<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>code injection on dronesec</title>
    <link>https://dronesec.pw/categories/code-injection/</link>
    <description>Recent content in code injection on dronesec</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Bryan Alexander</copyright>
    <lastBuildDate>Wed, 12 May 2021 15:10:04 +0000</lastBuildDate><atom:link href="https://dronesec.pw/categories/code-injection/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>the fanciful allure and utility of syscalls</title>
      <link>https://dronesec.pw/blog/the-fanciful-allure-and-utility-of-syscalls/</link>
      <pubDate>Wed, 12 May 2021 15:10:04 +0000</pubDate>
      
      <guid>https://dronesec.pw/blog/the-fanciful-allure-and-utility-of-syscalls/</guid>
      <description>So over the years I&amp;rsquo;ve had a number of conversations about the utility of using syscalls in shellcode, C2s, or loaders in offsec tooling and red team ops. For reasons likely related to the increasing maturity of EDRs and their totalitarian grip in enterprise environments, I&amp;rsquo;ve seen an uptick in projects and blogs championing &amp;ldquo;raw syscalls&amp;rdquo; as a technique for evading AV/SIEM technologies. This post is an attempt to describe why I think the technique&amp;rsquo;s efficacy has been overstated and its utility stretched thin.</description>
    </item>
    
    <item>
      <title>Code Execution via Fiber Local Storage</title>
      <link>https://dronesec.pw/blog/code-execution-via-fiber-local-storage/</link>
      <pubDate>Mon, 12 Aug 2019 15:10:04 +0000</pubDate>
      
      <guid>https://dronesec.pw/blog/code-execution-via-fiber-local-storage/</guid>
      <description>While working on another research project (post to be released soon, will update here), I stumbled onto a very Hexacorn[0] inspired type of code injection technique that fit my situation perfectly. Instead of tainting the other post with its description and code, I figured I&amp;rsquo;d release a separate post describing it here.
When I say that it&amp;rsquo;s Hexacorn inspired, I mean that the bulk of the strategy is similar to everything else you&amp;rsquo;ve probably seen; we open a handle to the remote process, allocate some memory, and copy our shellcode into it.</description>
    </item>
    
    <item>
      <title>Abusing delay load DLLs for remote code injection</title>
      <link>https://dronesec.pw/blog/abusing-delay-load-dlls-for-remote-code-injection/</link>
      <pubDate>Sun, 17 Sep 2017 15:00:00 +0000</pubDate>
      
      <guid>https://dronesec.pw/blog/abusing-delay-load-dlls-for-remote-code-injection/</guid>
      <description>I always tell myself that I&amp;rsquo;ll try posting more frequently on my blog, and yet here I am, two years later. Perhaps this post will provide the necessary motiviation to conduct more public research. I do love it.
This post details a novel remote code injection technique I discovered while playing around with delay loading DLLs. It allows for the injection of arbitrary code into arbitrary remote, running processes, provided that they implement the abused functionality.</description>
    </item>
    
  </channel>
</rss>
